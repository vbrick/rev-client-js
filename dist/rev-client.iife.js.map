{"version":3,"sources":["../src/index.ts","../src/utils/file-utils.ts","../src/utils/is-utils.ts","../src/utils/multipart-utils.ts","../src/interop/polyfills.ts","../src/utils/rate-limit.ts","../src/utils/rate-limit-queues.ts","../src/utils/index.ts","../src/rev-error.ts","../src/utils/paged-request.ts","../src/utils/request-utils.ts","../src/api/admin.ts","../src/utils/parse-csv.ts","../src/api/audit-request.ts","../src/api/audit.ts","../src/utils/merge-headers.ts","../src/api/oauth.ts","../src/api/auth.ts","../src/api/category.ts","../src/api/channel.ts","../src/api/device.ts","../src/api/group.ts","../src/api/playlist-details-request.ts","../src/api/playlist.ts","../src/api/recording.ts","../src/api/upload.ts","../src/api/user.ts","../src/api/video-download.ts","../src/api/video-external-access.ts","../src/api/video-report-request.ts","../src/api/video.ts","../src/api/webcast-report-request.ts","../src/api/webcast.ts","../src/api/zones.ts","../src/api/environment.ts","../src/rev-session.ts","../src/rev-client.ts"],"sourcesContent":["export * from './rev-client';\r\nexport * from './rev-error';\r\nexport type * from './types';\r\n\r\nimport {rateLimit} from './utils';\r\nimport {getExtensionForMime, getMimeForExtension} from './utils/file-utils';\r\nimport { setPolyfills } from './interop/polyfills';\r\n/**\r\n * Includes some helper utilities that may be useful when using this library\r\n * @category Utilities\r\n * @interface\r\n */\r\nexport const utils = {\r\n    /**\r\n     * Rate-limit a function - useful to throttle the number of API requests made in a minute\r\n     * @example\r\n     * ```js\r\n     * const {utils} = import '@vbrick/rev-client'\r\n     * const lock = utils.rateLimit(() => {}, { perSecond: 1 });\r\n     * for (let i = 0; i < 10; i++) {\r\n     *   await lock();\r\n     *   console.log(`${i}: this will only be called once per second`);\r\n     * }\r\n     * ```\r\n     */\r\n    rateLimit,\r\n    /**\r\n     * Get a valid file extension for a given mimetype (used for uploading videos/transcriptions/etc)\r\n     */\r\n    getExtensionForMime,\r\n    /**\r\n     * Get a valid mimetype for a given file extension (used for uploading videos/transcriptions/etc)\r\n     */\r\n    getMimeForExtension,\r\n    /**\r\n     * ADVANCED - Override the underlying classes used in making requests. This is for internal use only and shouldn't typically be used.\r\n     */\r\n    setPolyfills\r\n};\r\n\r\nimport { RevClient } from './rev-client';\r\nexport default RevClient;\r\n","\r\nexport const mimeTypes = {\r\n    '.7z': 'application/x-7z-compressed',\r\n    '.asf': 'video/x-ms-asf',\r\n    '.avi': 'video/x-msvideo',\r\n    '.csv': 'text/csv',\r\n    '.doc': 'application/msword',\r\n    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n    '.f4v': 'video/x-f4v',\r\n    '.flv': 'video/x-flv',\r\n    '.gif': 'image/gif',\r\n    '.jpg': 'image/jpeg',\r\n    '.m4a': 'audio/mp4',\r\n    '.m4v': 'video/x-m4v',\r\n    '.mkv': 'video/x-matroska',\r\n    '.mov': 'video/quicktime',\r\n    '.mp3': 'audio/mpeg',\r\n    '.mp4': 'video/mp4',\r\n    '.mpg': 'video/mpeg',\r\n    '.pdf': 'application/pdf',\r\n    '.png': 'image/png',\r\n    '.ppt': 'application/vnd.ms-powerpoint',\r\n    '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\r\n    '.rar': 'application/x-rar-compressed',\r\n    '.srt': 'application/x-subrip',\r\n    '.svg': 'image/svg+xml',\r\n    '.swf': 'application/x-shockwave-flash',\r\n    '.ts': 'video/mp2t',\r\n    '.txt': 'text/plain',\r\n    '.wmv': 'video/x-ms-wmv',\r\n    '.xls': 'application/vnd.ms-excel',\r\n    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n    '.zip': 'application/zip',\r\n    '.mks': 'video/x-matroska',\r\n    '.mts': 'model/vnd.mts',\r\n    '.vtt': 'text/vtt',\r\n    '.wma': 'audio/x-ms-wma'\r\n};\r\n\r\nexport function getMimeForExtension(extension: string = '', defaultType = 'video/mp4') {\r\n    extension = extension.toLowerCase();\r\n    if (extension && (extension in mimeTypes)) {\r\n        return mimeTypes[extension as keyof typeof mimeTypes];\r\n    }\r\n    return defaultType;\r\n}\r\n\r\nexport function getExtensionForMime(contentType: string, defaultExtension = '.mp4') {\r\n    const match = contentType && Object.entries(mimeTypes)\r\n        .find(([ext, mime]) => contentType.startsWith((mime)));\r\n    return match\r\n        ? match[0]\r\n        : defaultExtension;\r\n\r\n}\r\n\r\nexport function sanitizeUploadOptions(filename = 'upload', contentType = '', defaultContentType?: string) {\r\n    // sanitize content type\r\n    if (contentType === 'application/octet-stream') {\r\n        contentType = '';\r\n    }\r\n    if (/charset/.test(contentType)) {\r\n        contentType = contentType.replace(/;?.*charset.*$/, '');\r\n    }\r\n    let [name, ext] = filename.split(/(?=\\.[^\\.\\\\\\/]+$)/);\r\n    ext ||= getExtensionForMime(contentType || defaultContentType || '');\r\n\r\n    filename = `${name}${ext}`;\r\n\r\n    // extra check for transcription filetype\r\n    if (!contentType || ['.vtt', '.srt'].includes(ext)) {\r\n        contentType = getMimeForExtension(ext, defaultContentType);\r\n    }\r\n\r\n    return { filename, contentType };\r\n}\r\n\r\n","const { toString: _toString } = Object.prototype;\r\n\r\nexport function isPlainObject<T = { [key: string]: any; } | any[]>(val: unknown): val is T {\r\n    if (_toString.call(val) !== '[object Object]') {\r\n        return false;\r\n    }\r\n    const prototype = Object.getPrototypeOf(val);\r\n    return prototype === null || prototype === Object.getPrototypeOf({ });\r\n}\r\n\r\nexport function isBlobLike(val: unknown): val is Blob | File {\r\n    return typeof (val as Blob)?.stream === 'function';\r\n}\r\n\r\nexport function isReadable<T = any>(val: unknown): val is AsyncIterable<T> {\r\n    return typeof (val as AsyncIterable<T>)[Symbol.asyncIterator] === 'function';\r\n}\r\n\r\nexport function titleCase(val: string) {\r\n    return `${val[0]}${val.slice(1)}`;\r\n}\r\n\r\n// exclude 0 / false from falsy check\r\nexport function isBlank(val: any) {\r\n    return val == undefined || val === '';\r\n}\r\n","import polyfills from '../interop/polyfills';\r\nimport type { RevClient } from '../rev-client';\r\nimport { RevError } from '../rev-error';\r\nimport type { Rev } from '../types/index';\r\nimport { sanitizeUploadOptions } from './file-utils';\r\nimport { isBlobLike } from './is-utils';\r\n\r\nconst LOCAL_PROTOCOLS = ['blob:', 'data:'];\r\n\r\nexport const uploadParser = {\r\n    async string(value: string | URL, options: Rev.UploadFileOptions) {\r\n        const url = polyfills.parseUrl(value);\r\n\r\n        if (LOCAL_PROTOCOLS.includes(url.protocol)) {\r\n            const file = await (await polyfills.fetch(url)).blob();\r\n            return uploadParser.blob(file, options);\r\n        }\r\n\r\n        if (options.disableExternalResources) {\r\n            throw new Error(`${url.protocol} protocol not allowed`);\r\n        }\r\n\r\n        if (url.protocol === 'file:') {\r\n            return uploadParser.localFile(url, options);\r\n        }\r\n        // for backwards compatibility https streams are not supported\r\n        throw new TypeError('Only Blob / DateURI URLs are supported');\r\n    },\r\n    async localFile(url: URL, options: Rev.UploadFileOptions) {\r\n        if (options.disableExternalResources) {\r\n            throw new Error('file: protocol not allowed');\r\n        }\r\n        // as of 2025 only Deno supports file:// fetch\r\n        return uploadParser.response(await polyfills.fetch(url), options);\r\n    },\r\n    async stream(value: AsyncIterable<Uint8Array>, options: Rev.UploadFileOptions) {\r\n        const {contentType} = options;\r\n        // allow web streams only\r\n        if (!(value instanceof ReadableStream)) {\r\n            throw new TypeError('Only Blob / Files are supported for file uploads. Pass a File/Blob object');\r\n        }\r\n        // FormData doesn't support readable streams unfortunately, so read to blob\r\n        const response = new Response(value, {\r\n            headers: contentType ? { 'content-type': contentType } : {}\r\n        });\r\n        return uploadParser.response(response, options);\r\n    },\r\n    async response(response: Response, options: Rev.UploadFileOptions) {\r\n        const { body, headers } = response;\r\n        if (!response.ok || !body) {\r\n            const err = await RevError.create(response);\r\n            throw err;\r\n        }\r\n        return uploadParser.blob(\r\n            await response.blob(),\r\n            options\r\n        );\r\n    },\r\n    async blob(value: Blob | File, options: Rev.UploadFileOptions) {\r\n        let {\r\n            filename = (value as File).name ?? 'upload',\r\n            contentType = value.type ?? '',\r\n            defaultContentType\r\n        } = options;\r\n\r\n        const sanitized = sanitizeUploadOptions(filename, contentType, defaultContentType);\r\n\r\n        if (value.type !== sanitized.contentType && typeof value.slice === 'function') {\r\n            value = new File([value], sanitized.filename, { type: sanitized.contentType });\r\n        }\r\n        return {\r\n            file: value,\r\n            options: {\r\n                ...options,\r\n                ...value.size && { contentLength: value.size },\r\n                ...sanitized\r\n            }\r\n        };\r\n    },\r\n    async parse(value: Rev.FileUploadType, options: Rev.UploadFileOptions) {\r\n        if (typeof value === 'string' || value instanceof URL) {\r\n            return uploadParser.string(value, options);\r\n        }\r\n        if (value instanceof polyfills.Response) {\r\n            return uploadParser.response(value, options);\r\n        }\r\n        if (!isBlobLike(value)) {\r\n            throw new TypeError('Only Blob / Files are supported for file uploads. Pass a File/Blob object');\r\n        }\r\n        return uploadParser.blob(value, options);\r\n    }\r\n}\r\n\r\n\r\nexport function appendJSONToForm(form: FormData, fieldName: string, data: any) {\r\n    form.append(fieldName, JSON.stringify(data));\r\n}\r\n/**\r\n * This method is included for isometric support of uploading files in node.js and browser.\r\n * @param form FormData instance\r\n * @param fieldName name of field to add to form\r\n * @param file the file. Can be Blob or File on browser. On node.js it can be anything the 'form-data' package will accept\r\n * @param options optional filename, contentType and contentLength of upload. Otherwise it will try to guess based on input\r\n */\r\n\r\nexport async function appendFileToForm(form: FormData, fieldName: string, input: Rev.FileUploadType, uploadOptions: Rev.UploadFileOptions = {}): Promise<Rev.UploadFileOptions> {\r\n    const {\r\n        file,\r\n        options\r\n    } = await polyfills.uploadParser.parse(input, uploadOptions)\r\n    form.append(fieldName, file, options.filename);\r\n    return options;\r\n}\r\n/**\r\n * helper to upload multipart forms with files attached.\r\n * This is to work around issues with node.js's FormData implementation\r\n * @param rev Rev Client\r\n * @param method\r\n * @param endpoint\r\n * @param form\r\n * @param useChunkedTransfer\r\n * @param options\r\n * @returns\r\n */\r\n\r\nexport async function uploadMultipart(\r\n    rev: RevClient,\r\n    method: Rev.HTTPMethod,\r\n    endpoint: string,\r\n    form: FormData,\r\n    uploadOptions: Rev.UploadFileOptions,\r\n    options: Rev.RequestOptions = {}\r\n) {\r\n    const {\r\n        headers: optHeaders\r\n    } = options;\r\n\r\n    // coerce to Headers object, may be undefined\r\n    const headers = new polyfills.Headers(optHeaders);\r\n    options.headers = headers;\r\n\r\n    // switches to transfer encoding upload if necessary in node\r\n    // returns the body payload (on node.js it mutates options to set the body)\r\n    const data = polyfills.beforeFileUploadRequest(form, headers, uploadOptions, options);\r\n\r\n    const { body } = await rev.request(method, endpoint, data, options);\r\n    return body;\r\n}\r\n","/**\r\n * There are slight differences in handling browser and node.js environments.\r\n * This folder wraps all components that get polyfilled in node.js, as well as\r\n * allowing uploading a video from the local filesystem on node.js\r\n */\r\nimport { uploadParser } from '../utils/multipart-utils';\r\nimport type { Rev } from '../types/rev';\r\n\r\n/**\r\n * used in OAuth - get random verifier string\r\n * @param byteLength\r\n */\r\nfunction randomValues(byteLength: number) {\r\n    const values = crypto.getRandomValues(new Uint8Array(byteLength / 2));\r\n    return Array.from(values)\r\n        .map(c => c.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n/**\r\n * sha256 hash function for oauth2 pkce\r\n * @param value\r\n * @returns\r\n */\r\nasync function sha256Hash(value: string) {\r\n    const bytes = new TextEncoder().encode(value);\r\n    const hashed = await crypto.subtle.digest('SHA-256', bytes);\r\n    const binary = String.fromCharCode(...(new Uint8Array(hashed)));\r\n    return btoa(binary)\r\n        .replace(/\\//g, '_')\r\n        .replace(/\\+/g, '-')\r\n        .replace(/=+$/, '');\r\n}\r\n\r\n\r\n/**\r\n * used to sign the verifier in OAuth workflow\r\n */\r\nasync function hmacSign(message: string, secret: string) {\r\n    const enc = new TextEncoder();\r\n    const cryptoKey = await crypto.subtle\r\n        .importKey(\r\n            'raw',\r\n            enc.encode(secret),\r\n            { name: 'HMAC', hash: 'SHA-256' },\r\n            true,\r\n            ['sign']\r\n        );\r\n    const signed = await crypto.subtle.sign('HMAC', cryptoKey, enc.encode(message));\r\n    return btoa(String.fromCharCode(...new Uint8Array(signed)));\r\n}\r\n\r\nexport const polyfills: RevPolyfills = {\r\n    AbortController: globalThis.AbortController,\r\n    AbortSignal: globalThis.AbortSignal,\r\n    createAbortError(message: string): Error {\r\n        return new DOMException(message, 'AbortError');\r\n    },\r\n    fetch(...args: Parameters<typeof fetch>) { return globalThis.fetch(...args); },\r\n    FormData: globalThis.FormData,\r\n    File: globalThis.File,\r\n    Headers: globalThis.Headers,\r\n    Request: globalThis.Request,\r\n    Response: globalThis.Response,\r\n    uploadParser,\r\n    randomValues,\r\n    sha256Hash,\r\n    hmacSign,\r\n    parseUrl(value: string | URL) {\r\n        return value instanceof URL ? value : new URL(value, 'invalid://');\r\n    },\r\n    beforeFileUploadRequest(form: FormData, headers: Headers, uploadOptions: Rev.UploadFileOptions, options: Rev.RequestOptions): FormData | undefined {\r\n        return form;\r\n    },\r\n    asPlatformStream<TIn = any, TOut = TIn>(stream: TIn): TOut {\r\n        // nothing - this is used for fixing node's stream response\r\n        return stream as any;\r\n    },\r\n    asWebStream<TIn = any>(stream: TIn): ReadableStream {\r\n        // nothing - this is used for fixing node's stream response\r\n        return stream as any;\r\n    }\r\n}\r\nexport default polyfills;\r\n\r\n/**\r\n * ADVANCED - this includes library dependencies that may need to be overridden based on the current platform.\r\n * @category Utilities\r\n */\r\nexport interface RevPolyfills {\r\n    AbortController: typeof AbortController,\r\n    AbortSignal: typeof AbortSignal,\r\n    createAbortError(message: string): Error;\r\n    fetch(input: string | URL | Request, init?: RequestInit | undefined): Promise<Response>;\r\n    FormData: typeof FormData;\r\n    File: typeof File;\r\n    Headers: typeof Headers;\r\n    Request: typeof Request;\r\n    Response: typeof Response;\r\n    parseUrl(value: string | URL): URL;\r\n    uploadParser: {\r\n        string(value: string | URL, options: Rev.UploadFileOptions): Promise<{\r\n            file: Blob | File;\r\n            options: Rev.UploadFileOptions;\r\n        }>;\r\n        localFile(value: URL, options: Rev.UploadFileOptions): Promise<{\r\n            file: Blob | File;\r\n            options: Rev.UploadFileOptions;\r\n        }>\r\n        stream(value: AsyncIterable<Uint8Array>, options: Rev.UploadFileOptions): Promise<{\r\n            file: Blob | File;\r\n            options: Rev.UploadFileOptions;\r\n        }>;\r\n        response(response: Response, options: Rev.UploadFileOptions): Promise<{\r\n            file: Blob | File;\r\n            options: Rev.UploadFileOptions;\r\n        }>;\r\n        blob(value: Blob | File, options: Rev.UploadFileOptions): Promise<{\r\n            file: Blob | File;\r\n            options: Rev.UploadFileOptions;\r\n        }>;\r\n        parse(value: Rev.FileUploadType, options: Rev.UploadFileOptions): Promise<{\r\n            file: Blob | File;\r\n            options: Rev.UploadFileOptions;\r\n        }>;\r\n    };\r\n    randomValues(byteLength: number): string;\r\n    sha256Hash(value: string): Promise<string>;\r\n    hmacSign(message: string, secret: string): Promise<string>;\r\n    beforeFileUploadRequest(form: FormData, headers: Headers, uploadOptions: Rev.UploadFileOptions, options: Rev.RequestOptions): FormData | undefined;\r\n    asPlatformStream<TIn = any, TOut = TIn>(stream: TIn): TOut;\r\n    asWebStream<TIn = any>(stream: TIn): ReadableStream;\r\n}\r\n\r\n// logic for overriding polyfills before first network request\r\ntype InitializeCallback = (polyfills: RevPolyfills) => Promise<void> | void;\r\nlet isPendingInitialize = false;\r\nlet initializePromise: Promise<void> | undefined = undefined;\r\nconst pendingInitialize: InitializeCallback[] = [];\r\n\r\nexport function shouldInitialize() {\r\n    return !!isPendingInitialize;\r\n}\r\n\r\nexport function onInitialize() {\r\n    if (!isPendingInitialize) {\r\n        return;\r\n    }\r\n\r\n    initializePromise ||= (async () => {\r\n        while (pendingInitialize.length > 0) {\r\n            const pending = pendingInitialize.shift();\r\n            if (typeof pending !== 'function') continue;\r\n            try {\r\n                const overrides = await pending(polyfills);\r\n                Object.assign(polyfills, overrides);\r\n            } catch (error) {\r\n                // ignore\r\n            }\r\n        }\r\n        isPendingInitialize = false;\r\n        initializePromise = undefined;\r\n    })();\r\n\r\n    return initializePromise;\r\n}\r\n\r\n/**\r\n * ADVANCED - override the underlying implementation used when constructing requests/other primitive values.\r\n * This is used internally and should not be used unless you absolutely need to change some particular behavior (for example, using a different `fetch` implementation)\r\n * @param overrideCallback\r\n */\r\nexport function setPolyfills(overrideCallback: (polyfills: RevPolyfills) => Promise<void> | void) {\r\n    pendingInitialize.push(overrideCallback);\r\n    isPendingInitialize = true;\r\n}\r\n","import polyfills from '../interop/polyfills';\r\n\r\nconst ONE_MINUTE = 60 * 1000;\r\n\r\n/** @category Utilities */\r\nexport interface RateLimitOptions {\r\n    /**\r\n     * how many to allow in parallel in any given interval\r\n     * @default 1\r\n     */\r\n    limit?: number,\r\n    /**\r\n     * interval in milliseconds\r\n     */\r\n    interval?: number,\r\n    /**\r\n     * set limit to X per second\r\n     */\r\n    perSecond?: number,\r\n    /**\r\n     * set limit to X per minute (can be fraction, i.e. 0.5 for 1 every 2 minutes)\r\n     */\r\n    perMinute?: number,\r\n    /**\r\n     * set limit to X per hour\r\n     */\r\n    perHour?: number,\r\n    /**\r\n     * cancel with AbortController\r\n     */\r\n    signal?: AbortSignal,\r\n}\r\n\r\n/**\r\n * @category Utilities\r\n * @inline\r\n */\r\nexport type ThrottledFunction<T extends (...args: any[]) => any> = (\r\n    (...args: Parameters<T>) => ReturnType<T> extends PromiseLike<infer Return> ? Promise<Return> : Promise<ReturnType<T>>\r\n) & {\r\n    /**\r\n     * Abort pending executions. All unresolved promises are rejected with a `AbortError` error.\r\n     * @param {string} [message] - message parameter for rejected AbortError\r\n     * @param {boolean} [dispose] - remove abort signal listener as well\r\n     */\r\n    abort: (message?: string, dispose?: boolean) => void;\r\n};\r\n\r\n/** @inline */\r\ntype RateLimitOptionsWithFn<T> = RateLimitOptions & {\r\n\r\n    /**\r\n     * function to rate limit\r\n     */\r\n    fn: T\r\n}\r\n\r\ntype TimeoutRef = ReturnType<typeof setTimeout>;\r\n\r\nfunction rateLimit<T extends (...args: any) => any>(options: RateLimitOptionsWithFn<T>): ThrottledFunction<T>;\r\nfunction rateLimit<T extends (...args: any) => any>(fn: T, options: RateLimitOptions): ThrottledFunction<T>;\r\nfunction rateLimit<T extends (...args: any) => any>(fn: T | RateLimitOptionsWithFn<T>, options?: RateLimitOptions): ThrottledFunction<T>;\r\n\r\n/**\r\n *\r\n * adapted from {@link https://github.com/sindresorhus/p-throttle | p-throttle}\r\n * @param fn\r\n * @param options\r\n * @returns\r\n */\r\nfunction rateLimit<T extends (...args: any) => any> (fn: T | RateLimitOptionsWithFn<T>, options: RateLimitOptions = {}) {\r\n    if (fn && (typeof fn === 'object')) {\r\n        options = Object.assign({}, fn, options);\r\n        fn = undefined as unknown as T;\r\n    }\r\n    if (!fn) {\r\n        fn = (options as RateLimitOptionsWithFn<T>).fn;\r\n    }\r\n\r\n    if (typeof fn !== 'function') {\r\n        throw new TypeError('Rate limit function is not a function');\r\n    }\r\n\r\n    const {\r\n        perSecond,\r\n        perMinute,\r\n        perHour,\r\n        signal\r\n    } = options;\r\n\r\n    let limit = parseFloat(options.limit as unknown as string) || 1;\r\n    let interval = parseInt(options.interval as unknown as string, 10);\r\n\r\n    if (perSecond) {\r\n        limit = parseFloat(perSecond as unknown as string);\r\n        interval = 1000;\r\n    }\r\n    if (perMinute) {\r\n        limit = parseFloat(perMinute as unknown as string);\r\n        interval = ONE_MINUTE;\r\n    }\r\n    if (perHour) {\r\n        limit = parseFloat(perHour as unknown as string);\r\n        interval = ONE_MINUTE * 60;\r\n    }\r\n\r\n    if (limit < 1) {\r\n        interval /= limit;\r\n        limit = 1;\r\n    } else {\r\n        // just make sure it isn't a faction for some silly reason\r\n        limit = Math.floor(limit);\r\n    }\r\n\r\n    if (!Number.isFinite(limit)) {\r\n        throw new TypeError(`Invalid limit ${limit}`);\r\n    }\r\n\r\n    if (!Number.isFinite(interval) || interval <= 0) {\r\n        throw new TypeError('Invalid interval option');\r\n    }\r\n\r\n    const queue:Map<TimeoutRef, (err: Error) => any> = new Map();\r\n\r\n    let currentTick = 0;\r\n    let activeCount = 0;\r\n\r\n    type Return = ReturnType<T> extends PromiseLike<infer R> ? Promise<R> : Promise<ReturnType<T>>;\r\n\r\n    const throttled = function (...args: Parameters<T>) {\r\n        let timeout: TimeoutRef;\r\n        return new Promise((resolve, reject) => {\r\n            const execute = () => {\r\n                resolve((fn as T).apply(null, args));\r\n                queue.delete(timeout);\r\n            };\r\n\r\n            const now = Date.now();\r\n\r\n            if ((now - currentTick) > interval) {\r\n                activeCount = 1;\r\n                currentTick = now;\r\n            } else if (activeCount < limit) {\r\n                activeCount++;\r\n            } else {\r\n                currentTick += interval;\r\n                activeCount = 1;\r\n            }\r\n\r\n            timeout = setTimeout(execute, currentTick - now);\r\n\r\n            // used for sending cancel error\r\n            queue.set(timeout, reject);\r\n        }) as Return;\r\n    };\r\n\r\n    let abortHandler = signal\r\n        ? () => throttled.abort(signal.reason ? `${signal.reason}` : undefined, true)\r\n        : undefined;\r\n\r\n    throttled.abort = (message: string = 'Cancelled rate-limit queue', dispose: boolean = false) => {\r\n        if (dispose) {\r\n            signal?.removeEventListener('abort', abortHandler!);\r\n        }\r\n        for (const [timeout, reject] of queue.entries()) {\r\n            clearTimeout(timeout);\r\n            reject(polyfills.createAbortError(message));\r\n        }\r\n\r\n        queue.clear();\r\n    };\r\n\r\n    signal?.addEventListener('abort', abortHandler!);\r\n\r\n    return throttled;\r\n}\r\n\r\nexport default rateLimit;\r\n","import rateLimit from \"./rate-limit\";\r\nimport type {ThrottledFunction} from \"./rate-limit\";\r\n\r\n/**\r\n * @inline\r\n */\r\nexport enum RateLimitEnum {\r\n    Get = 'get',\r\n    Post = 'post',\r\n    SearchVideos = 'searchVideos',\r\n    UploadVideo = 'uploadVideo',\r\n    AuditEndpoints = 'auditEndpoint',\r\n    UpdateVideoMetadata = 'updateVideo',\r\n    GetUsersByLoginDate = 'loginReport',\r\n    GetVideoDetails = 'videoDetails',\r\n    GetWebcastAttendeesRealtime = 'attendeesRealtime',\r\n    GetVideoViewReport = 'viewReport'\r\n}\r\n\r\nexport type RateLimits = { [K in RateLimitEnum]?: number }\r\nexport type RateLimitQueues = { [K in RateLimitEnum]?: () => Promise<void> };\r\n\r\nexport const defaultRateLimits: Required<RateLimits> = {\r\n    [RateLimitEnum.Get]: 24000,\r\n    [RateLimitEnum.Post]: 3600,\r\n    [RateLimitEnum.SearchVideos]: 120,\r\n    [RateLimitEnum.UploadVideo]: 30,\r\n    [RateLimitEnum.UpdateVideoMetadata]: 30,\r\n    [RateLimitEnum.GetVideoDetails]: 2000,\r\n    [RateLimitEnum.GetWebcastAttendeesRealtime]: 2,\r\n    [RateLimitEnum.AuditEndpoints]: 60,\r\n    [RateLimitEnum.GetUsersByLoginDate]: 10,\r\n    [RateLimitEnum.GetVideoViewReport]: 120,\r\n};\r\n\r\n// passthrough placeholder for ratelimit\r\nconst fn = () => Promise.resolve();\r\n\r\nexport function normalizeRateLimitOptions(rateLimits?: boolean | RateLimits): RateLimits {\r\n    return {\r\n        // include defaults if true or object\r\n        ...rateLimits && defaultRateLimits,\r\n        ...(typeof rateLimits === 'object') && rateLimits\r\n    };\r\n}\r\n\r\nexport function makeQueue(key: RateLimitEnum, value?: number) {\r\n    const defaultValue = defaultRateLimits[key];\r\n    const perMinute = value ?? defaultValue;\r\n    // 0, -1, null or Infinity get treated as no rate limiting\r\n    if (!isFinite(perMinute) || perMinute <= 0) {\r\n        return fn;\r\n    }\r\n    // split into 5 sec increments to even out request flow\r\n    const limit = perMinute / 12;\r\n    const interval = 5000;\r\n    return rateLimit({ fn, limit, interval });\r\n}\r\n\r\n/**\r\n * create a dict of rate limited-locks based on input options\r\n * @param rateLimits\r\n * @returns\r\n */\r\nexport function makeQueues(rateLimits: RateLimits = {}): RateLimitQueues {\r\n    const entries = (Object.keys(defaultRateLimits) as RateLimitEnum[])\r\n        .map(key => [key, makeQueue(key, rateLimits[key])]);\r\n\r\n    return Object.fromEntries(entries);\r\n}\r\n\r\nexport function clearQueues(rateLimits: RateLimitQueues, message?: string) {\r\n    const fns = Object.values(rateLimits) as Array<Partial<ThrottledFunction<() => void>>>;\r\n    fns.forEach(fn => fn.abort?.(message));\r\n}\r\n","export {default as rateLimit, type RateLimitOptions} from './rate-limit';\r\nexport {RateLimitEnum} from './rate-limit-queues';\r\nexport type {RateLimits} from './rate-limit-queues';\r\n\r\nexport * from './is-utils';\r\n\r\nexport function asValidDate(val: string | Date | undefined): Date | undefined;\r\nexport function asValidDate(val: string | Date | undefined, defaultValue: Date): Date;\r\nexport function asValidDate(val: string | Date | undefined, defaultValue?: Date): Date | undefined {\r\n    if (!val) {\r\n        return defaultValue;\r\n    }\r\n    if (!(val instanceof Date)) {\r\n        val = new Date(val);\r\n    }\r\n    return isNaN(val.getTime())\r\n    ? defaultValue\r\n    : val;\r\n}\r\n\r\n/**\r\n * Retry a function multiple times, sleeping before attempts\r\n * @param {() => Promise<T>} fn function to attempt. Return value if no error thrown\r\n * @param {(err: Error, attempt: number) => boolean} [shouldRetry] callback on error.\r\n * @param {number} [maxAttempts] maximum number of retry attempts before throwing error\r\n * @param {number} [sleepMilliseconds] milliseconds to wait between attempts\r\n * @returns {Promise<T>}\r\n */\r\nexport async function retry<T, E extends Error>(fn: () => Promise<T>, shouldRetry: (err: E, attempt?: number) => boolean = () => true, maxAttempts: number = 3, sleepMilliseconds: number = 1000) {\r\n    let attempt = 0;\r\n    while (attempt < maxAttempts) {\r\n        try {\r\n            const result = await fn();\r\n            return result;\r\n        } catch (err: any) {\r\n            attempt += 1;\r\n            if (attempt >= maxAttempts || !shouldRetry(err, attempt)) {\r\n                throw err;\r\n            }\r\n            await sleep(sleepMilliseconds);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * delay async execution, with optional early exit using abort signal\r\n * @param ms\r\n * @param signal\r\n * @returns\r\n */\r\nexport async function sleep(ms: number, signal?: AbortSignal) {\r\n    return new Promise<void>(done => {\r\n        let timer: ReturnType<typeof setTimeout>;\r\n        const cleanup = () => {\r\n            clearTimeout(timer);\r\n            signal?.removeEventListener('abort', cleanup);\r\n            done();\r\n        };\r\n        timer = setTimeout(cleanup, ms);\r\n        signal?.addEventListener('abort', cleanup);\r\n    });\r\n}\r\n\r\n/** try to parse as json */\r\nexport function tryParseJson(val: string): any {\r\n    if (val !== 'null' && val) {\r\n        try {\r\n            return JSON.parse(val);\r\n        } catch (err) {\r\n            // nothing\r\n        }\r\n    }\r\n    return null;\r\n};\r\n","import { isPlainObject, tryParseJson } from './utils';\r\n\r\n/**\r\n * A custom error for parsing and handling Error HTTP responses from Rev.\r\n * @category Getting Started\r\n */\r\nexport class RevError extends Error {\r\n    /**\r\n     * HTTP Status Code\r\n     */\r\n    status: number;\r\n    /**\r\n     * Request URL/endpoint\r\n     */\r\n    url: string;\r\n    /**\r\n     * Rev-specific error code\r\n     */\r\n    code: string;\r\n    /**\r\n     * Additional error message returned by Rev API\r\n     */\r\n    detail: string;\r\n    /**\r\n     * @hidden\r\n     * @param response\r\n     * @param body\r\n     */\r\n    constructor(response: Response, body: { [key: string]: any; } | string) {\r\n        const {\r\n            status = 500,\r\n            statusText = '',\r\n            url\r\n        } = response;\r\n        super(`${status} ${statusText}`);\r\n        // Chrome/node specific function\r\n        if ('captureStackTrace' in Error) {\r\n            (Error as any).captureStackTrace(this, this.constructor);\r\n        }\r\n\r\n        this.status = status;\r\n        this.url = url;\r\n        this.code = `${status}`;\r\n        this.detail = statusText;\r\n        // Some Rev API responses include additional details in its body\r\n        if (isPlainObject<Record<string, string>>(body)) {\r\n            if (body.code) {\r\n                this.code = body.code;\r\n            }\r\n            if (body.detail) {\r\n                this.detail = body.detail;\r\n            }\r\n        } else if (typeof body === 'string') {\r\n            body = body.trim();\r\n            // try to parse as JSON\r\n            if (body.startsWith('{')) {\r\n                const { code, detail } = tryParseJson(body) || { };\r\n                if (code) { this.code = code; }\r\n                if (detail) { this.detail = detail; }\r\n            } else if (this.status === 429) {\r\n                this.detail = 'Too Many Requests';\r\n            } else if (/^(<!DOCTYPE|<html)/.test(body)) {\r\n                // if html then strip out the extra cruft\r\n                this.detail = body\r\n                    .replace(/.*<body>\\s+/s, '')\r\n                    .replace(/<\\/body>.*/s, '')\r\n                    .slice(0, 256);\r\n            }\r\n        }\r\n    }\r\n    /** @ignore */\r\n    override get name() {\r\n        return 'RevError';\r\n    }\r\n    /** @ignore */\r\n    get [Symbol.toStringTag]() {\r\n        return 'RevError';\r\n    }\r\n    /**\r\n     * Consume a HTTP Response's body to create a new Error instance\r\n     * @param response\r\n     * @returns\r\n     */\r\n    static async create(response: Response) {\r\n        let body: any;\r\n\r\n        try {\r\n            // retrieve body - constructor will decode as json\r\n            body = await response.text();\r\n        } catch (err) {\r\n            body = {\r\n                code: 'Unknown',\r\n                detail: `Unable to parse error response body: ${err}`\r\n            };\r\n        }\r\n        return new RevError(response, body);\r\n    }\r\n}\r\n\r\n/**\r\n * This error is not very common - when calling Search APIs this may be thrown if paging through search results takes too long.\r\n * @category Utilities\r\n */\r\nexport class ScrollError extends Error {\r\n    /**\r\n     * HTTP Status Code\r\n     */\r\n    status: number;\r\n\r\n    /**\r\n     * Rev-specific error code\r\n     */\r\n    code: string;\r\n    /**\r\n     * Additional error message returned by Rev API\r\n     */\r\n    detail: string;\r\n    /**\r\n     * @hidden\r\n     * @param status\r\n     * @param code\r\n     * @param detail\r\n     */\r\n    constructor(status: number = 408, code: string = 'ScrollExpired', detail: string = 'Timeout while fetching all results in search request') {\r\n        super('Search Scroll Expired');\r\n        Error.captureStackTrace(this, this.constructor);\r\n        this.status = status;\r\n        this.code = code;\r\n        this.detail = detail;\r\n    }\r\n    /** @ignore */\r\n    override get name() {\r\n        return this.constructor.name;\r\n    }\r\n    /** @ignore */\r\n    get [Symbol.toStringTag]() {\r\n        return this.constructor.name;\r\n    }\r\n}\r\n","import type { Rev } from '../types/rev';\r\n\r\n/**\r\n * A page of results returned from `.nextPage()`\r\n * @category Utilities\r\n */\r\nexport interface IPageResponse<T> {\r\n    items: T[],\r\n    done: boolean,\r\n    total?: number,\r\n    pageCount?: number,\r\n    error?: Error\r\n}\r\n\r\n/**\r\n * Interface to iterate through results from API endpoints that return results in pages.\r\n * Use in one of three ways:\r\n * 1) Get all results as an array: `await request.exec() == <array>`\r\n * 2) Get each page of results: `await request.nextPage() == { current, total, items: <array> }`\r\n * 3) Use for await to get all results one at a time: `for await (let hit of request) { }`\r\n * @category Utilities\r\n */\r\nexport abstract class PagedRequest<ItemType> implements Rev.ISearchRequest<ItemType> {\r\n    current: number;\r\n    total: number | undefined;\r\n    done: boolean;\r\n    options: Required<Rev.SearchOptions<ItemType>>;\r\n    /**\r\n     * @hidden\r\n     * @param options\r\n     */\r\n    constructor(options: Rev.SearchOptions<ItemType> = {}) {\r\n        this.options = {\r\n            maxResults: Infinity,\r\n            onProgress: (items: ItemType[], current: number, total?: number) => {},\r\n            onError: (err => { throw err; }),\r\n            onScrollError: (err => {\r\n                console.warn(\"DEPRECATED: use onError instead of onScrollError with rev search requests\");\r\n                this.options.onError(err);\r\n            }),\r\n            signal: undefined as any,\r\n            ...options\r\n        };\r\n\r\n        this.current = 0;\r\n        this.total = undefined;\r\n        this.done = false;\r\n    }\r\n    protected abstract _requestPage(): Promise<IPageResponse<ItemType>>;\r\n    /**\r\n     * Get the next page of results from API\r\n     */\r\n    async nextPage(): Promise<Rev.SearchPage<ItemType>> {\r\n        const {\r\n            onProgress,\r\n            onError,\r\n            signal\r\n        } = this.options;\r\n\r\n        if (signal?.aborted) this.done = true;\r\n\r\n        if (this.done) {\r\n            return {\r\n                current: this.current,\r\n                total: this.current,\r\n                done: this.done,\r\n                items: []\r\n            };\r\n        }\r\n\r\n        const page = await this._requestPage();\r\n        const result = this._parsePage(page);\r\n\r\n        let {\r\n            current,\r\n            items,\r\n            total,\r\n            done,\r\n            error\r\n        } = result;\r\n\r\n        onProgress(items, current, total);\r\n\r\n        if (error) {\r\n            onError(error);\r\n        }\r\n\r\n        return {\r\n            current,\r\n            items,\r\n            total,\r\n            done\r\n        };\r\n    }\r\n    /**\r\n     * update internal variables based on API response\r\n     * @param page\r\n     * @returns\r\n     */\r\n    protected _parsePage(page: IPageResponse<ItemType>) {\r\n        const { maxResults } = this.options;\r\n\r\n        let {\r\n            items = [],\r\n            done = this.done,\r\n            total,\r\n            pageCount,\r\n            error,\r\n        } = page;\r\n\r\n        // let request function set done status\r\n        if (done) {\r\n            this.done = true;\r\n        }\r\n\r\n        // update total\r\n        if (isFinite(total!)) {\r\n            this.total = Math.min(total!, maxResults);\r\n        }\r\n\r\n        if (!pageCount) {\r\n            pageCount = items.length;\r\n        }\r\n\r\n        const current = this.current;\r\n\r\n        // limit results to specified max results\r\n        if (current + pageCount >= maxResults) {\r\n            pageCount = maxResults - current;\r\n            items = items.slice(0, pageCount);\r\n            this.done = true;\r\n        }\r\n\r\n        this.current += pageCount;\r\n\r\n        if (this.total != undefined && this.current >= this.total) {\r\n            this.done = true;\r\n        }\r\n\r\n        if (this.done) {\r\n            // set total to current for results where not otherwise known in advance\r\n            this.total = this.current;\r\n        }\r\n\r\n        if (error) {\r\n            this.done = true;\r\n        }\r\n\r\n        return {\r\n            current,\r\n            total: this.total,\r\n            done: this.done,\r\n            error,\r\n            items\r\n        };\r\n    }\r\n    /**\r\n     * Go through all pages of results and return as an array.\r\n     * TIP: Use the {maxResults} option to limit the maximum number of results\r\n     *\r\n     */\r\n    async exec(): Promise<ItemType[]> {\r\n        const results: ItemType[] = [];\r\n        // use async iterator\r\n        for await (let hit of this) {\r\n            results.push(hit);\r\n        }\r\n        return results;\r\n    }\r\n    /**\r\n     * Supports iterating through results using for await...\r\n     * @see [MDN Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for-await...of)\r\n     */\r\n    async* [Symbol.asyncIterator]() {\r\n        const {signal} = this.options;\r\n        do {\r\n            const {\r\n                items\r\n            } = await this.nextPage();\r\n\r\n            for await (let hit of items) {\r\n                if (signal?.aborted) break;\r\n                yield hit;\r\n            }\r\n        } while (!this.done);\r\n    }\r\n}\r\n\r\n","import { ScrollError } from '../rev-error';\r\nimport type { RevClient } from '../rev-client';\r\nimport type { Rev } from '../types/index';\r\nimport { type IPageResponse, PagedRequest } from './paged-request';\r\n\r\nexport async function decodeBody(response: Response, acceptType?: string | null) {\r\n    const contentType = response.headers.get('Content-Type') || acceptType || '';\r\n    const contentLength = response.headers.get('Content-Length');\r\n\r\n    if (contentType.startsWith('application/json') && contentLength !== '0') {\r\n        try {\r\n            return await response.json();\r\n        } catch (err) {\r\n            // keep going\r\n        }\r\n    }\r\n\r\n    if (contentType.startsWith('text')) {\r\n        return response.text();\r\n    }\r\n\r\n    return response.body;\r\n}\r\n\r\n/**\r\n * Interface to iterate through results from API endpoints that return results in pages.\r\n * Use in one of three ways:\r\n * 1) Get all results as an array: `await request.exec() == <array>`\r\n * 2) Get each page of results: `await request.nextPage() == { current, total, items: <array> }`\r\n * 3) Use for await to get all results one at a time: `for await (let hit of request) { }`\r\n * @category Utilities\r\n */\r\nexport class SearchRequest<T> extends PagedRequest<T> {\r\n    declare options: Required<Rev.SearchOptions<T>>;\r\n    private query: Record<string, any>;\r\n    private _reqImpl: () => Promise<IPageResponse<T>>;\r\n    constructor(\r\n        rev: RevClient,\r\n        searchDefinition: Rev.SearchDefinition<T>,\r\n        query: Record<string, any> = {},\r\n        options: Rev.SearchOptions<T> = {}\r\n    ) {\r\n        super({\r\n            onProgress: (items: T[], current: number, total?: number | undefined) => {\r\n                const {hitsKey} = searchDefinition;\r\n                rev.log('debug', `searching ${hitsKey}, ${current}-${current + items.length} of ${total}...`);\r\n            },\r\n            onError: (err => { throw err; }),\r\n            ...options\r\n        });\r\n\r\n        // make copy of query object\r\n        const {\r\n            scrollId: _ignore,\r\n            ...queryOpt\r\n        } = query;\r\n        this.query = queryOpt;\r\n\r\n        this._reqImpl = this._buildReqFunction(rev, searchDefinition);\r\n\r\n        this.current = 0;\r\n        this.total = Infinity;\r\n        this.done = false;\r\n    }\r\n    protected _requestPage() {\r\n        return this._reqImpl();\r\n    }\r\n    private _buildReqFunction(rev: RevClient, searchDefinition: Rev.SearchDefinition<T>) {\r\n        const {\r\n            endpoint,\r\n            totalKey,\r\n            hitsKey,\r\n            isPost = false,\r\n            request,\r\n            transform\r\n        } = searchDefinition;\r\n\r\n        const requestFn = request || (isPost\r\n            ? rev.post.bind(rev)\r\n            : rev.get.bind(rev)\r\n        );\r\n\r\n        return async () => {\r\n\r\n            const response: Record<string, any> = await requestFn(endpoint, this.query, { responseType: 'json' });\r\n\r\n            let {\r\n                scrollId,\r\n                [totalKey]: total,\r\n                [hitsKey]: rawItems = [],\r\n                statusCode,\r\n                statusDescription\r\n            } = response;\r\n\r\n            let done = false;\r\n\r\n            this.query.scrollId = scrollId;\r\n            if (!scrollId) {\r\n                done = true;\r\n            }\r\n\r\n            const items: T[] = (typeof transform === 'function')\r\n                ? await Promise.resolve(transform(rawItems))\r\n                : rawItems;\r\n\r\n            if (items.length === 0) {\r\n                done = true;\r\n            }\r\n\r\n            // check for error response\r\n            const error = (statusCode >= 400 && !!statusDescription)\r\n                ? new ScrollError(statusCode, statusDescription)\r\n                : undefined;\r\n\r\n            return {\r\n                total,\r\n                done,\r\n                pageCount: rawItems.length,\r\n                items,\r\n                error\r\n            };\r\n        };\r\n    }\r\n}\r\n","import type { Admin, Rev, Role, RegistrationField } from '../types/index';\r\nimport type { RevClient } from '../rev-client';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\n/**\r\n * if true allow storing/retrieving from cached values. 'Force' means refresh value saved in cache. false means bypass cache\r\n * @inline\r\n * @ignore\r\n */\r\ntype CacheOption = boolean | 'Force'\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof adminAPIFactory>;\r\n/**\r\n * The Admin API methods\r\n * @category Administration\r\n * @group API\r\n * @see [Administration API Docs](https://revdocs.vbrick.com/reference/getroles)\r\n */\r\nexport interface AdminAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function adminAPIFactory(rev: RevClient) {\r\n    let roles: Role.Details[];\r\n    let customFields: Admin.CustomField[];\r\n\r\n    const adminAPI = {\r\n        /**\r\n        * get mapping of role names to role IDs\r\n        * @param cache - if true allow storing/retrieving from cached values. 'Force' means refresh value saved in cache\r\n        */\r\n        async roles(cache: CacheOption = true): Promise<Role.Details[]> {\r\n            // retrieve from cached values if already stored. otherwise get from API\r\n            // if cache is 'Force' then refresh from\r\n            if (roles && cache === true) {\r\n                return roles;\r\n            }\r\n            const response = await rev.get('/api/v2/users/roles');\r\n            if (cache) {\r\n                roles = response;\r\n            }\r\n            return response;\r\n        },\r\n        /**\r\n        * Get a Role (with the role id) based on its name\r\n        * @param name Name of the Role OR RoleType. You can specify the specific enum value (preferred, only Rev 7.53+), or the localized string value in the current user's language, i.e. \"Media Viewer\" for english\r\n        * @param fromCache - if true then use previously cached Role listing (more efficient)\r\n        */\r\n        async getRoleByName(name: Role.RoleType | Role.RoleName, fromCache: CacheOption = true): Promise<Role> {\r\n            const roles = await adminAPI.roles(fromCache);\r\n            const role = roles.find(r => r.roleType === name || r.name === name);\r\n            if (!role) {\r\n                throw new TypeError(`Invalid Role Name ${name}. Valid values are: ${roles.flatMap(r => r.roleType ? [r.roleType, r.name] : [r.name]).join(', ')}`);\r\n            }\r\n            return {\r\n                id: role.id,\r\n                name: role.roleType || role.name\r\n            };\r\n        },\r\n        /**\r\n        * get list of custom fields\r\n        * @param cache - if true allow storing/retrieving from cached values. 'Force' means refresh value saved in cache\r\n        */\r\n        async customFields(cache: CacheOption = true): Promise<Admin.CustomField[]> {\r\n            // retrieve from cached values if already stored. otherwise get from API\r\n            // if cache is 'Force' then refresh from\r\n            if (customFields && cache === true) {\r\n                return customFields;\r\n            }\r\n            const response = await rev.get('/api/v2/video-fields', undefined, { responseType: 'json' });\r\n            if (cache) {\r\n                customFields = response;\r\n            }\r\n            return response;\r\n        },\r\n        /**\r\n        * Get a Custom Field based on its name\r\n        * @param name name of the Custom Field\r\n        * @param fromCache if true then use previously cached Role listing (more efficient)\r\n        */\r\n        async getCustomFieldByName(name: string, fromCache: CacheOption = true): Promise<Admin.CustomField> {\r\n            const customFields = await adminAPI.customFields(fromCache);\r\n            const field = customFields.find(cf => cf.name === name);\r\n            if (!field) {\r\n                throw new TypeError(`Invalid Custom Field Name ${name}. Valid values are: ${customFields.map(cf => cf.name).join(', ')}`);\r\n            }\r\n            return field;\r\n        },\r\n        async brandingSettings(): Promise<Admin.BrandingSettings> {\r\n            return rev.get('/api/v2/accounts/branding-settings');\r\n        },\r\n        async webcastRegistrationFields(): Promise<RegistrationField & { id: string }> {\r\n            const response = await rev.get('/api/v2/accounts/webcast-registration-fields');\r\n            return response.registrationFields;\r\n        },\r\n        async createWebcastRegistrationField(registrationField: RegistrationField.Request): Promise<string> {\r\n            const response = await rev.post('/api/v2/accounts/webcast-registration-fields', registrationField);\r\n            return response.fieldId;\r\n        },\r\n        async updateWebcastRegistrationField(fieldId: string, registrationField: Partial<RegistrationField.Request>): Promise<void> {\r\n            return rev.put(`/api/v2/accounts/webcast-registration-fields/${fieldId}`, registrationField);\r\n        },\r\n        async deleteWebcastRegistrationField(fieldId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/accounts/webcast-registration-fields/${fieldId}`);\r\n        },\r\n        listIQCreditsUsage(query: { startDate?: string | Date, endDate?: string | Date }, options?: Rev.SearchOptions<Admin.IQCreditsSession>): Rev.ISearchRequest<Admin.IQCreditsSession> {\r\n            const searchDefinition: Rev.SearchDefinition<Admin.IQCreditsSession> = {\r\n                endpoint: `/api/v2/analytics/accounts/iq-credits-usage`,\r\n                totalKey: 'total',\r\n                hitsKey: 'sessions'\r\n            };\r\n            return new SearchRequest<Admin.IQCreditsSession>(rev, searchDefinition, query, options);\r\n        },\r\n        /**\r\n        * get system health - returns 200 if system is active and responding, otherwise throws error\r\n        */\r\n        async verifySystemHealth(): Promise<boolean> {\r\n            await rev.get('/api/v2/system-health');\r\n            return true;\r\n        },\r\n        /**\r\n        * gets list of scheduled maintenance windows\r\n        */\r\n        async maintenanceSchedule(): Promise<{start: string, end: string}[]> {\r\n            const {schedules} = await rev.get('/api/v2/maintenance-schedule');\r\n            return schedules;\r\n        },\r\n        /**\r\n         * gets the user location service URL\r\n         */\r\n        async userLocationService(): Promise<{ enabled: boolean, locationUrls: string[] }> {\r\n            return rev.get('/api/v2/user-location');\r\n        },\r\n        /**\r\n         * returns an array of all expiration rules\r\n         */\r\n        async expirationRules(): Promise<Admin.ExpirationRule[]> {\r\n            return rev.get('/api/v2/expiration-rules');\r\n        },\r\n        async featureSettings(videoId?: string): Promise<Admin.FeatureSettings> {\r\n            const params = videoId ? { videoId } : undefined;\r\n            return rev.get('/api/v2/videos/feature-settings', params);\r\n        }\r\n    };\r\n    return adminAPI;\r\n}\r\n","/**\r\n * simple helper function to parse CSV data into JSON\r\n */\r\nexport function parseCSV(raw: string) {\r\n    raw = raw.replace(/(\\r\\n|\\n|\\r)/gm, '\\n').replace(/\\n$/g, '');\r\n\r\n    let cur = '';\r\n    let inQuote = false;\r\n    let fieldQuoted = false;\r\n    let field: string | undefined = '';\r\n    let row: (string | undefined)[] = [];\r\n    let out: (string | undefined)[][] = [];\r\n    let i: number;\r\n    const n = raw.length;\r\n\r\n    function processField(field: string) {\r\n        if (fieldQuoted) { return field; }\r\n        if (field === '') { return undefined; }\r\n        return field.trim();\r\n    }\r\n\r\n    for (i = 0; i < n; i += 1) {\r\n        cur = raw.charAt(i);\r\n\r\n        if (!inQuote && (cur === ',' || cur === '\\n')) {\r\n            field = processField(field);\r\n            row.push(field);\r\n            if (cur === '\\n') {\r\n                out.push(row);\r\n                row = [];\r\n            }\r\n            field = '';\r\n            fieldQuoted = false;\r\n        } else if (cur === '\"') {\r\n            if (!inQuote) {\r\n                inQuote = true;\r\n                fieldQuoted = true;\r\n            } else {\r\n                if (raw.charAt(i + 1) === '\"') {\r\n                    field += '\"';\r\n                    i += 1;\r\n                } else {\r\n                    inQuote = false;\r\n                }\r\n            }\r\n        } else {\r\n            field += cur === '\\n' ? '\\n' : cur;\r\n        }\r\n    }\r\n\r\n    // Add the last field\r\n    field = processField(field);\r\n    row.push(field);\r\n    out.push(row);\r\n\r\n    const headers: string[] = out.shift() as string[];\r\n    return out\r\n        .map((line: (string | undefined)[]) => {\r\n            const obj: Record<string, string> = { };\r\n            line\r\n                .forEach((field, i) => {\r\n                    if (field !== undefined) {\r\n                        obj[headers[i]] = field;\r\n                    }\r\n                });\r\n            return obj;\r\n        });\r\n}\r\n","import { RevClient } from '../rev-client';\r\nimport type { Audit } from '../types/audit';\r\nimport { asValidDate, tryParseJson } from '../utils/index';\r\nimport { type IPageResponse, PagedRequest } from '../utils/paged-request';\r\nimport { parseCSV } from '../utils/parse-csv';\r\n\r\nfunction parseEntry<T extends Audit.Entry>(line: Record<string, any>): T {\r\n    return {\r\n        messageKey: line['MessageKey'],\r\n        entityKey: line['EntityKey'],\r\n        when: line['When'],\r\n        entityId: line['EntityId'],\r\n        principal: tryParseJson(line['Principal']) || {},\r\n        message: tryParseJson(line['Message']) || {},\r\n        currentState: tryParseJson(line['CurrentState']) || {},\r\n        previousState: tryParseJson(line['PreviousState']) || {}\r\n    } as T;\r\n}\r\n\r\n/**\r\n * @category Audit\r\n */\r\nexport class AuditRequest<T extends Audit.Entry> extends PagedRequest<T> {\r\n    declare options: Required<Omit<Audit.Options<T>, 'toDate' | 'fromDate'>>;\r\n    private params: {\r\n        toDate?: string,\r\n        fromDate?: string,\r\n        nextContinuationToken?: string;\r\n    }\r\n    private _req: () => Promise<IPageResponse<T>>;\r\n    /**\r\n     * @hidden\r\n     * @param rev\r\n     * @param endpoint\r\n     * @param label\r\n     * @param options\r\n     */\r\n    constructor(\r\n        rev: RevClient,\r\n        endpoint: string,\r\n        label: string = 'audit records',\r\n        {toDate, fromDate, beforeRequest, ...options}: Audit.Options<T> = {}\r\n    ) {\r\n        if (!toDate && 'endDate' in options) {\r\n            throw new TypeError('Audit API uses toDate param instead of endDate');\r\n        }\r\n        if (!fromDate && 'startDate' in options) {\r\n            throw new TypeError('Audit API uses fromDate param instead of startDate');\r\n        }\r\n        super({\r\n            onProgress: (items: T[], current: number, total?: number | undefined) => {\r\n                rev.log('debug', `loading ${label}, ${current} of ${total}...`);\r\n            },\r\n            ...options\r\n        });\r\n\r\n        const {from, to} = this._parseDates(fromDate, toDate);\r\n\r\n        this.params = {\r\n            toDate: to.toISOString(),\r\n            fromDate: from.toISOString()\r\n        };\r\n\r\n        this._req = this._buildReqFunction(rev, endpoint, beforeRequest);\r\n    }\r\n    protected _requestPage() { return this._req(); }\r\n    private _buildReqFunction(rev: RevClient, endpoint: string, beforeRequest?: (request: PagedRequest<T>) => Promise<void>) {\r\n        return async () => {\r\n            await beforeRequest?.(this);\r\n            const response = await rev.request('GET', endpoint, this.params, { responseType: 'text' });\r\n\r\n            const {\r\n                body,\r\n                headers\r\n            } = response;\r\n\r\n            let items = parseCSV(body)\r\n                .map(line => parseEntry<T>(line));\r\n\r\n            const remaining = parseInt(headers.get('totalRecords') || '', 10);\r\n\r\n            Object.assign(this.params, {\r\n                nextContinuationToken: headers.get('nextContinuationToken') || undefined,\r\n                fromDate: headers.get('nextfromDate') || undefined\r\n            });\r\n\r\n            let done = !this.params.nextContinuationToken;\r\n\r\n\r\n            return {\r\n                items,\r\n                // totalRecords for subsequent requests is the count return from current fromDate, rather than total for starting date range\r\n                total: Math.max(this.total || 0, remaining),\r\n                done\r\n            } as IPageResponse<T>;\r\n        }\r\n    }\r\n    private _parseDates(fromDate?: Date | string, toDate?: Date | string) {\r\n        let to = asValidDate(toDate, new Date());\r\n\r\n        // default to one year older than toDate\r\n        const defaultFrom = new Date(to);\r\n        defaultFrom.setFullYear(to.getFullYear() - 1);\r\n\r\n        let from = asValidDate(fromDate, defaultFrom);\r\n\r\n        if (to < from) {\r\n            [to, from] = [from, to];\r\n        }\r\n        return {from, to};\r\n    }\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Audit, Rev } from '../types/index';\r\nimport { RateLimitEnum, makeQueue, normalizeRateLimitOptions } from '../utils/rate-limit-queues';\r\nimport { AuditRequest } from './audit-request';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof auditAPIFactory>;\r\n/**\r\n * The Audit API methods\r\n * @category Audit\r\n * @group API\r\n * @see [Audit API Docs](https://revdocs.vbrick.com/reference/getuseraccessauditdetails)\r\n */\r\nexport interface AuditAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function auditAPIFactory(rev: RevClient, optRateLimits?: Rev.Options['rateLimits']) {\r\n    // The Audit API endpoints each have their own bucket of limits, so we keep track of each one here\r\n\r\n    // parse the incoming rate limit option and pass into AuditRequest object\r\n    const requestsPerMinute = normalizeRateLimitOptions(optRateLimits)[RateLimitEnum.AuditEndpoints];\r\n    function makeOptTransform() {\r\n        if (!requestsPerMinute) return (opts?: Audit.Options<any>) => opts;\r\n        const lock = makeQueue(RateLimitEnum.AuditEndpoints, requestsPerMinute);\r\n        return (opts: Audit.Options<any> = {}) => ({\r\n            ...opts,\r\n            async beforeRequest(req: AuditRequest<any>) {\r\n                await lock();\r\n                return opts.beforeRequest?.(req);\r\n            }\r\n        } as Audit.Options<any>);\r\n    }\r\n    const locks = {\r\n        accountAccess: makeOptTransform(),\r\n        userAccess: makeOptTransform(),\r\n        accountUsers: makeOptTransform(),\r\n        user: makeOptTransform(),\r\n        accountGroups: makeOptTransform(),\r\n        group: makeOptTransform(),\r\n        accountDevices: makeOptTransform(),\r\n        device: makeOptTransform(),\r\n        accountVideos: makeOptTransform(),\r\n        video: makeOptTransform(),\r\n        accountWebcasts: makeOptTransform(),\r\n        webcast: makeOptTransform(),\r\n        principal: makeOptTransform()\r\n    };\r\n\r\n\r\n    const auditAPI = {\r\n        /**\r\n        * Logs of user login / logout / failed login activity\r\n        */\r\n        accountAccess(accountId: string, options?: Audit.Options<Audit.UserAccessEntry>) {\r\n            const opts = locks.accountAccess(options);\r\n            return new AuditRequest<Audit.UserAccessEntry>(rev, `/network/audit/accounts/${accountId}/userAccess`, 'UserAccess', opts);\r\n        },\r\n        userAccess(userId: string, accountId: string, options?: Audit.Options<Audit.UserAccessEntry>) {\r\n            const opts = locks.userAccess(options);\r\n            return new AuditRequest<Audit.UserAccessEntry>(rev, `/network/audit/accounts/${accountId}/userAccess/${userId}`, `UserAccess_${userId}`, opts);\r\n        },\r\n        /**\r\n        * Operations on User Records (create, delete, etc)\r\n        */\r\n        accountUsers(accountId: string, options?: Audit.Options<Audit.UserEntry>) {\r\n            const opts = locks.accountUsers(options);\r\n            return new AuditRequest<Audit.UserEntry>(rev, `/network/audit/accounts/${accountId}/users`, 'User', opts);\r\n        },\r\n        user(userId: string, accountId: string, options?: Audit.Options<Audit.UserEntry>) {\r\n            const opts = locks.user(options);\r\n            return new AuditRequest<Audit.UserEntry>(rev, `/network/audit/accounts/${accountId}/users/${userId}`, 'User', opts);\r\n        },\r\n        /**\r\n        * Operations on Group Records (create, delete, etc)\r\n        */\r\n        accountGroups(accountId: string, options?: Audit.Options<Audit.GroupEntry>) {\r\n            const opts = locks.accountGroups(options);\r\n            return new AuditRequest<Audit.GroupEntry>(rev, `/network/audit/accounts/${accountId}/groups`, 'Groups', opts);\r\n        },\r\n        group(groupId: string, accountId: string, options?: Audit.Options<Audit.GroupEntry>) {\r\n            const opts = locks.group(options);\r\n            return new AuditRequest<Audit.GroupEntry>(rev, `/network/audit/accounts/${accountId}/groups/${groupId}`, 'Group', opts);\r\n        },\r\n        /**\r\n        * Operations on Device Records (create, delete, etc)\r\n        */\r\n        accountDevices(accountId: string, options?: Audit.Options<Audit.DeviceEntry>) {\r\n            const opts = locks.accountDevices(options);\r\n            return new AuditRequest<Audit.DeviceEntry>(rev, `/network/audit/accounts/${accountId}/devices`, 'Devices', opts);\r\n        },\r\n        device(deviceId: string, accountId: string, options?: Audit.Options<Audit.DeviceEntry>) {\r\n            const opts = locks.device(options);\r\n            return new AuditRequest<Audit.DeviceEntry>(rev, `/network/audit/accounts/${accountId}/devices/${deviceId}`, 'Device', opts);\r\n        },\r\n        /**\r\n        * Operations on Video Records (create, delete, etc)\r\n        */\r\n        accountVideos(accountId: string, options?: Audit.Options<Audit.VideoEntry>) {\r\n            const opts = locks.accountVideos(options);\r\n            return new AuditRequest<Audit.VideoEntry>(rev, `/network/audit/accounts/${accountId}/videos`, 'Videos', opts);\r\n        },\r\n        video(videoId: string, accountId: string, options?: Audit.Options<Audit.VideoEntry>) {\r\n            const opts = locks.video(options);\r\n            return new AuditRequest<Audit.VideoEntry>(rev, `/network/audit/accounts/${accountId}/videos/${videoId}`, 'Video', opts);\r\n        },\r\n        /**\r\n        * Operations on Webcast Records (create, delete, etc)\r\n        */\r\n        accountWebcasts(accountId: string, options?: Audit.Options<Audit.WebcastEntry>) {\r\n            const opts = locks.accountWebcasts(options);\r\n            return new AuditRequest<Audit.WebcastEntry>(rev, `/network/audit/accounts/${accountId}/scheduledEvents`, 'Webcasts', opts);\r\n        },\r\n        webcast(eventId: string, accountId: string, options?: Audit.Options<Audit.WebcastEntry>) {\r\n            const opts = locks.webcast(options);\r\n            return new AuditRequest<Audit.WebcastEntry>(rev, `/network/audit/accounts/${accountId}/scheduledEvents/${eventId}`, `Webcast`, opts);\r\n        },\r\n        /**\r\n        * All operations a single user has made\r\n        */\r\n        principal(userId: string, accountId: string, options?: Audit.Options<Audit.Entry<string>>) {\r\n            const opts = locks.principal(options);\r\n            return new AuditRequest<Audit.Entry<string>>(rev, `/network/audit/accounts/${accountId}/principals/${userId}`, 'Principal', opts);\r\n        }\r\n    };\r\n\r\n    return auditAPI;\r\n}\r\n","import polyfills from '../interop/polyfills';\r\n\r\nexport function mergeHeaders(source?: HeadersInit, other?: HeadersInit) {\r\n    const merged = new polyfills.Headers(source);\r\n    new polyfills.Headers(other).forEach((value, key) => merged.set(key, value));\r\n    return merged;\r\n}\r\n","import type { OAuth } from '../types/auth';\r\nimport polyfills from '../interop/polyfills';\r\nimport type { Rev } from '../types/rev';\r\n\r\nconst PLACEHOLDER = 'http://rev';\r\n\r\nexport function getOAuth2AuthorizationUrl(config: OAuth.ServerConfig, code_challenge: string, state?: string) {\r\n    // construct URL with query params\r\n    const url = new URL('/api/v2/oauth2/authorize', config.revUrl);\r\n    url.search = new URLSearchParams({\r\n        client_id: config.oauthApiKey,\r\n        code_challenge,\r\n        response_type: 'code',\r\n        redirect_uri: config.redirectUri,\r\n        ...state && {state}\r\n    }).toString();\r\n\r\n    return url.toString();\r\n}\r\n\r\n/**\r\n *\r\n * @param codeVerifier value can be any string 43-128 characters in length, just these characters: [A-Za-z0-9._~-]\r\n */\r\nexport async function getOAuth2PKCEVerifier(codeVerifier = polyfills.randomValues(48)) {\r\n    // setup pkce\r\n    // value can be any string 43-128 characters in length, just these characters: [A-Za-z0-9._~-]\r\n    // this line uses random values to create 64char string\r\n    const codeChallenge = await polyfills.sha256Hash(codeVerifier);\r\n    return { codeVerifier, codeChallenge };\r\n}\r\n\r\n/**\r\n * Constructs the query parameters for the Rev /oauth/authorization endpoint\r\n * @param config OAuth signing settings, retrieved from Rev Admin -> Security -> API Keys page, along with revUrl\r\n * @param state optional state to pass back to redirectUri once complete\r\n * @returns A valid oauth flow endpoint + query\r\n */\r\nexport async function buildLegacyOAuthQuery(config: OAuth.Config, oauthSecret: string, state: string = '1') {\r\n    const { hmacSign } = polyfills;\r\n\r\n    const RESPONSE_TYPE = 'code';\r\n\r\n    const {\r\n        oauthApiKey: apiKey,\r\n        redirectUri\r\n    } = config;\r\n\r\n    const timestamp = new Date();\r\n    const verifier = `${apiKey}::${timestamp.toISOString()}`;\r\n\r\n    const signature = await hmacSign(verifier, oauthSecret);\r\n\r\n    return {\r\n        apiKey,\r\n        signature,\r\n        verifier,\r\n        'redirect_uri': redirectUri,\r\n        'response_type': RESPONSE_TYPE,\r\n        state\r\n    };\r\n}\r\n\r\n/**\r\n * Parse the query parameters returned to the redirectUri from Rev\r\n * @param url The URL with query parameters, or object with the query parrameters\r\n * @returns\r\n */\r\nexport function parseLegacyOAuthRedirectResponse(url: string | URL | URLSearchParams | Record<string, string>): OAuth.RedirectResponse {\r\n    if (typeof url === 'string') {\r\n        // just in case only the query string is returned, include base\r\n        url = new URL(url, PLACEHOLDER);\r\n    }\r\n\r\n    if (url instanceof URL) {\r\n        url = url.searchParams;\r\n    }\r\n\r\n    const query: Record<string, string> = (url instanceof URLSearchParams)\r\n        ? Object.fromEntries(url)\r\n        : url;\r\n\r\n    const {\r\n        'auth_code': authCode = '',\r\n        state = '',\r\n        error = undefined\r\n    } = query;\r\n\r\n    return {\r\n        isSuccess: !error,\r\n        // URL parsing parses pluses (+) as spaces, which can cause later validation to fail\r\n        authCode: `${authCode}`.replace(/ /g, '+'),\r\n        state,\r\n        error\r\n    };\r\n}\r\n\r\n/**\r\n * Format the oauth configuration and oauth response into the constructor arguments for RevClient\r\n * @param revUrl\r\n * @param config\r\n * @param response\r\n * @returns {Rev.Options}\r\n */\r\nexport function buildLegacyOAuthRevOptions(revUrl: string, config: OAuth.Config, response: OAuth.RedirectResponse): Rev.Options {\r\n    const {\r\n        oauthApiKey,\r\n        redirectUri\r\n    } = config;\r\n\r\n    const {\r\n        authCode\r\n    } = response;\r\n\r\n    return {\r\n        url: revUrl,\r\n        authCode,\r\n        oauthConfig: {\r\n            oauthApiKey,\r\n            redirectUri\r\n        }\r\n    };\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Auth, OAuth } from '../types/auth';\r\nimport type { Rev } from '../types/rev';\r\nimport { mergeHeaders } from '../utils/merge-headers';\r\nimport {buildLegacyOAuthQuery, getOAuth2AuthorizationUrl, getOAuth2PKCEVerifier, parseLegacyOAuthRedirectResponse} from './oauth';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof authAPIFactory>;\r\n\r\n/**\r\n * Authentication API methods\r\n * Generally you won't need to call these methods directly - {@link RevClient#connect | RevClient} instances use them internally to maintain an authentication session.\r\n *\r\n * The exception is the {@link AuthAPI.buildOAuth2Authentication} and {@link AuthAPI.loginOAuth2} methods, which can be used when building an OAuth2 authentication flow.\r\n *\r\n * @category Authentication\r\n * @group API\r\n * @see [Auth API Docs](https://revdocs.vbrick.com/reference/authenticateuser)\r\n     */\r\nexport interface AuthAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function authAPIFactory(rev: RevClient) {\r\n\r\n    const authAPI = {\r\n        async loginToken(apiKey: string, secret: string, options?: Rev.RequestOptions): Promise<Auth.LoginResponse> {\r\n            return rev.post('/api/v2/authenticate', {\r\n                apiKey,\r\n                secret\r\n            }, options);\r\n        },\r\n        async extendSessionToken(apiKey: string): Promise<Auth.ExtendResponse> {\r\n            return rev.post(`/api/v2/auth/extend-session-timeout/${apiKey}`);\r\n        },\r\n        async logoffToken(apiKey: string): Promise<void> {\r\n            return rev.delete(`/api/v2/tokens/${apiKey}`);\r\n        },\r\n        async loginUser(username: string, password: string, options?: Rev.RequestOptions): Promise<Auth.UserLoginResponse> {\r\n            return rev.post('/api/v2/user/login', {\r\n                username,\r\n                password\r\n            }, options);\r\n        },\r\n        async logoffUser(userId: string): Promise<void> {\r\n            return rev.post('/api/v2/user/logoff', { userId });\r\n        },\r\n        async extendSessionUser(userId: string): Promise<Auth.ExtendResponse> {\r\n            return rev.post('/api/v2/user/extend-session-timeout', { userId });\r\n        },\r\n        async loginJWT(jwtToken: string, options?: Rev.RequestOptions): Promise<Auth.JWTLoginResponse> {\r\n            return rev.get('/api/v2/jwtauthenticate', { jwt_token: jwtToken }, options);\r\n        },\r\n        async loginGuestRegistration(webcastId: string, jwtToken: string, options?: Rev.RequestOptions): Promise<Auth.GuestRegistrationResposne> {\r\n            const opts = {\r\n                ...options,\r\n                headers: mergeHeaders(options?.headers, { 'x-requested-with': 'xmlhttprequest' })\r\n            };\r\n            return rev.post(`/external/auth/jwt/${webcastId}`, { token: `vbrick_rev ${jwtToken}`}, options);\r\n        },\r\n        async extendSession(): Promise<Auth.ExtendResponse> {\r\n            return rev.post('/api/v2/user/extend-session');\r\n        },\r\n        async verifySession(): Promise<void> {\r\n            return rev.get('/api/v2/user/session');\r\n        },\r\n\r\n        /**\r\n         * @deprecated - use logoffUser - put here because it's a common misspelling\r\n         */\r\n        get logoutUser() { return authAPI.logoffUser; },\r\n        /**\r\n         * @deprecated - use logoffToken - put here because it's a common misspelling\r\n         */\r\n        get logoutToken() { return authAPI.logoffToken; },\r\n        /**\r\n         * generate the Authorization URL for the OAuth2 flow as well as the codeVerifier for the\r\n         * subsequent Access Token request. You *must* store the codeVerifier somehow (i.e. serverside database matched to user's state/cookies/session, or on browser SessionStorage) to be able to complete the OAuth2 login flow.\r\n         * @param config OAuth signing settings, retrieved from Rev Admin -> Security -> API Keys page\r\n         * @param state optional state to pass back to redirectUri once complete\r\n         * @param verifier the code_verifier to use when generating the code challenge. Can be any string 43-128 characters in length, just these characters: [A-Za-z0-9._~-]. If not provided then code will automatically generate a suitable value\r\n         * @returns A valid oauth flow URL + the code_verifier to save for later verification\r\n         */\r\n        async buildOAuth2Authentication(config: OAuth.ServerConfig, state: string = '1', verifier?: string): Promise<OAuth.AuthenticationData> {\r\n            const {codeChallenge, codeVerifier} = await getOAuth2PKCEVerifier(verifier);\r\n            const _cfg = { revUrl: rev.url, ...config };\r\n            const url = getOAuth2AuthorizationUrl(_cfg, codeChallenge, state);\r\n            return {\r\n                url: `${url}`,\r\n                codeVerifier\r\n            };\r\n        },\r\n        async loginOAuth2(config: OAuth.Config, code: string, codeVerifier: string, options?: Rev.RequestOptions): Promise<OAuth.AuthTokenResponse> {\r\n            return rev.post('/api/v2/oauth2/token', {\r\n                // sometimes the authCode can get mangled, with the pluses in the code being replaced by spaces.\r\n                code: code.replace(/ /g, '+'),\r\n                client_id: config.oauthApiKey,\r\n                grant_type: 'authorization_code',\r\n                redirect_uri: config.redirectUri,\r\n                code_verifier: codeVerifier\r\n            }, options);\r\n        },\r\n        /**\r\n         * @deprecated\r\n         * @param config OAuth signing settings, retrieved from Rev Admin -> Security -> API Keys page\r\n         * @param oauthSecret Secret from Rev Admin -> Security. This is a DIFFERENT value from the\r\n         *                    User Secret used for API login. Do not expose client-side!\r\n         * @param state optional state to pass back to redirectUri once complete\r\n         * @returns A valid oauth flow URL\r\n         */\r\n        async buildOAuthAuthenticationURL(config: OAuth.Config, oauthSecret: string, state: string = '1'): Promise<string> {\r\n            const query = await buildLegacyOAuthQuery(config, oauthSecret, state);\r\n            const url = new URL('/api/v2/oauth/authorization', rev.url);\r\n            url.search = `${new URLSearchParams(query)}`;\r\n            return `${url}`;\r\n        },\r\n        /**\r\n         * @deprecated\r\n         */\r\n        buildOAuthAuthenticationQuery: buildLegacyOAuthQuery,\r\n        /**\r\n         * @deprecated\r\n         */\r\n        parseOAuthRedirectResponse: parseLegacyOAuthRedirectResponse,\r\n        /**\r\n         * @deprecated\r\n         * @param config\r\n         * @param authCode\r\n         * @returns\r\n         */\r\n        async loginOAuth(config: OAuth.Config, authCode: string): Promise<OAuth.LoginResponse> {\r\n            const GRANT_AUTH = 'authorization_code';\r\n\r\n            const {\r\n                oauthApiKey: apiKey,\r\n                redirectUri\r\n            } = config;\r\n\r\n            // sometimes the authCode can get mangled, with the pluses in the code\r\n            // being replaced by spaces. This is just to make sure that isn't a problem (even though already done in parseOAuthRedirectResponse)\r\n            authCode = authCode.replace(/ /g, '+');\r\n\r\n            // COMBAK I don't think it matters if rev-client is logged in and passing Authorization headers or not.\r\n            return rev.post('/api/v2/oauth/token', {\r\n                authCode,\r\n                apiKey,\r\n                redirectUri,\r\n                grantType: GRANT_AUTH\r\n            });\r\n        },\r\n        /**\r\n         * @deprecated\r\n         * @param config\r\n         * @param refreshToken\r\n         * @returns\r\n         */\r\n        async extendSessionOAuth(config: OAuth.Config, refreshToken: string): Promise<OAuth.LoginResponse> {\r\n            const GRANT_REFRESH = 'refresh_token';\r\n\r\n            const {\r\n                oauthApiKey: apiKey\r\n            } = config;\r\n\r\n            return rev.post('/api/v2/oauth/token', {\r\n                apiKey,\r\n                refreshToken,\r\n                grantType: GRANT_REFRESH\r\n            });\r\n        }\r\n    };\r\n\r\n    return authAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Category } from '../types/index';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof categoryAPIFactory>;\r\n/**\r\n * Category API methods\r\n * @category Administration\r\n * @group API\r\n * @see [Category API Docs](https://revdocs.vbrick.com/reference/getcategories)\r\n */\r\nexport interface CategoryAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function categoryAPIFactory(rev: RevClient) {\r\n    const categoryAPI = {\r\n        async create(category: Category.CreateRequest): Promise<Category.CreateResponse> {\r\n            return rev.post('/api/v2/categories', category, { responseType: 'json' });\r\n        },\r\n        async details(categoryId: string): Promise<Category.Details> {\r\n            return rev.get(`/api/v2/categories/${categoryId}`, undefined, { responseType: 'json' });\r\n        },\r\n        async update(categoryId: string, category: Category.EditRequest): Promise<void> {\r\n            return rev.put(`/api/v2/categories/${categoryId}`, category);\r\n        },\r\n        async delete(categoryId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/categories/${categoryId}`);\r\n        },\r\n        /**\r\n         * get list of categories in system\r\n         * @see {@link https://revdocs.vbrick.com/reference#getcategories}\r\n         */\r\n        async list(parentCategoryId?: string, includeAllDescendants?: boolean): Promise<Category[]> {\r\n            // only pass parameters if defined\r\n            const payload: Record<string, any> = Object.assign(\r\n                { },\r\n                parentCategoryId && { parentCategoryId },\r\n                includeAllDescendants != undefined && { includeAllDescendants }\r\n            );\r\n            const { categories } = await rev.get('/api/v2/categories', payload, { responseType: 'json' });\r\n            return categories;\r\n        },\r\n        /**\r\n         * get list of categories that current user has ability to add videos to\r\n         */\r\n        async listAssignable(): Promise<Category.Assignable[]> {\r\n            return rev.get('/api/v2/assignable-categories');\r\n        }\r\n    };\r\n    return categoryAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { AccessControl, Channel, Rev } from '../types/index';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof channelAPIFactory>;\r\n/**\r\n * Channel API methods\r\n * @category Channels\r\n * @group API\r\n * @see [Channel API Docs](https://revdocs.vbrick.com/reference/getchannels)\r\n */\r\nexport interface ChannelAPI extends API {};\r\n\r\n/** @ignore */\r\nexport default function channelAPIFactory(rev: RevClient) {\r\n    const channelAPI = {\r\n        async create(channel: Channel.CreateRequest): Promise<string> {\r\n            const {channelId} = await rev.post('/api/v2/channels', channel, { responseType: 'json' });\r\n            return channelId;\r\n        },\r\n        async update(channelId: string, channel: Channel.CreateRequest): Promise<void> {\r\n            return rev.put(`/api/v2/channels/${channelId}`, channel);\r\n        },\r\n        /**\r\n         * @summary Patch Channel\r\n         * Partially edits the members and details of a channel. You do not need to provide the fields that you are not changing.\r\n         * @example\r\n         * ```js\r\n         * const rev = new RevClient(...config...);\r\n         * await rev.connect();\r\n         *\r\n         * // add a member\r\n         * await rev.channel.patch(channelId, [{ op: 'add', path: '/Members/-', value: { id: userId, type: 'User', roleTypes: 'Uploader' } }]);\r\n         *\r\n         * // add current user as an admin\r\n         * const user = await rev.user.details('me');\r\n         * await rev.channel.patch(channelId, [{ op: 'add', path: '/Members/-', value: { id: user.userId, type: 'User', roleTypes: 'Admin' } }]);\r\n         *\r\n         * // change sort order\r\n         * await rev.channel.patch(channelId, [{ op: 'replace', path: '/DefaultSortOrder', value: 'recommended' }]);\r\n         *\r\n         * ```\r\n         * @param channelId\r\n         * @param operations\r\n         * @param options\r\n         */\r\n        async patch(channelId: string, operations: Rev.PatchOperation[], options?: Rev.RequestOptions): Promise<void> {\r\n            await rev.patch(`/api/v2/channels/${channelId}`, operations, options);\r\n        },\r\n        async delete(channelId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/channels/${channelId}`);\r\n        },\r\n        /**\r\n         * get list of channels in system\r\n         * @see {@link https://revdocs.vbrick.com/reference/getchannels}\r\n         */\r\n        list(start: number = 0, options: Channel.SearchOptions = {}): ChannelListRequest {\r\n            return new ChannelListRequest(rev, start, options);\r\n        },\r\n        async addMembers(channelId: string, members: Channel.Member[]) {\r\n            const operations = members\r\n                .map(member => {\r\n                    return { op: 'add', path: '/Members/-', value: member };\r\n                });\r\n            await rev.patch(`/api/v2/channels/${channelId}`, operations);\r\n        },\r\n        async removeMembers(channelId: string, members: Array<string | Channel.Member>) {\r\n            const operations = members\r\n                .map(member => {\r\n                    const entityId = typeof member === 'string'\r\n                        ? member\r\n                        : member.id;\r\n\r\n                    return { op: 'remove', path: '/Members', value: entityId };\r\n                });\r\n\r\n            await rev.patch(`/api/v2/channels/${channelId}`, operations);\r\n        },\r\n        get uploadLogo() {\r\n            return rev.upload.channelLogo;\r\n        },\r\n        get uploadHeader() {\r\n            return rev.upload.channelHeader;\r\n        },\r\n        async downloadLogo<T = ReadableStream>(channel: {logoKey?: string | null, logoUri?: string | null}, options: Rev.RequestOptions): Promise<Rev.Response<T>> {\r\n            const endpoint = channel?.logoKey\r\n                ? `/api/v2/channels/thumbnails/${channel?.logoKey}`\r\n                : channel?.logoUri;\r\n\r\n            if (!endpoint) throw new TypeError('Channel has no logo');\r\n            const response = await rev.request<T>('GET', endpoint, undefined, {\r\n                responseType: 'stream',\r\n                ...options\r\n            });\r\n            return response;\r\n        },\r\n        async downloadHeader<T = ReadableStream>(channel: {headerKey?: string | null, headerUri?: string | null}, options: Rev.RequestOptions): Promise<Rev.Response<T>> {\r\n            const endpoint = channel?.headerKey\r\n                ? `/api/v2/channels/thumbnails/${channel?.headerKey}`\r\n                : channel?.headerUri;\r\n            if (!endpoint) throw new TypeError('Channel has no header');\r\n            const response = await rev.request<T>('GET', endpoint, undefined, {\r\n                responseType: 'stream',\r\n                ...options\r\n            });\r\n            return response;\r\n        },\r\n        /**\r\n         *\r\n         * @param {string} [searchText]\r\n         * @param {Rev.SearchOptions<{Id: string, Name: string}>} [options]\r\n         */\r\n        search(searchText?: string, options: Rev.AccessEntitySearchOptions<AccessControl.SearchHit> & { type?: AccessControl.EntitySearchType } = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/access-entity${options?.assignable ? '/assignable' : ''}`,\r\n                totalKey: 'totalEntities',\r\n                hitsKey: 'accessEntities'\r\n            };\r\n            const query: Record<string, any> = {\r\n                type: options.type || 'Channel',\r\n                ...searchText && {q: searchText}\r\n            };\r\n            return new SearchRequest<AccessControl.SearchHit>(rev, searchDefinition, query, options);\r\n        },\r\n        /**\r\n         * @summary Get Channels For User\r\n         * Returns only the channels and video count for the user making the API call based on their access control.\r\n         * @param options\r\n         */\r\n        async listUserChannels(options?: Rev.RequestOptions): Promise<Channel.UserListItem[]> {\r\n            return rev.get('/api/v2/search/channels', undefined, options);\r\n        }\r\n    };\r\n    return channelAPI;\r\n}\r\n\r\n/** @category Channels */\r\nexport class ChannelListRequest implements Rev.ISearchRequest<Channel.SearchHit> {\r\n    currentPage: number;\r\n    current: number;\r\n    total: number;\r\n    done: boolean;\r\n    options: Required<Pick<Channel.SearchOptions, 'maxResults' | 'onProgress' | 'pageSize'>>;\r\n    private _req: () => Promise<Channel.SearchHit[]>;\r\n    constructor(rev: RevClient, start: number = 0, options: Channel.SearchOptions = {}) {\r\n        this.options = {\r\n            maxResults: Infinity,\r\n            pageSize: 10,\r\n            onProgress: (items: Channel.SearchHit[], current: number, total: number) => {\r\n                rev.log('debug', `loading channels, ${current} of ${total}...`);\r\n            },\r\n            ...options\r\n        };\r\n\r\n        this.current = 0;\r\n        this.total = Infinity;\r\n        this.done = false;\r\n        this.currentPage = start;\r\n\r\n        this._req = () => {\r\n            const params = {\r\n                page: this.currentPage,\r\n                size: this.options.pageSize\r\n            };\r\n            return rev.get('/api/v2/channels', params, { responseType: 'json' });\r\n        }\r\n\r\n    }\r\n    async nextPage() {\r\n        const {\r\n            maxResults,\r\n            onProgress\r\n        } = this.options;\r\n\r\n        let current = this.current;\r\n\r\n        let items: Channel.SearchHit[] = await this._req();\r\n\r\n        if (!Array.isArray(items) || items.length == 0) {\r\n            this.done = true;\r\n            items = [];\r\n        }\r\n\r\n        if (current + items.length >= maxResults) {\r\n            const delta = maxResults - current;\r\n            items = items.slice(0, delta);\r\n            this.done = true;\r\n        }\r\n        this.total = current + items.length;\r\n\r\n        onProgress(items, current, this.total);\r\n\r\n        this.current += items.length;\r\n        this.currentPage += 1;\r\n\r\n        return {\r\n            current,\r\n            total: this.total,\r\n            done: this.done,\r\n            items\r\n        };\r\n    }\r\n    /**\r\n     * Go through all pages of results and return as an array.\r\n     * TIP: Use the {maxResults} option to limit the maximum number of results\r\n     *\r\n     */\r\n    async exec(): Promise<Channel.SearchHit[]> {\r\n        const results: Channel.SearchHit[] = [];\r\n        // use async iterator\r\n        for await (let hit of this) {\r\n            results.push(hit);\r\n        }\r\n        return results;\r\n    }\r\n    async* [Symbol.asyncIterator]() {\r\n        do {\r\n            const {\r\n                items\r\n            } = await this.nextPage();\r\n\r\n            for await (let hit of items) {\r\n                yield hit;\r\n            }\r\n        } while (!this.done);\r\n    }\r\n}\r\n","import type { RevClient } from '../rev-client';\r\n\r\nimport type { Device } from '../types/index';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof deviceAPIFactory>;\r\n/**\r\n * Device API methods\r\n * @category Devices\r\n * @group API\r\n * @see [Device API Docs](https://revdocs.vbrick.com/reference/getdmedevices-1)\r\n */\r\nexport interface DeviceAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function deviceAPIFactory(rev: RevClient) {\r\n    const deviceAPI = {\r\n        /**\r\n         * Get a list of all DMEs\r\n         * @returns\r\n         */\r\n        async listDMEs(): Promise<Device.DmeDetails[]> {\r\n            const response = await rev.get('/api/v2/devices/dmes');\r\n            return response.devices;\r\n        },\r\n        /**\r\n         * Get a list of devices that can be used for Zoning configuration\r\n         * @returns\r\n         */\r\n        async listZoneDevices(): Promise<Device.ZoneDevice[]> {\r\n            const response = await rev.get('/api/v2/zonedevices');\r\n            return response.devices;\r\n        },\r\n        /**\r\n         * Get a list of the Presentation Profiles defined in Rev\r\n         * @returns\r\n         */\r\n        async listPresentationProfiles(): Promise<Device.PresentationProfile[]> {\r\n            return rev.get('/api/v2/presentation-profiles');\r\n        },\r\n        /**\r\n         * Create a new DME in Rev\r\n         * @param dme\r\n         * @returns\r\n         */\r\n        async add(dme: Device.CreateDMERequest) {\r\n            return rev.post('/api/v2/devices/dmes', dme);\r\n        },\r\n        /**\r\n         * Get details about the specified DME's health\r\n         * @param deviceId\r\n         * @returns\r\n         */\r\n        async healthStatus(deviceId: string): Promise<Device.DmeHealthStatus> {\r\n            return rev.get(`/api/v2/devices/dmes/${deviceId}/health-status`);\r\n        },\r\n        /**\r\n         * Remove a DME from Rev\r\n         * @param deviceId\r\n         * @returns\r\n         */\r\n        async delete(deviceId: string) {\r\n            return rev.delete(`/api/v2/devices/dmes/${deviceId}`);\r\n        },\r\n        /**\r\n         * Have Rev send a reboot request to the specified DME\r\n         * @param deviceId\r\n         * @returns\r\n         */\r\n        async rebootDME(deviceId: string) {\r\n            return rev.put(`/api/v2/devices/dmes/${deviceId}`);\r\n        }\r\n    };\r\n    return deviceAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Group, Rev, User } from '../types/index';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof groupAPIFactory>;\r\n\r\n/**\r\n * Group API methods\r\n * @category Users & Groups\r\n * @group API\r\n * @see [Group API Docs](https://revdocs.vbrick.com/reference/getgroups-1)\r\n */\r\nexport interface GroupAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function groupAPIFactory(rev: RevClient) {\r\n    const groupAPI = {\r\n        /**\r\n         * Create a group. Returns the resulting Group ID\r\n         * @param {{name: string, userIds: string[], roleIds: string[]}} group\r\n         * @returns {Promise<string>}\r\n         */\r\n        async create(group: Group.CreateRequest): Promise<string> {\r\n            const { groupId } = await rev.post('/api/v2/groups', group);\r\n            return groupId;\r\n        },\r\n        async delete(groupId: string) {\r\n            await rev.delete(`/api/v2/groups/${groupId}`);\r\n        },\r\n        async details(groupId: string): Promise<Group.Details> {\r\n            return rev.get(`/api/v2/groups/${groupId}`);\r\n        },\r\n        /**\r\n         *\r\n         * @param {string} [searchText]\r\n         * @param {Rev.SearchOptions<{Id: string, Name: string}>} [options]\r\n         */\r\n        search(searchText?: string, options: Rev.AccessEntitySearchOptions<Group.SearchHit> = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/access-entity${options?.assignable ? '/assignable' : ''}`,\r\n                totalKey: 'totalEntities',\r\n                hitsKey: 'accessEntities',\r\n                transform: (hits: Group.RawSearchHit[]) => hits.map(formatGroupSearchHit)\r\n            };\r\n            const query: Record<string, any> = { type: 'group' };\r\n            if (searchText) {\r\n                query.q = searchText;\r\n            }\r\n            return new SearchRequest<Group.SearchHit>(rev, searchDefinition, query, options);\r\n        },\r\n        list(options: Rev.SearchOptions<Group.SearchHit> = { }) {\r\n            return groupAPI.search(undefined, options);\r\n        },\r\n        listUsers(groupId: string, options: Rev.SearchOptions<string> = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/groups/${groupId}/users`,\r\n                totalKey: 'totalUsers',\r\n                hitsKey: 'userIds'\r\n            };\r\n            return new SearchRequest<string>(rev, searchDefinition, undefined, options);\r\n        },\r\n        /**\r\n         * get all users in a group with full details\r\n         * @param groupId\r\n         * @param options\r\n         * @returns\r\n         */\r\n        listUserDetails(groupId: string, options: Rev.SearchOptions<User & { error?: Error }> = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/groups/${groupId}/users`,\r\n                totalKey: 'totalUsers',\r\n                hitsKey: 'userIds',\r\n                transform: async (userIds: string[]) => {\r\n                    const result: User[] = [];\r\n                    for (let userId of userIds) {\r\n                        const out: User & {error: Error} = { userId } as any;\r\n                        try {\r\n                            const details = await rev.user.details(userId);\r\n                            Object.assign(out, details);\r\n                        } catch (error: any) {\r\n                            out.error = error;\r\n                        }\r\n                        result.push(out);\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n            return new SearchRequest<User & {userId: string, error?: Error}>(rev, searchDefinition, undefined, options);\r\n        }\r\n    };\r\n    return groupAPI;\r\n}\r\n\r\nfunction formatGroupSearchHit(hit: Group.RawSearchHit): Group.SearchHit {\r\n    return {\r\n        id: hit.Id,\r\n        name: hit.Name,\r\n        entityType: hit.EntityType\r\n    };\r\n}\r\n","import {RevClient} from \"../rev-client\";\r\nimport type { Playlist, Rev, Video } from \"../types/index\";\r\nimport { RateLimitEnum } from \"../utils/index\";\r\nimport { SearchRequest } from \"../utils/request-utils\";\r\n\r\nfunction getSummaryFromResponse<T extends Record<string, any>>(response: T, hitsKey: string) {\r\n    const ignoreKeys = ['scrollId', 'statusCode', 'statusDescription'];\r\n\r\n    const summary = Object.fromEntries(Object.entries(response)\r\n        .filter(([key, value]) => {\r\n            // don't include arrays or scroll type keys\r\n            return !(key === hitsKey || ignoreKeys.includes(key) || Array.isArray(value));\r\n        }));\r\n    return summary as Omit<Playlist.DetailsResponse, 'scrollId'>;\r\n}\r\n\r\n/** @category Playlists */\r\nexport class PlaylistDetailsRequest extends SearchRequest<Video.Details> {\r\n    playlist: Playlist & Omit<Playlist.DetailsResponse, 'scrollId'> = {} as any;\r\n    get playlistName() {\r\n        return this.playlist.playlistDetails?.name || this.playlist.name;\r\n    }\r\n    get searchFilter() {\r\n        return this.playlist?.playlistType === 'Dynamic'\r\n            ? this.playlist.playlistDetails?.searchFilter || this.playlist.searchFilter\r\n            : undefined;\r\n    }\r\n    /**\r\n     * @hidden\r\n     * @param rev\r\n     * @param playlistId\r\n     * @param query\r\n     * @param options\r\n     */\r\n    constructor(rev: RevClient, playlistId: string, query: { count?: number } = {}, options: Rev.SearchOptions<Video.Details> = {}) {\r\n        const searchDefinition: Rev.SearchDefinition<Video.Details> = {\r\n            endpoint: `/api/v2/playlists/${playlistId}`,\r\n            totalKey: 'totalVideos',\r\n            hitsKey: 'videos',\r\n            // get summary from initial response\r\n            request: async (endpoint, query, options) => {\r\n                await rev.session.queueRequest(RateLimitEnum.SearchVideos);\r\n                const response = await rev.get<Playlist.DetailsResponse>(endpoint, query, options);\r\n                // checking for playlist for possible future compatibility\r\n                Object.assign(this.playlist, getSummaryFromResponse(response, 'videos'));\r\n                return response;\r\n            }\r\n        };\r\n        super(rev, searchDefinition, query, options);\r\n    }\r\n    async getPlaylistInfo() {\r\n        // set maxResults to 0 to mark request as done, since first page of sessions will be lost\r\n        this.options.maxResults = 0;\r\n        // must get first page of results to load summary data\r\n        const {items: videos} = await this.nextPage();\r\n\r\n        return {\r\n            ...this.playlist,\r\n            ...this.playlist?.playlistDetails,\r\n            videos,\r\n            playlistName: this.playlistName,\r\n            searchFilter: this.searchFilter\r\n        };\r\n    }\r\n}\r\n\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Rev, Video } from '../types/index';\r\nimport type { Playlist } from '../types/playlist';\r\nimport { isPlainObject } from '../utils';\r\nimport { PlaylistDetailsRequest } from './playlist-details-request';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof playlistAPIFactory>;\r\n/**\r\n * Playlist API methods\r\n * @category Playlists\r\n * @group API\r\n * @see [Playlist API Docs](https://revdocs.vbrick.com/reference/getplaylists)\r\n */\r\nexport interface PlaylistAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function playlistAPIFactory(rev: RevClient) {\r\n    const playlistAPI = {\r\n        async create(name: string, videos: string[] | Video.SearchOptions): Promise<string> {\r\n            const isStatic = Array.isArray(videos);\r\n            const payload = isStatic\r\n                ? { name, playlistType: 'Static', videoIds: videos }\r\n                : { name, playlistType: 'Dynamic', playlistDetails: videos };\r\n\r\n            const { playlistId } = await rev.post('/api/v2/playlists', payload, { responseType: 'json' });\r\n            return playlistId;\r\n        },\r\n        async details(playlistId: string, query: { count?: number }): Promise<Playlist.DetailsResponse> {\r\n            return rev.get(`/api/v2/playlists/${playlistId}`, query, { responseType: 'json' });\r\n        },\r\n        listVideos(playlistId: string, query: { count?: number }, options?: Rev.SearchOptions<Video.Details>)  {\r\n            return new PlaylistDetailsRequest(rev, playlistId, query, options);\r\n        },\r\n        async update(playlistId: string, actions: Playlist.UpdateAction[] | Video.SearchOptions): Promise<void> {\r\n            const isStatic = Array.isArray(actions);\r\n            const payload = isStatic\r\n                ? { playlistVideoDetails: actions }\r\n                : { playlistDetails: actions };\r\n\r\n            return rev.put(`/api/v2/playlists/${playlistId}`, payload);\r\n        },\r\n        async updateFeatured(actions: Playlist.UpdateAction[]): Promise<void> {\r\n            const payload = {\r\n                playlistVideoDetails: actions\r\n            };\r\n            return rev.put(`/api/v2/playlists/featured-playlist`, payload);\r\n        },\r\n        async delete(playlistId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/playlists/${playlistId}`);\r\n        },\r\n        /**\r\n         * get list of playlists in system.\r\n         * NOTE: return type is slightly different than API documentation\r\n         * @see {@link https://revdocs.vbrick.com/reference#getplaylists}\r\n         */\r\n        async list(): Promise<Playlist.List> {\r\n            // ensure raw response is in consistent format\r\n            function parsePlaylist(entry: Record<string, string> & { videos: any; }): Playlist {\r\n                const {\r\n                    id,\r\n                    playlistId,\r\n                    featurePlaylistId,\r\n                    featuredPlaylist,\r\n                    name,\r\n                    playlistName,\r\n                    ...extra\r\n                } = entry;\r\n                return {\r\n                    ...(extra as any),\r\n                    id: id ?? playlistId ?? featurePlaylistId ?? featuredPlaylist,\r\n                    name: name ?? playlistName,\r\n                    videos: entry.videos ?? entry.Videos as any,\r\n                };\r\n            }\r\n\r\n            const rawResult = await rev.get('/api/v2/playlists', undefined, { responseType: 'json' });\r\n            // rawResult may return in strange format, so cleanup and return consistent output\r\n\r\n            const hasFeatured = !Array.isArray(rawResult);\r\n\r\n            const rawPlaylists = hasFeatured\r\n                ? rawResult.playlists\r\n                : rawResult;\r\n\r\n\r\n            const output: Playlist.List = {\r\n                playlists: rawPlaylists.map(parsePlaylist)\r\n            };\r\n\r\n            if (hasFeatured) {\r\n                if (isPlainObject(rawResult.featuredPlaylist)) {\r\n                    output.featuredPlaylist = parsePlaylist(rawResult.featuredPlaylist);\r\n                } else if (Array.isArray(rawResult.videos)) {\r\n                    output.featuredPlaylist = parsePlaylist(rawResult);\r\n                }\r\n            }\r\n            return output;\r\n        }\r\n    };\r\n    return playlistAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Recording } from '../types/recording';\r\nimport type { Video } from '../types/video';\r\nimport { isPlainObject } from '../utils';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof recordingAPIFactory>;\r\n\r\n/**\r\n * Recording-related API methods\r\n * @category Videos\r\n * @group API\r\n * @see [Recording API Docs](https://revdocs.vbrick.com/reference/startrecording)\r\n */\r\nexport interface RecordingAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function recordingAPIFactory(rev: RevClient) {\r\n    const recordingAPI = {\r\n        async startVideoConferenceRecording(sipAddress: string, sipPin: string, title?: string): Promise<string> {\r\n            const { videoId } = await rev.post('/api/v2/vc/start-recording', { title, sipAddress, sipPin }, { responseType: 'json' });\r\n            return videoId;\r\n        },\r\n        async getVideoConferenceStatus(videoId: string): Promise<Video.StatusEnum> {\r\n            const { status } = await rev.get(`/api/v2/vc/recording-status/${videoId}`, undefined, { responseType: 'json' });\r\n            return status;\r\n        },\r\n        async stopVideoConferenceRecording(videoId: string): Promise<string> {\r\n            const payload = { videoId };\r\n            const result = await rev.post(`/api/v2/vc/stop-recording`, payload, { responseType: 'json' });\r\n            return isPlainObject<{ message: string; }>(result)\r\n                ? result.message\r\n                : result;\r\n        },\r\n        async startPresentationProfileRecording(request: Recording.PresentationProfileRequest): Promise<string> {\r\n            const { scheduledRecordingId } = await rev.post('/api/v2/pp/start-recording', request, { responseType: 'json' });\r\n            return scheduledRecordingId;\r\n        },\r\n        async getPresentationProfileStatus(recordingId: string): Promise<Recording.PresentationProfileStatus> {\r\n            const result = await rev.get(`/api/v2/pp/recording-status/${recordingId}`, undefined, { responseType: 'json' });\r\n            return result;\r\n        },\r\n        async stopPresentationProfileRecording(recordingId: string): Promise<Recording.StopPresentationProfileResponse> {\r\n            const payload = { scheduledRecordingId: recordingId };\r\n            const result = await rev.get(`/api/v2/vc/recording-status`, payload, { responseType: 'json' });\r\n            return result;\r\n        }\r\n    };\r\n    return recordingAPI;\r\n}\r\n","import polyfills from '../interop/polyfills';\r\nimport type { RevClient } from '../rev-client';\r\nimport type { Rev, Transcription, Video, Webcast } from '../types/index';\r\nimport type { Upload } from '../types/upload';\r\nimport { RateLimitEnum } from '../utils';\r\nimport { appendFileToForm, appendJSONToForm, uploadMultipart } from '../utils/multipart-utils';\r\n\r\nfunction splitOptions(options: Rev.UploadFileOptions & Rev.RequestOptions, defaultType?: string) {\r\n    const {\r\n        filename,\r\n        contentType,\r\n        contentLength,\r\n        useChunkedTransfer,\r\n        defaultContentType = defaultType,\r\n        ...requestOptions\r\n    } = options;\r\n\r\n    return {\r\n        requestOptions,\r\n        uploadOptions: {\r\n            ...filename && {filename},\r\n            ...contentType && {contentType},\r\n            ...contentLength && {contentLength},\r\n            ...useChunkedTransfer && {useChunkedTransfer},\r\n            defaultContentType\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport type API = ReturnType<typeof uploadAPIFactory>;\r\n/**\r\n * Functions to upload binary content to Rev.\r\n * @category Videos\r\n * @group API\r\n * @see [Upload API Docs](https://revdocs.vbrick.com/reference/uploadvideo-1)\r\n */\r\nexport interface UploadAPI extends API {};\r\n\r\n/** @ignore */\r\nexport default function uploadAPIFactory(rev: RevClient) {\r\n    const uploadAPI = {\r\n        /**\r\n         * Upload a video, and returns the resulting video ID\r\n         * @see [API Docs](https://revdocs.vbrick.com/reference/uploadvideo-1)\r\n         *\r\n         * @example\r\n         * ```js\r\n        const rev = new RevClient(...config...);\r\n        await rev.connect();\r\n\r\n        // if browser - pass in File\r\n        const file = fileInputElement.files[0];\r\n        // if nodejs - can pass in path to file instead\r\n        // const file = \"/path/to/local/video.mp4\";\r\n        // upload returns resulting ID when complete\r\n        const videoId = await rev.upload.video(file, {\r\n            uploader: 'username.of.uploader',\r\n            title: 'video uploaded via the API',\r\n            //categories: [EXISTING_REV_CATEGORY_NAME],\r\n            unlisted: true,\r\n            isActive: true\r\n            /// ...any additional metadata\r\n        });\r\n        ```\r\n         * @param file A File/Blob. if using nodejs you can also pass in the path to a file\r\n         * @param metadata metadata to add to video (title, etc.) - see API docs\r\n         * @param options Additional `RequestInit` options, as well as customizing the contentType/contentLength/filename of the `file` in the POST upload form (only needed if they can't be inferred from input)\r\n         * @returns the resulting video id\r\n         */\r\n        async video(\r\n            file: Rev.FileUploadType,\r\n            metadata: Video.UploadMetadata = { uploader: rev.session.username ?? '' },\r\n            options: Upload.VideoOptions = {}): Promise<string> {\r\n\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'video/mp4');\r\n\r\n            // prepare payload\r\n            const form = new polyfills.FormData();\r\n\r\n            // at bare minimum the uploader needs to be defined\r\n            if (!metadata.uploader) {\r\n                // if using username login then uploader can be set to current user\r\n                const defaultUsername = rev.session.username;\r\n                if (defaultUsername) {\r\n                    metadata.uploader = defaultUsername;\r\n                } else {\r\n                    throw new TypeError('metadata must include uploader parameter');\r\n                }\r\n            }\r\n\r\n            // add video metadata to body (as json)\r\n            appendJSONToForm(form, 'video', metadata);\r\n\r\n            // append file (works around some node's form-data library quirks)\r\n            const filePayload = await appendFileToForm(form, 'VideoFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await rev.session.queueRequest(RateLimitEnum.UploadVideo);\r\n\r\n            const { videoId } = await uploadMultipart(rev, 'POST', '/api/v2/uploads/videos', form, filePayload, requestOptions);\r\n            return videoId;\r\n        },\r\n        /**\r\n         * Replace an existing video with an uploaded file\r\n         * @see [API Docs](https://revdocs.vbrick.com/reference/replacevideo)\r\n         */\r\n        async replaceVideo(videoId: string, file: Rev.FileUploadType, options: Upload.VideoOptions = {}): Promise<void> {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'video/mp4');\r\n            const form = new polyfills.FormData();\r\n            const filePayload = await appendFileToForm(form, 'VideoFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Replacing ${videoId} with ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await rev.session.queueRequest(RateLimitEnum.UploadVideo);\r\n\r\n            await uploadMultipart(rev, 'PUT', `/api/v2/uploads/videos/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        async transcription(videoId: string, file: Rev.FileUploadType, language: Transcription.SupportedLanguage = 'en', options: Upload.TranscriptionOptions = { }): Promise<void> {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'application/x-subrip');\r\n\r\n            const form = new polyfills.FormData();\r\n            const lang = language.toLowerCase();\r\n\r\n            // uploads will fail if files end with the txt file extension, so make sure it's set to a valid value\r\n            if (uploadOptions.contentType === 'text/plain' || uploadOptions.filename?.endsWith('txt')) {\r\n                uploadOptions.filename = `${uploadOptions.filename || 'upload'}.srt`;\r\n            }\r\n\r\n            const filePayload = await appendFileToForm(form, 'File', file, uploadOptions);\r\n            const metadata = {\r\n                files: [\r\n                    { language: lang, fileName: filePayload.filename }\r\n                ]\r\n            };\r\n            appendJSONToForm(form, 'TranscriptionFiles', metadata);\r\n\r\n            rev.log('info', `Uploading transcription to ${videoId} ${lang} ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/transcription-files/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        async supplementalFile(videoId: string, file: Rev.FileUploadType, options: Upload.SupplementalOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options);\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'File', file, uploadOptions);\r\n            const metadata = {\r\n                files: [\r\n                    { fileName: filePayload.filename }\r\n                ]\r\n            };\r\n            appendJSONToForm(form, 'SupplementalFiles', metadata);\r\n\r\n            rev.log('info', `Uploading supplemental content to ${videoId} ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/supplemental-files/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        /**\r\n         *\r\n         * @param videoId id of video to add chapters to\r\n         * @param chapters list of chapters. Must have time value and one of title or imageFile\r\n         * @param action replace = POST/replace existing with this payload\r\n         *               append = PUT/add or edit without removing existing\r\n         * @param options  additional upload + request options\r\n         */\r\n        async chapters(videoId: string, chapters: Video.Chapter.Request[], action: 'append' | 'replace' = 'replace', options: Rev.RequestOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/png');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            type ChapterPayload = Video.Chapter.Request & {imageFile?: string};\r\n\r\n            const metadata: {chapters: ChapterPayload[]} = {\r\n                chapters: []\r\n            };\r\n\r\n            for (let [index, chapter] of chapters.entries()) {\r\n                const {\r\n                    title, time, imageFile, uploadOptions: fileUploadOptions = {}\r\n                } = chapter;\r\n\r\n                const chapterEntry: ChapterPayload = { time };\r\n                if (title) {\r\n                    chapterEntry.title = title;\r\n                }\r\n\r\n                if (imageFile) {\r\n                    const fileOpts = {\r\n                        ...uploadOptions,\r\n                        // explicitly set filename to avoid conflict with multiple chapters\r\n                        filename: `chapter${index + 1}`,\r\n                        ...fileUploadOptions,\r\n                    };\r\n                    const filePayload = await appendFileToForm(form, 'File', imageFile, fileOpts);\r\n                    // add image filename based on what was appended to form\r\n                    chapterEntry.imageFile = filePayload.filename;\r\n                }\r\n                metadata.chapters.push(chapterEntry);\r\n            }\r\n\r\n            appendJSONToForm(form, 'Chapters', metadata);\r\n\r\n            rev.log('info', `${action === 'replace' ? 'Uploading' : 'Updating'} ${metadata.chapters.length} chapters to ${videoId}`);\r\n\r\n            const method = action === 'replace'\r\n                ? 'POST'\r\n                : 'PUT';\r\n\r\n            await uploadMultipart(rev, method, `/api/v2/uploads/chapters/${videoId}`, form, uploadOptions, requestOptions);\r\n        },\r\n        async thumbnail(videoId: string, file: Rev.FileUploadType, options: Upload.ImageOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/jpeg');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'ThumbnailFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading thumbnail for ${videoId} ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/images/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        async presentationChapters(videoId: string, file: Rev.FileUploadType, options: Upload.PresentationChaptersOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'application/vnd.ms-powerpoint');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'PresentationFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading presentation for ${videoId} ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/video-presentations/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        async webcastPresentation(eventId: string, file: Rev.FileUploadType, options: Upload.PresentationChaptersOptions) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'application/vnd.ms-powerpoint');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'PresentationFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading presentation for ${eventId} ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/presentations/${eventId}`, form, filePayload, requestOptions);\r\n        },\r\n        async webcastBackground(eventId: string, file: Rev.FileUploadType, options: Upload.ImageOptions) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/jpeg');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'ImageFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading background image for ${eventId} ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/background-image/${eventId}`, form, filePayload, requestOptions);\r\n        },\r\n        async webcastProducerLayoutBackground(eventId: string, file: Rev.FileUploadType, options: Upload.ImageOptions) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/jpeg');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'ImageFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading producer layout background image for ${eventId} ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/webcast-producer-bgimage/${eventId}`, form, filePayload, requestOptions);\r\n        },\r\n        async webcastBranding(eventId: string, request: Webcast.BrandingRequest, options: Upload.ImageOptions = { }): Promise<void> {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/jpeg');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const logoOptions: Rev.UploadFileOptions = {\r\n                ...uploadOptions,\r\n                // make sure filename is by default unique\r\n                filename: 'logo',\r\n                ...(request.logoImageOptions ?? {})\r\n            };\r\n            const backgroundOptions: Rev.UploadFileOptions = {\r\n                ...uploadOptions,\r\n                // make sure filename is by default unique\r\n                filename: 'background',\r\n                ...(request.logoImageOptions ?? {})\r\n            };\r\n\r\n            const logoImagePayload = await appendFileToForm(form, 'LogoImageFile', request.logoImage, logoOptions);\r\n            const backgroundImagePayload = await appendFileToForm(form, 'BackgroundImageFile', request.backgroundImage, backgroundOptions);\r\n\r\n            const meta = {\r\n                ...request.branding,\r\n                logoImageFilename: logoImagePayload.filename,\r\n                backgroundImageFilename: backgroundImagePayload.filename\r\n            };\r\n\r\n            appendJSONToForm(form, 'Branding', meta);\r\n\r\n            rev.log('info', `Uploading webcast branding to ${eventId} (${meta.logoImageFilename} ${meta.backgroundImageFilename})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/webcast-branding/${eventId}`, form, uploadOptions, requestOptions);\r\n        },\r\n        async channelLogo(channelId: string, file: Rev.FileUploadType, options: Upload.ImageOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/jpeg');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'ImageFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading channel logo for ${channelId} (${filePayload.filename} ${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/channel-logo/${channelId}`, form, filePayload, requestOptions);\r\n        },\r\n        /**\r\n         * @summary Upload Channel Header Image\r\n         * @see [API Docs](https://revdocs.vbrick.com/reference/uploadchannellogofile)\r\n         * @param channelId Id of the channel to upload image\r\n         * @param file image file\r\n         * @param options\r\n         */\r\n        async channelHeader(channelId: string, file: Rev.FileUploadType, options: Upload.ImageOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/jpeg');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'ImageFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading channel header for ${channelId} (${filePayload.filename} ${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/channel-header/${channelId}`, form, filePayload, requestOptions);\r\n        },\r\n        /**\r\n         * Upload a profile image for a given user. Only account admins can upload user profile image.\r\n         */\r\n        async userProfileImage(userId: string, file: Rev.FileUploadType, options: Upload.ImageOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/jpeg');\r\n\r\n            const form = new polyfills.FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'ImageFile', file, uploadOptions);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/profile-image/${userId}`, form, filePayload, requestOptions);\r\n        }\r\n    };\r\n\r\n    return uploadAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Rev, User } from '../types/index';\r\nimport type { LiteralString } from '../types/rev';\r\nimport { RateLimitEnum } from '../utils';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof userAPIFactory>;\r\n\r\n/**\r\n * User API methods\r\n * @category Users & Groups\r\n * @group API\r\n * @see [User API Docs](https://revdocs.vbrick.com/reference/createuser)\r\n */\r\nexport interface UserAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function userAPIFactory(rev: RevClient) {\r\n    /**\r\n     * Get details about a specific user\r\n     * By default it will lookup users by `userId`. To lookup by `username` or `email` pass in the second parameter `{lookupType}`. Specify the special value `'me'` to get details of the authenticated user\r\n     *\r\n     * @param userLookupValue userId, username or email\r\n     * @param options the lookup type {lookupType: 'username'} as well as any additional {@link Rev.RequestOptions | request options}\r\n     *\r\n     * @example\r\n     * ```js\r\n     * const rev = new RevClient(...config...);\r\n     * await rev.connect();\r\n     *\r\n     * // get details of the current user\r\n     * let user = await rev.user.details('me');\r\n     * // { userId: '<guid>', username: 'string', email: 'string', ... }\r\n     *\r\n     * // now get the same user record, just change the lookup criteria\r\n     * console.log('looking up by id', user.userId);\r\n     * user = await rev.user.details(user.userId);\r\n     *\r\n     * console.log('looking up by username', user.username);\r\n     * user = await rev.user.details(user.username, { lookupType: 'username' });\r\n     *\r\n     * console.log('looking up by email', user.email);\r\n     * user = await rev.user.details(user.email, { lookupType: 'email' });\r\n     * ```\r\n     *\r\n     * @see [Get User by ID](https://revdocs.vbrick.com/reference/getuser)\r\n     * @see [Get User by Username](https://revdocs.vbrick.com/reference/getuserbyusername)\r\n     * @see [Get User by Email](https://revdocs.vbrick.com/reference/getuserbyemail)\r\n     */\r\n    function details(userLookupValue: string, options?: User.DetailsOptions): Promise<User>;\r\n    /**\r\n     * @deprecated\r\n     * use {@link UserAPI.details | updated signature} `details(userLookupValue, {lookupType: 'userId' | 'username' | 'email'})` instead\r\n     */\r\n    function details(userLookupValue: string, type: 'userId' | 'email' | 'username'): Promise<User>;\r\n    async function details(userLookupValue: string, options: User.DetailsLookup | User.DetailsOptions = {}) {\r\n        const {lookupType, ...requestOptions} = typeof options === 'string'\r\n            ? {lookupType: options}\r\n            : options;\r\n\r\n        const query = (lookupType === 'username' || lookupType === 'email')\r\n            ? { type: lookupType }\r\n            : undefined;\r\n\r\n        const result = await rev.get(`/api/v2/users/${userLookupValue}`, query, {...requestOptions, responseType: 'json'});\r\n\r\n        // email lookup returns an array\r\n        return Array.isArray(result)\r\n            ? result[0]\r\n            : result;\r\n    }\r\n\r\n    const userAPI = {\r\n        /**\r\n         * get the list of roles available in the system (with role name and id)\r\n         */\r\n        get roles() {\r\n            return rev.admin.roles;\r\n        },\r\n        /**\r\n         * Create a new User in Rev\r\n         * @param user\r\n         * @returns the User ID of the created user\r\n         */\r\n        async create(user: User.Request): Promise<string> {\r\n            const { userId } = await rev.post('/api/v2/users', user);\r\n            return userId;\r\n        },\r\n        async delete(userId: string): Promise<void> {\r\n            await rev.delete(`/api/v2/users/${userId}`);\r\n        },\r\n        details,\r\n        /**\r\n         * Use the Details API to get information about currently logged in user\r\n         * @param requestOptions\r\n         */\r\n        async profile(requestOptions?: Rev.RequestOptions) {\r\n            return details('me', requestOptions);\r\n        },\r\n        /**\r\n         * get user details by username\r\n         * @deprecated use {@link UserAPI.details | user.details()} with `{lookupType: 'username'}`\r\n         */\r\n        async getByUsername(username: string) {\r\n            // equivalent to rev.get<User>(`/api/v2/users/${username}`, { type: 'username' });\r\n            return userAPI.details(username, {lookupType: 'username'});\r\n        },\r\n        /**\r\n         * get user details by email address\r\n         * @deprecated use {@link UserAPI.details | user.details()} with `{lookupType: 'email'}`\r\n         */\r\n        async getByEmail(email: string) {\r\n            return userAPI.details(email, {lookupType: 'email'});\r\n        },\r\n        /**\r\n         * Check if user exists in the system. Instead of throwing on a 401/403 error if\r\n         * user does not exist it returns `false`. Returns {@link User | user details} if does exist,\r\n         * instead of just `true`\r\n         * @param userLookupValue userId, username, or email\r\n         * @param type\r\n         * @returns User if exists, otherwise false\r\n         */\r\n        async exists(userLookupValue: string, type?: User.DetailsLookup): Promise<User | false> {\r\n            const query = (type === 'username' || type === 'email')\r\n            ? { type }\r\n            : undefined;\r\n\r\n            const response = await rev.request<User>('GET', `/api/v2/users/${userLookupValue}`, query, { responseType: 'json', throwHttpErrors: false });\r\n\r\n            return response.statusCode === 200\r\n                ? response.body\r\n                : false;\r\n        },\r\n        /**\r\n         * use PATCH API to add user to the specified group\r\n         * https://revdocs.vbrick.com/reference#edituserdetails\r\n         * @param {string} userId id of user in question\r\n         * @param {string} groupId\r\n         * @returns {Promise<void>}\r\n         */\r\n        async addToGroup(userId: string, groupId: string) {\r\n            const operations = [\r\n                { op: 'add', path: '/GroupIds/-', value: groupId }\r\n            ];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        /**\r\n         * use PATCH API to add user to the specified group\r\n         * https://revdocs.vbrick.com/reference#edituserdetails\r\n         * @param {string} userId id of user in question\r\n         * @param {string} groupId\r\n         * @returns {Promise<void>}\r\n         */\r\n        async removeFromGroup(userId: string, groupId: string) {\r\n            const operations = [\r\n                { op: 'remove', path: '/GroupIds', value: groupId }\r\n            ];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        async suspend(userId: string) {\r\n            const operations = [{ op: 'replace', path: '/ItemStatus', value: 'Suspended' }];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        async unsuspend(userId: string) {\r\n            const operations = [{ op: 'replace', path: '/ItemStatus', value: 'Active' }];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        /**\r\n         * search for users based on text query. Leave blank to return all users.\r\n         *\r\n         * @param {string} [searchText]\r\n         * @param {Rev.SearchOptions<{Id: string, Name: string}>} [options]\r\n         */\r\n        search(searchText?: string, options: Rev.AccessEntitySearchOptions<User.SearchHit> = { }): Rev.ISearchRequest<User.SearchHit> {\r\n            const {\r\n                assignable = false\r\n            } = options;\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/access-entity${assignable ? '/assignable' : ''}`,\r\n                totalKey: 'totalEntities',\r\n                hitsKey: 'accessEntities',\r\n                /**\r\n                 * the result of this search is uppercase keys. This transforms them to camelcase to match other API responses\r\n                 */\r\n                transform: (items: User.RawSearchHit[]) => items.map(formatUserSearchHit)\r\n            };\r\n            const query: Record<string, any> = { type: 'user' };\r\n            if (searchText) {\r\n                query.q = searchText;\r\n            }\r\n            return new SearchRequest(rev, searchDefinition, query, options);\r\n        },\r\n        get listChannels() {\r\n            return rev.channel.listUserChannels;\r\n        },\r\n        /**\r\n         * Returns the channel and category subscriptions for the user making the API call.\r\n         */\r\n        async listSubscriptions(): Promise<{ categories: string[], channels: string[] }> {\r\n            return rev.get('/api/v2/users/subscriptions');\r\n        },\r\n        async subscribe(id: string, type: LiteralString<'Channel' | 'Category'>): Promise<void> {\r\n            return rev.post('/api/v2/users/subscribe', { id, type });\r\n        },\r\n        /**\r\n         * Unsubscribe from specific channel or category.\r\n         */\r\n        async unsubscribe(id: string, type: LiteralString<'Channel' | 'Category'>): Promise<void> {\r\n            return rev.post('/api/v2/users/unsubscribe', { id, type });\r\n        },\r\n        async getNotifications(unread: boolean = false): Promise<{ count: number, notifications: User.Notification[]}> {\r\n            return rev.get('/api/v2/users/notifications', { unread });\r\n        },\r\n        /**\r\n         *\r\n         * @param notificationId If notificationId not provided, then all notifications for the user are marked as read.\r\n         */\r\n        async markNotificationRead(notificationId?: string): Promise<void> {\r\n            await rev.put('/api/v2/users/notifications', notificationId ? {notificationId} : undefined);\r\n        },\r\n        async loginReport(sortField?: User.LoginReportSort, sortOrder?: Rev.SortDirection): Promise<User.LoginReportEntry[]> {\r\n            const query = {\r\n                ...sortField && { sortField },\r\n                ...sortOrder && { sortOrder }\r\n            };\r\n            await rev.session.queueRequest(RateLimitEnum.GetUsersByLoginDate);\r\n            const {Users} = await rev.get('/api/v2/users/login-report', query, { responseType: 'json' });\r\n            return Users;\r\n        },\r\n        get uploadProfileImage() {\r\n            return rev.upload.userProfileImage;\r\n        },\r\n        deleteProfileImage(userId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/users/${userId}/profile-image`);\r\n        }\r\n    };\r\n    return userAPI;\r\n}\r\n\r\nfunction formatUserSearchHit(hit: User.RawSearchHit): User.SearchHit {\r\n    return {\r\n        userId: hit.Id,\r\n        entityType: hit.EntityType,\r\n        email: hit.Email,\r\n        firstname: hit.FirstName,\r\n        lastname: hit.LastName,\r\n        username: hit.UserName,\r\n        profileImageUri: hit.ProfileImageUri\r\n    };\r\n}\r\n","import type { Rev, Transcription, Video } from \"../types\";\r\nimport { isPlainObject } from \"../utils\";\r\nimport type {RevClient} from \"../rev-client\";\r\n\r\n/** @ignore */\r\nexport function videoDownloadAPI(rev: RevClient) {\r\n    /**\r\n     * Download a video. does not parse the output body. Note that content is sent as transfer-encoding: chunked;\r\n     * @param videoId\r\n     * @returns\r\n     */\r\n    async function download<T = ReadableStream>(videoId: string, options: Rev.RequestOptions = {}): Promise<Rev.Response<T>> {\r\n        const response = await rev.request<T>('GET', `/api/v2/videos/${videoId}/download`, undefined, {\r\n            responseType: 'stream',\r\n            ...options\r\n        });\r\n        return response;\r\n    }\r\n\r\n    /**\r\n     * download specified chapter. The chapter object has an imageUrl, this just wraps the functionality and adds the authorization header\r\n     * @param chapter chapter object returned from the video.chapters(videoId) API call\r\n     * @returns\r\n     */\r\n    async function downloadChapter(chapter: Video.Chapter, options: Rev.RequestOptions = {}) {\r\n        const {imageUrl} = chapter;\r\n        const { body } = await rev.request<Blob>('GET', imageUrl, undefined, { responseType: 'blob', ...options });\r\n        return body;\r\n    }\r\n\r\n    async function downloadSupplemental<T = Blob>(file: Video.SupplementalFile, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadSupplemental<T = Blob>(videoId: string, fileId: string, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadSupplemental<T = Blob>(videoId: Video.SupplementalFile | string, fileId?: string | Rev.RequestOptions, options?: Rev.RequestOptions): Promise<T> {\r\n        const endpoint = isPlainObject(videoId)\r\n            ? videoId.downloadUrl\r\n            : `/api/v2/videos/${videoId}/supplemental-files/${fileId}`;\r\n\r\n        const opts = isPlainObject(fileId) ? fileId : options;\r\n\r\n        const { body } = await rev.request<T>('GET', endpoint, undefined, { responseType: 'blob', ...opts });\r\n        return body;\r\n    }\r\n\r\n    async function downloadTranscription<T = Blob>(transcription: Transcription, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadTranscription<T = Blob>(videoId: string, language: string, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadTranscription<T = Blob>(videoId: Transcription | string, language?: string | Rev.RequestOptions, options?: Rev.RequestOptions): Promise<T> {\r\n        const endpoint = isPlainObject(videoId)\r\n            ? videoId.downloadUrl\r\n            : `/api/v2/videos/${videoId}/transcription-files/${language}`;\r\n\r\n        const opts = isPlainObject(language) ? language : options;\r\n\r\n        const { body } = await rev.request<T>('GET', endpoint, undefined, { responseType: 'blob', ...opts });\r\n        return body;\r\n    }\r\n\r\n    async function downloadThumbnail<T = Blob>(thumbnailUrl: string, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadThumbnail<T = Blob>(query: { imageId: string }, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadThumbnail<T = Blob>(query: { videoId: string }, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadThumbnail<T = Blob>(query: string | { videoId?: string, imageId?: string; }, options: Rev.RequestOptions = {}): Promise<T> {\r\n        let {\r\n            videoId = '',\r\n            imageId = ''\r\n        } = typeof query === 'string'\r\n                ? { imageId: query }\r\n                : query;\r\n\r\n        if (!(videoId || imageId)) {\r\n            throw new TypeError('No video/image specified to download');\r\n        }\r\n\r\n        let thumbnailUrl: string = '';\r\n\r\n        if (videoId) {\r\n            thumbnailUrl = `/api/v2/videos/${videoId}/thumbnail`;\r\n            // allow getting from api if only know the video ID\r\n            // imageId = (await rev.get<{video: Video.Playback}>(`/api/v2/videos/${videoId}/playback-url`)).video.thumbnailUrl;\r\n        } else if (imageId.startsWith('http')) {\r\n            // thumbnail URI\r\n            thumbnailUrl = `${imageId}${!imageId.endsWith('.jpg') ? '.jpg' : ''}`;\r\n        } else {\r\n            thumbnailUrl = `/api/v2/media/videos/thumbnails/${imageId}.jpg`;\r\n        }\r\n\r\n        const { body } = await rev.request<T>('GET', thumbnailUrl, undefined, { responseType: 'blob', ...options });\r\n        return body;\r\n    }\r\n    /**\r\n     * Download the thumbnail sheet image for a video\r\n     * @param thumbnailSheet the thumbnailSheetUri or Thumbnail Configuration (get from video.thumbnailConfiguration)\r\n     * @param options\r\n     * @returns\r\n     */\r\n    async function downloadThumbnailSheet<T = Blob>(thumbnailSheet: string, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadThumbnailSheet<T = Blob>(thumbnailSheet: Video.ThumbnailConfiguration, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadThumbnailSheet<T = Blob>(thumbnailSheet: { videoId: string, sheetIndex?: string | number }, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadThumbnailSheet<T = Blob>(thumbnailSheet: string | { videoId: string, sheetIndex?: string | number } | Video.ThumbnailConfiguration, options?: Rev.RequestOptions): Promise<T> {\r\n        let thumbnailSheetsUri = '';\r\n        if (typeof thumbnailSheet === 'string') {\r\n            thumbnailSheetsUri = thumbnailSheet;\r\n        } else if (thumbnailSheet && typeof thumbnailSheet === 'object' && 'thumbnailSheetsUri' in thumbnailSheet) {\r\n            thumbnailSheetsUri = thumbnailSheet.thumbnailSheetsUri;\r\n        } else if (thumbnailSheet?.videoId) {\r\n            const {videoId, sheetIndex = '1'} = thumbnailSheet;\r\n            thumbnailSheetsUri = `/api/v2/videos/${videoId}/thumbnail-sheets/${sheetIndex}`;\r\n        }\r\n\r\n        if (!thumbnailSheetsUri) {\r\n            throw new TypeError('No thumbnail sheet specified to download');\r\n        }\r\n\r\n        const { body } = await rev.request<T>('GET', thumbnailSheetsUri, undefined, { responseType: 'blob', ...options });\r\n        return body;\r\n    }\r\n\r\n    return {\r\n        download,\r\n        downloadChapter,\r\n        downloadSupplemental,\r\n        downloadThumbnail,\r\n        downloadTranscription,\r\n        downloadThumbnailSheet\r\n    };\r\n}\r\n","import type { Rev, Video } from \"../types\";\r\nimport type { ExternalAccess } from '../types/video';\r\nimport { isPlainObject } from \"../utils\";\r\nimport type {RevClient} from \"../rev-client\";\r\nimport { SearchRequest } from \"../utils/request-utils\";\r\n\r\n/** @ignore */\r\nexport function videoExternalAccessAPI(rev: RevClient) {\r\n    return {\r\n        /**\r\n         *\r\n         * @param videoId Id of video to submit emails for external access\r\n         * @param q       Search string\r\n         * @param options search options\r\n         * @returns\r\n         */\r\n        listExternalAccess(videoId: string, q?: string, options?: Rev.SearchOptions<ExternalAccess>): Rev.ISearchRequest<ExternalAccess> {\r\n            const searchDefinition: Rev.SearchDefinition<ExternalAccess> = {\r\n                endpoint: `/api/v2/videos/${videoId}/external-access`,\r\n                /** NOTE: this API doesn't actually return a total, so this will always be undefined */\r\n                totalKey: 'total',\r\n                hitsKey: 'items'\r\n            };\r\n            const payload = q ? {q} : undefined;\r\n            return new SearchRequest<ExternalAccess>(rev, searchDefinition, payload, options);\r\n        },\r\n        async createExternalAccess(videoId: string, request: ExternalAccess.Request): Promise<void> {\r\n            await rev.post(`/api/v2/videos/${videoId}/external-access`, request);\r\n        },\r\n        async renewExternalAccess(videoId: string, request: Pick<ExternalAccess.Request, 'emails' | 'noEmail'>): Promise<ExternalAccess.RenewResponse> {\r\n            return rev.put(`/api/v2/videos/${videoId}/external-access`, request);\r\n        },\r\n        async deleteExternalAccess(videoId: string, request: Pick<ExternalAccess.Request, 'emails'>) {\r\n            return rev.delete(`/api/v2/videos/${videoId}/external-access`, request);\r\n        },\r\n        async revokeExternalAccess(videoId: string, request: Pick<ExternalAccess.Request, 'emails'>) {\r\n            return rev.put<void>(`/api/v2/videos/${videoId}/external-access/revoke`, request);\r\n        }\r\n    }\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Rev, Video } from '../types/index';\r\nimport { RateLimitEnum, asValidDate, isPlainObject } from '../utils';\r\nimport { PagedRequest } from '../utils/paged-request';\r\n\r\n\r\nconst DEFAULT_INCREMENT: number = 30;\r\nconst DEFAULT_SORT: Rev.SortDirection = 'asc';\r\n\r\nfunction addDays(date: Date, numDays: number) {\r\n    const d = new Date(date.getTime());\r\n    d.setDate(d.getDate() + numDays);\r\n    return d;\r\n}\r\n\r\nfunction parseOptions(options: Video.VideoReportOptions) {\r\n    let {\r\n        incrementDays = DEFAULT_INCREMENT,\r\n        sortDirection = DEFAULT_SORT,\r\n        videoIds,\r\n        startDate,\r\n        endDate,\r\n        ...otherOptions\r\n    } = options;\r\n\r\n    // clamp increment to 1 minute - 30 days range\r\n    incrementDays = Math.min(\r\n        Math.max(\r\n            1 / 24 / 60,\r\n            parseFloat(incrementDays as any) || DEFAULT_INCREMENT\r\n        ),\r\n        30\r\n    );\r\n\r\n    // API expects videoIds as a string\r\n    if (Array.isArray(videoIds)) {\r\n        videoIds = videoIds\r\n            .map(s => s.trim())\r\n            .filter(Boolean)\r\n            .join(',');\r\n    }\r\n\r\n    return {\r\n        incrementDays, sortDirection, videoIds,\r\n        ...parseDates(startDate, endDate),\r\n        ...otherOptions\r\n    };\r\n}\r\n\r\nfunction parseDates(startArg: string | Date | undefined, endArg: string | Date | undefined) {\r\n    const now = new Date();\r\n    let startDate = asValidDate(startArg);\r\n    let endDate = asValidDate(endArg);\r\n\r\n    // if no end date set then use now, or startDate + 30 days\r\n    if (!endDate) {\r\n        if (startDate) {\r\n            endDate = addDays(startDate, 30);\r\n            if (endDate.getTime() > now.getTime()) {\r\n                endDate = now;\r\n            }\r\n        } else {\r\n            endDate = now;\r\n        }\r\n    }\r\n    // if no start/beginning date then use end - 30 days\r\n    if (!startDate)\r\n    {\r\n        startDate = addDays(endDate, -30);\r\n    }\r\n\r\n    // make sure times aren't swapped\r\n    if (startDate.getTime() > endDate.getTime()) {\r\n        [startDate, endDate] = [endDate, startDate];\r\n    }\r\n    return { startDate, endDate };\r\n}\r\n\r\n/** @category Videos */\r\nexport class VideoReportRequest extends PagedRequest<Video.VideoReportEntry> {\r\n    declare options: Required<ReturnType<typeof parseOptions>> & {scrollId?: string};\r\n    private _rev: RevClient;\r\n    private _endpoint: string;\r\n    /**\r\n     * @hidden\r\n     * @param rev\r\n     * @param options\r\n     * @param endpoint\r\n     */\r\n    constructor(rev: RevClient, options: Video.VideoReportOptions = {}, endpoint = \"/api/v2/videos/report\") {\r\n        super(parseOptions(options));\r\n        this._endpoint = endpoint;\r\n        this._rev = rev;\r\n    }\r\n    protected async _requestPage() {\r\n        const { startDate, endDate } = this;\r\n        const {incrementDays, sortDirection, videoIds, scrollId } = this.options;\r\n        const isAscending = sortDirection === 'asc';\r\n\r\n        let rangeStart = startDate;\r\n        let rangeEnd = endDate;\r\n        let done = false;\r\n\r\n        if (isAscending) {\r\n            rangeEnd = addDays(rangeStart, incrementDays);\r\n            if (rangeEnd >= endDate) {\r\n                done = true;\r\n                rangeEnd = endDate;\r\n            }\r\n        } else {\r\n            rangeStart = addDays(rangeEnd, -1 * incrementDays);\r\n            if (rangeStart <= startDate)\r\n            {\r\n                done = true;\r\n                rangeStart = startDate;\r\n            }\r\n        }\r\n\r\n        const query: Record<string, string> = {\r\n            after: rangeStart.toJSON(),\r\n            before: rangeEnd.toJSON(),\r\n            ...scrollId && {scrollId},\r\n            ...videoIds && {videoIds}\r\n        };\r\n\r\n        await this._rev.session.queueRequest(RateLimitEnum.GetVideoViewReport);\r\n        const page = await this._rev.post<{ sessions: Video.VideoReportEntry[], total: number, scrollId?: string }>(this._endpoint, query, { responseType: \"json\" });\r\n\r\n        const items = page.sessions ?? [];\r\n        this.options.scrollId = items.length === 0 ? undefined : page.scrollId;\r\n\r\n        // keep requesting same page if scrollId was returned\r\n        if (this.options.scrollId) {\r\n            done = false;\r\n        } else if (!done) {\r\n            // go to next date range\r\n            if (isAscending) {\r\n                this.startDate = rangeEnd;\r\n            } else {\r\n                this.endDate = rangeStart;\r\n            }\r\n        }\r\n\r\n        return {\r\n            items,\r\n            done\r\n        };\r\n    }\r\n    get startDate() { return this.options.startDate; }\r\n    set startDate(value) { this.options.startDate = value; }\r\n    get endDate() { return this.options.endDate; }\r\n    set endDate(value) { this.options.endDate = value; }\r\n}\r\n\r\n/** @ignore */\r\nexport function videoReportAPI(rev: RevClient) {\r\n    function report(options?: Video.VideoReportOptions): VideoReportRequest;\r\n    function report(videoId: string, options?: Video.VideoReportOptions): VideoReportRequest;\r\n    function report(videoId?: string | Video.VideoReportOptions, options: Video.VideoReportOptions = {}): VideoReportRequest {\r\n        if (isPlainObject(videoId)) {\r\n            options = videoId;\r\n        } else if (typeof videoId === 'string') {\r\n            options = {\r\n                ...(options ?? {}),\r\n                videoIds: videoId\r\n            };\r\n        }\r\n        return new VideoReportRequest(rev, options, '/api/v2/videos/report');\r\n    }\r\n    function summaryStatistics(videoId: string, startDate?: undefined, endDate?: undefined, options?: Rev.RequestOptions): Promise<Video.SummaryStatistics>;\r\n    function summaryStatistics(videoId: string, startDate: Date | string, endDate?: undefined, options?: Rev.RequestOptions): Promise<Video.SummaryStatistics>;\r\n    function summaryStatistics(videoId: string, startDate: Date | string, endDate: Date | string, options?: Rev.RequestOptions): Promise<Video.SummaryStatistics>;\r\n    function summaryStatistics(videoId: string, startDate?: Date | string, endDate: Date | string | undefined = new Date(), options?: Rev.RequestOptions): Promise<Video.SummaryStatistics> {\r\n        const payload = startDate\r\n            ? { after: new Date(startDate).toISOString(), before: asValidDate(endDate, new Date()).toISOString() }\r\n            : undefined;\r\n        return rev.get(`/api/v2/videos/${videoId}/summary-statistics`, payload, options);\r\n    }\r\n    return {\r\n        report,\r\n        uniqueSessionsReport(videoId: string, options: Video.UniqueSessionReportOptions = {}) {\r\n            return new VideoReportRequest(rev, options, `/api/v2/videos/${videoId}/report`);\r\n        },\r\n        summaryStatistics\r\n    };\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport { RevError } from '../rev-error';\r\nimport type { Admin, Rev, Transcription, Video } from '../types/index';\r\nimport { RateLimitEnum, sleep } from '../utils';\r\nimport { mergeHeaders } from '../utils/merge-headers';\r\nimport { SearchRequest } from '../utils/request-utils';\r\nimport { videoDownloadAPI } from './video-download';\r\nimport { videoExternalAccessAPI } from './video-external-access';\r\nimport { videoReportAPI } from './video-report-request';\r\n\r\n/** @ignore */\r\ntype VideoSearchDetailedItem = Video.SearchHit & (Video.Details | { error?: Error });\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport type API = ReturnType<typeof videoAPIFactory>;\r\n\r\n/**\r\n * Video API methods\r\n * @category Videos\r\n * @group API\r\n * @see [Video API Docs](https://revdocs.vbrick.com/reference/searchvideo)\r\n */\r\nexport interface VideoAPI extends API {};\r\n\r\n/** @ignore */\r\nexport default function videoAPIFactory(rev: RevClient) {\r\n    /** get list of comments on a video\r\n     *\r\n     * set `showAll` param to `true` to include un-redacted values of comments (admin only)\r\n     */\r\n    function comments(videoId: string): Promise<Video.Comment[]>;\r\n    function comments(videoId: string, showAll: true): Promise<Video.Comment.Unredacted[]>;\r\n    async function comments(videoId: string, showAll: boolean = false): Promise<Video.Comment[] | Video.Comment.Unredacted[]> {\r\n        const response = await rev.get<Video.Comment.ListResponse>(`/api/v2/videos/${videoId}/comments`, showAll ? { showAll: 'true' } : undefined);\r\n        return response.comments;\r\n    }\r\n\r\n    const videoAPI = {\r\n        /**\r\n         * This is an example of using the video Patch API to only update a single field\r\n         * @param videoId\r\n         * @param title\r\n         */\r\n        async setTitle(videoId: string, title: string) {\r\n            const payload = [{ op: 'add', path: '/Title', value: title }];\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.patch(`/api/v2/videos/${videoId}`, payload);\r\n        },\r\n        /**\r\n         * Use the Patch API to update a single Custom Field.\r\n         * @param videoId - id of video to update\r\n         * @param customField - the custom field object (with id and value)\r\n         */\r\n        async setCustomField(videoId: string, customField: Pick<Admin.CustomField, 'id' | 'value'>) {\r\n            // LEGACY behavior, only relevant for Rev < 7.48\r\n            // const payload = [\r\n            //     { op: 'remove', path: '/customFields', value: customField.id },\r\n            //     { op: 'add', path: '/customFields/-', value: customField }\r\n            // ];\r\n            const payload = [{\r\n                op: 'replace',\r\n                path: '/CustomFields',\r\n                value: [customField]\r\n            }];\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.patch(`/api/v2/videos/${videoId}`, payload);\r\n        },\r\n        async delete(videoId: string, options?: Rev.RequestOptions): Promise<void> {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.delete(`/api/v2/videos/${videoId}`, undefined, options);\r\n            // TIP: If delete returns a 401 then video has likely already been deleted\r\n        },\r\n        /**\r\n         * get processing status of a video\r\n         * @see [API Docs](https://revdocs.vbrick.com/reference/getvideostatus)\r\n         */\r\n        async status(videoId: string, options?: Rev.RequestOptions): Promise<Video.StatusResponse> {\r\n            return rev.get(`/api/v2/videos/${videoId}/status`, undefined, options);\r\n        },\r\n        /**\r\n         * get details of a video\r\n         * @see [API Docs](https://revdocs.vbrick.com/reference/getvideosdetails)\r\n         * @param videoId\r\n         * @param options\r\n         * @returns\r\n         */\r\n        async details(videoId: string, options?: Rev.RequestOptions): Promise<Video.Details> {\r\n            await rev.session.queueRequest(RateLimitEnum.GetVideoDetails);\r\n            return rev.get(`/api/v2/videos/${videoId}/details`, undefined, options);\r\n        },\r\n        async update(videoId: string, metadata: Video.UpdateRequest, options?: Rev.RequestOptions): Promise<void> {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.put(`/api/v2/videos/${videoId}`, metadata, options);\r\n        },\r\n        comments,\r\n        async chapters(videoId: string, options?: Rev.RequestOptions): Promise<Video.Chapter[]> {\r\n            try {\r\n                const {chapters} = await rev.get<{chapters: Video.Chapter[]}>(`/api/v2/videos/${videoId}/chapters`, undefined, options);\r\n                return chapters;\r\n            } catch (err) {\r\n                // if no chapters then this api returns a 400 response\r\n                if (err instanceof RevError && err.code === \"NoVideoChapters\") {\r\n                    return [];\r\n                }\r\n                throw err;\r\n            }\r\n        },\r\n        async supplementalFiles(videoId: string, options?: Rev.RequestOptions): Promise<Video.SupplementalFile[]> {\r\n            const {supplementalFiles} = await rev.get(`/api/v2/videos/${videoId}/supplemental-files`, undefined, options);\r\n            return supplementalFiles;\r\n        },\r\n        async thumbnailConfiguration(videoId: string, options?: Rev.RequestOptions): Promise<Video.ThumbnailConfiguration> {\r\n            const {thumbnailCfg} = await rev.get(`/api/v2/videos/${videoId}/thumbnail-config`, undefined, options);\r\n            return thumbnailCfg;\r\n        },\r\n        async transcriptions(videoId: string, options?: Rev.RequestOptions): Promise<Transcription[]> {\r\n            const {transcriptionFiles} = await rev.get(`/api/v2/videos/${videoId}/transcription-files`, undefined, options);\r\n            return transcriptionFiles;\r\n        },\r\n        get upload() {\r\n            return rev.upload.video;\r\n        },\r\n        get replace() {\r\n            return rev.upload.replaceVideo;\r\n        },\r\n        async migrate(videoId: string, options: Video.MigrateRequest, requestOptions?: Rev.RequestOptions) {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.put(`/api/v2/videos/${videoId}/migration`, options, requestOptions);\r\n        },\r\n        /**\r\n         * search for videos, return as one big list. leave blank to get all videos in the account\r\n         */\r\n        search(query: Video.SearchOptions = { }, options: Rev.SearchOptions<Video.SearchHit> = { }): Rev.ISearchRequest<Video.SearchHit> {\r\n            const searchDefinition: Rev.SearchDefinition<Video.SearchHit> = {\r\n                endpoint: '/api/v2/videos/search',\r\n                totalKey: 'totalVideos',\r\n                hitsKey: 'videos',\r\n                async request(endpoint, query, options) {\r\n                    await rev.session.queueRequest(RateLimitEnum.SearchVideos);\r\n                    return rev.get(endpoint, query, options);\r\n                }\r\n            };\r\n            const request = new SearchRequest<Video.SearchHit>(rev, searchDefinition, query, options);\r\n            return request;\r\n        },\r\n        /**\r\n         * Example of using the video search API to search for videos, then getting\r\n         * the details of each video\r\n         * @deprecated This method can cause timeouts if iterating through a very\r\n         *             large number of results, as the search scroll cursor has a\r\n         *             timeout of ~5 minutes. Consider getting all search results\r\n         *             first, then getting details\r\n         * @param query\r\n         * @param options\r\n         */\r\n        searchDetailed(\r\n            query: Video.SearchOptions = { },\r\n            options: Rev.SearchOptions<VideoSearchDetailedItem> = { }\r\n        ): Rev.ISearchRequest<VideoSearchDetailedItem> {\r\n            const searchDefinition = {\r\n                endpoint: '/api/v2/videos/search',\r\n                totalKey: 'totalVideos',\r\n                hitsKey: 'videos',\r\n                transform: async (videos: Video.SearchHit[]) => {\r\n                    const result: Array<Video.SearchHit & (Video.Details & { error?: Error; })> = [];\r\n                    for (let rawVideo of videos) {\r\n                        const out: Video.SearchHit & (Video.Details & { error?: Error; }) = rawVideo as any;\r\n                        try {\r\n                            const details = await videoAPI.details(rawVideo.id);\r\n                            Object.assign(out, details);\r\n                        } catch (error: any) {\r\n                            out.error = error;\r\n                        }\r\n                        result.push(out);\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n            const request = new SearchRequest<Video.SearchHit>(rev, searchDefinition, query, options);\r\n            return request;\r\n        },\r\n        async playbackInfo(videoId: string): Promise<Video.Playback> {\r\n            const { video } = await rev.get(`/api/v2/videos/${videoId}/playback-url`);\r\n            return video;\r\n        },\r\n        async playbackUrls(videoId: string, {ip, userAgent}: Video.PlaybackUrlsRequest = {}, options?: Rev.RequestOptions): Promise<Video.PlaybackUrlsResponse> {\r\n            const query = ip ? { ip } : undefined;\r\n\r\n            const opts: Rev.RequestOptions = {\r\n                ...options,\r\n                ...userAgent && {\r\n                    headers: mergeHeaders(options?.headers, { 'User-Agent': userAgent })\r\n                },\r\n                responseType: 'json'\r\n            };\r\n\r\n            return rev.get(`/api/v2/videos/${videoId}/playback-urls`, query, opts);\r\n        },\r\n        ...videoDownloadAPI(rev),\r\n        ...videoReportAPI(rev),\r\n        ...videoExternalAccessAPI(rev),\r\n        listDeleted(query: Video.RemovedVideosQuery = {}, options: Rev.SearchOptions<Video.RemovedVideoItem> = {}): Rev.ISearchRequest<Video.RemovedVideoItem> {\r\n            const searchDefinition: Rev.SearchDefinition<Video.RemovedVideoItem> = {\r\n                endpoint: '/api/v2/videos/deleted',\r\n                totalKey: 'totalVideos',\r\n                hitsKey: 'deletedVideos',\r\n                async request(endpoint, query, options) {\r\n                    await rev.session.queueRequest(RateLimitEnum.SearchVideos);\r\n                    return rev.get(endpoint, query, options);\r\n                }\r\n            };\r\n            const request = new SearchRequest<Video.RemovedVideoItem>(rev, searchDefinition, query, options);\r\n            return request;\r\n        },\r\n        /**\r\n         * @deprecated Use edit() API instead\r\n         */\r\n        async trim(videoId: string, removedSegments: Array<{ start: string, end: string }>) {\r\n            await rev.session.queueRequest(RateLimitEnum.UploadVideo);\r\n            return rev.post(`/api/v2/videos/${videoId}/trim`, removedSegments);\r\n        },\r\n        async convertDualStreamToSwitched(videoId: string) {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            return rev.put<void>(`/api/v2/videos/${videoId}/convert-dual-streams-to-switched-stream`);\r\n        },\r\n        async edit(videoId: string, keepRanges: Video.ClipRequest[], options?: Rev.RequestOptions) {\r\n            await rev.session.queueRequest(RateLimitEnum.UploadVideo);\r\n            return rev.post(`/api/v2/videos/${videoId}/edit`, keepRanges, options);\r\n        },\r\n        async patch(videoId: string, operations: Rev.PatchOperation[], options?: Rev.RequestOptions) {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.patch(`/api/v2/videos/${videoId}`, operations, options);\r\n        },\r\n        async generateMetadata(videoId: string, fields: Video.MetadataGenerationField[] = [\"all\"], options?: Rev.RequestOptions) {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.put(`/api/v2/videos/${videoId}/generate-metadata`, { metadataGenerationFields: fields }, options);\r\n        },\r\n        async generateMetadataStatus(videoId: string, options?: Rev.RequestOptions): Promise<Video.MetadataGenerationStatus> {\r\n            const {description} = await rev.get(`/api/v2/videos/${videoId}/metadata-generation-status`, undefined, {...options, responseType: 'json'});\r\n            return description.status;\r\n        },\r\n        async transcribe(videoId: string, language: Transcription.SupportedLanguage | Transcription.Request, options?: Rev.RequestOptions): Promise<Transcription.Status> {\r\n            const payload = typeof language === 'string' ? { language } : language;\r\n            return rev.post(`/api/v2/videos/${videoId}/transcription`, payload, {...options, responseType: 'json'})\r\n        },\r\n        async transcriptionStatus(videoId: string, transcriptionId: string, options?: Rev.RequestOptions): Promise<Transcription.Status> {\r\n            return rev.get(`/api/v2/videos/${videoId}/transcriptions/${transcriptionId}/status`, undefined, {...options, responseType: 'json'});\r\n        },\r\n        async translate(videoId: string, source: Transcription.TranslateSource, target: Transcription.SupportedLanguage | Transcription.SupportedLanguage[], options?: Rev.RequestOptions): Promise<Transcription.TranslateResult> {\r\n            const payload = {\r\n                sourceLanguage: source,\r\n                targetLanguages: typeof target === 'string' ? [target] : target\r\n            };\r\n            return rev.post(`/api/v2/videos/${videoId}/translations`, payload, {...options, responseType: 'json'});\r\n        },\r\n        async getTranslationStatus(videoId: string, language: Transcription.SupportedLanguage, options?: Rev.RequestOptions): Promise<Transcription.StatusEnum> {\r\n            const {status} = await rev.get(`/api/v2/videos/${videoId}/translations/${language}/status`, undefined, {...options, responseType: 'json'});\r\n            return status;\r\n        },\r\n        /**\r\n         * Deletes all (or specified) transcriptions that have been uploaded for a given video.\r\n         * @param videoId\r\n         * @param language single or list of locales, as returned from the `rev.video.transcriptions` endpoint\r\n         * @param options\r\n         */\r\n        async deleteTranscription(videoId: string, language?: Transcription.SupportedLanguage | Transcription.SupportedLanguage[], options?: Rev.RequestOptions): Promise<void> {\r\n            const locale = Array.isArray(language) ? language.map(s => s.trim()).join(',') : language;\r\n            await rev.delete(`/api/v2/videos/${videoId}/transcription-files`, locale ? {locale} : undefined, options);\r\n        },\r\n        /**\r\n         * Deletes all (or specified) supplemental files that have been uploaded for a given video.\r\n         * @param videoId\r\n         * @param fileId single or list of fileIds, as returned from the `rev.video.supplementalFiles` endpoint\r\n         */\r\n        async deleteSupplementalFiles(videoId: string, fileId: string | string[], options?: Rev.RequestOptions): Promise<void> {\r\n            const fileIds = Array.isArray(fileId)\r\n                ? fileId.join(',')\r\n                : fileId\r\n            await rev.delete(`/api/v2/videos/${videoId}/supplemental-files`, { fileIds }, options);\r\n        },\r\n        /**\r\n         * Deletes all (or specified) video chapters that have been uploaded for a given video.\r\n         * @param videoId\r\n         * @param startTime single or list of chapter start times, as returned from the `rev.video.chapters` endpoint\r\n         */\r\n        async deleteChapters(videoId: string, startTime: string | string[], options?: Rev.RequestOptions): Promise<void> {\r\n            startTime = Array.isArray(startTime)\r\n                ? startTime.join(',')\r\n                : startTime\r\n            await rev.delete(`/api/v2/videos/${videoId}/chapters`, { startTime }, options);\r\n        },\r\n        /**\r\n         * Deletes all (or specified) video comments for a given video.\r\n         * @param videoId\r\n         * @param commentIds single or list of comment ids, as returned from the `rev.video.comments` endpoint *(`id` parameter for each comment)*\r\n         */\r\n        async deleteComments(videoId: string, commentIds: string | string[], options?: Rev.RequestOptions): Promise<void> {\r\n            commentIds = Array.isArray(commentIds)\r\n                ? commentIds.join(',')\r\n                : commentIds\r\n            await rev.delete(`/api/v2/videos/${videoId}/comments`, { commentIds }, options);\r\n        },\r\n        /**\r\n         * Helper - update the audio language for a video. If index isn't specified then update the default language\r\n         * @param video - videoId or video details (from video.details api call)\r\n         * @param language - language to use, for example 'en'\r\n         * @param trackIndex - index of audio track - if not supplied then update default or first index\r\n         * @param options\r\n         * @deprecated - use `video.patchAudioTracks(video, [{ op: 'replace', track: 0, value: { languageId: 'en', isDefault: true } }])`\r\n         */\r\n        async setAudioLanguage(video: string | Video.Details, language: Transcription.SupportedLanguage, trackIndex?: number, options?: Rev.RequestOptions): Promise<void> {\r\n            const {id, audioTracks = []} = typeof video === 'string' ? { id: video } : video;\r\n            let index = trackIndex ?? audioTracks.findIndex(t => t.isDefault === true) ?? 0;\r\n            const op: Rev.PatchOperation = {\r\n                op: 'replace',\r\n                path: `/audioTracks/${index}`,\r\n                value: { track: index, languageId: language }\r\n            };\r\n            await videoAPI.patch(id, [op], options);\r\n        },\r\n        /**\r\n         * Helper - updating audioTracks or generating new ones requires some specific formatting and making sure that the track indexes are correct. This wraps up the logic of converting tasks into the correct PATCH operations\r\n         * NOTE: Adding audio tracks will use RevIQ credits to generate the new audio.\r\n         * @param video videoId or Video Details object. If videoId is passed then the Get Video Details API will automatically be called to get the latest audioTrack data\r\n         * @param operations List of updates to audio tracks.\r\n         * @param options\r\n         * @returns {Promise<void>}\r\n         * @example\r\n         * ```js\r\n         * const rev = new RevClient(...config...);\r\n         * await rev.connect();\r\n         * const videoId = '<guid>'\r\n         *\r\n         * // helper generator function - used to call status apis until a timeout\r\n         * async function * pollEvery(intervalSeconds = 15, maxSeconds = 900) {\r\n         *     for (let attempt = 0, maxAttempts = maxSeconds / intervalSeconds; attempt < maxAttempts; attempt += 1) {\r\n         *         await new Promise(done => setTimeout(done, intervalSeconds * 1000));\r\n         *         yield attempt;\r\n         *     }\r\n         * }\r\n         *\r\n         * // helper function to generate translation/transcription of a video\r\n         * // NOTE: Uses Rev IQ Credits\r\n         * async function transcribeOrTranslate(videoId, languageId, sourceLanguageId) {\r\n         *     // call translate or transcribe based on if 3rd arg is passed\r\n         *     const response = sourceLanguageId\r\n         *         ? await rev.video.translate(videoId, sourceLanguageId, languageId)\r\n         *         : await rev.video.transcribe(videoId, languageId);\r\n         *\r\n         *     // get the id and status depending on if translate or transcribe\r\n         *     let {transcriptionId, status} = sourceLanguageId\r\n         *         ? response.translations[0]\r\n         *         : response;\r\n         *\r\n         *     for await (let attempt of pollEvery(5)) {\r\n         *         status = (await rev.video.transcriptionStatus(videoId, transcriptionId)).status;\r\n         *         if (['Success', 'Failed'].includes(status)) {\r\n         *             break;\r\n         *         } else {\r\n         *             console.log(`Waiting for transcription to ${languageId} (${attempt}) - ${status}`);\r\n         *         }\r\n         *     }\r\n         *     if (status === 'Success') {\r\n         *         console.log('Transcription complete');\r\n         *     } else {\r\n         *         throw new Error(`Transcription incomplete (${status})`);\r\n         *     }\r\n         * }\r\n         *\r\n         * // get details of video\r\n         * let details = await rev.video.details(videoId);\r\n         * console.log('Initial audio tracks:', details.audioTracks);\r\n         *\r\n         * // set language of first audio track to English (Great Britain) and as the default (if no language set)\r\n         * if (details.audioTracks[0].languageId === 'und') {\r\n         *     console.warn('Setting language of default audio track');\r\n         *     await rev.video.patchAudioTracks(details, [{ op: 'replace', track: 0, value: { languageId: 'en-gb', isDefault: true } }]);\r\n         * }\r\n         *\r\n         * // make sure there's a transcription on the video. If not then add one\r\n         * let transcriptions = await rev.video.transcriptions(videoId);\r\n         * if (transcriptions.length === 0) {\r\n         *   console.warn('A transcription is required for generating audio. Submitting job for transcription now');\r\n         *   await transcribeOrTranslate(videoId, 'en-gb');\r\n         *   transcriptions = await rev.video.transcriptions(videoId);\r\n         * }\r\n         *\r\n         * // check if existing spanish translation\r\n         * if (!transcriptions.some(t => t.locale === 'es')) {\r\n         *     console.warn('A translation to target language is required for generating audio. Submitting job for translation now');\r\n         *     await transcribeOrTranslate(videoId, 'es', transcriptions[0].locale);\r\n         * }\r\n         *\r\n         * // start generating a spanish version of the audio\r\n         * console.log('Generating Spanish audio track');\r\n         * await rev.video.patchAudioTracks(details, [{ op: 'add', value: { languageId: 'es' }}]);\r\n         *\r\n         * // wait for audio generation to complete\r\n         * for await (let attempt of pollEvery(15)) {\r\n         *     details = await rev.video.details(videoId);\r\n         *     const audioTrack = details.audioTracks.find(t => t.languageId === 'es');\r\n         *     const isFinalState = ['Ready', 'AddingFailed'].includes(audioTrack?.status);\r\n         *     if (isFinalState) {\r\n         *         console.log('audio processing completed', audioTrack);\r\n         *         break;\r\n         *     } else {\r\n         *         console.log(`Waiting for audio generation to complete (${attempt}) - ${audioTrack?.status}`);\r\n         *     }\r\n         * }\r\n         *\r\n         * console.log('Final audio tracks:', details.audioTracks);\r\n         *\r\n         * // Finally, if you want to delete the spanish version:\r\n         * // WARNING: This is destructive and will remove the audio track\r\n         * //await rev.video.patchAudioTracks(details, [{ op: 'remove', languageId: 'es' }]);\r\n         *\r\n         *\r\n         * ```\r\n         *\r\n         */\r\n        async patchAudioTracks(video: string | Pick<Video.Details, 'id' | 'audioTracks'>, operations: Video.AudioTrack.PatchRequest[], options?: Rev.RequestOptions) {\r\n            const {id, audioTracks} = typeof video === 'string'\r\n                ? await rev.video.details(video)\r\n                : video;\r\n\r\n            // convert audioTracks to Map and remove languageName\r\n            const request: Map<number, Video.AudioTrack.Request> = new Map(audioTracks.map(({ languageName, ...t }) => [t.track, t]));\r\n\r\n            for (let { op, languageId, track, value } of operations) {\r\n                if (op === 'add') {\r\n                    languageId ??= value?.languageId;\r\n                    if (!languageId) throw new TypeError('value languageId is required when adding audioTrack');\r\n                    const audioTrack: Video.AudioTrack.Request = {\r\n                        isDefault: value?.isDefault ?? false,\r\n                        languageId,\r\n                        track: request.size,\r\n                        status: 'Adding'\r\n                    };\r\n                    request.set(audioTrack.track, audioTrack);\r\n                    continue;\r\n                }\r\n\r\n                let existing = track != undefined && request.has(track)\r\n                    ? request.get(track)\r\n                    : [...request.values()].find(t => t.languageId === languageId);\r\n\r\n                if (!existing && audioTracks.length === 1) {\r\n                    existing = request.get(audioTracks[0].track);\r\n                }\r\n                if (!existing) {\r\n                    throw new Error(`Attempt to ${op} audioTrack language ${languageId} ${track}, but no matching track found`);\r\n                }\r\n                // update existing entry in list\r\n                Object.assign(existing, {\r\n                    ...value,\r\n                    status: op === 'remove' ? 'Deleting' : 'Updating'\r\n                });\r\n            }\r\n\r\n            const payload: Rev.PatchOperation = {\r\n                op: 'replace',\r\n                path: '/audioTracks',\r\n                value: [...request.values()]\r\n            };\r\n\r\n            return videoAPI.patch(id, [payload], options);\r\n        },\r\n        /**\r\n         * Helper - wait for video transcode to complete.\r\n         * This doesn't indicate that a video is playable, rather that all transcoding jobs are complete\r\n         * @param videoId\r\n         * @param options\r\n         */\r\n        async waitTranscode(videoId: string, options: Video.WaitTranscodeOptions = {}, requestOptions?: Rev.RequestOptions): Promise<Video.StatusResponse> {\r\n            const {\r\n                pollIntervalSeconds = 30,\r\n                timeoutMinutes = 240,\r\n                signal,\r\n                ignorePlaybackWhileTranscoding = true,\r\n                onProgress,\r\n                onError = (error: Error) => { throw error; }\r\n            } = options;\r\n\r\n            const ONE_MINUTE = 1000 * 60;\r\n            const timeoutDate = (Date.now() + (timeoutMinutes * ONE_MINUTE) || Infinity);\r\n            // sanity check: ensure at least 5 seconds between calls\r\n            const pollInterval = Math.max((pollIntervalSeconds || 30) * 1000, 5000);\r\n            // set as failed initially in case no error thrown but times out\r\n            let statusResponse = {status: 'UploadFailed'} as Video.StatusResponse;\r\n            while (Date.now() < timeoutDate && !signal?.aborted) {\r\n                // call video status API\r\n                try {\r\n                    statusResponse = await videoAPI.status(videoId, options);\r\n                    let {\r\n                        isProcessing,\r\n                        overallProgress = 0,\r\n                        status\r\n                    } = statusResponse;\r\n\r\n                    // status may be Ready initially even though about to go to Processing state\r\n                    if (ignorePlaybackWhileTranscoding && status === 'Ready' && isProcessing) {\r\n                        status = 'Processing';\r\n                    }\r\n\r\n                    // force failed processing as finished\r\n                    if (status === 'ProcessingFailed') {\r\n                        overallProgress = 1;\r\n                        isProcessing = false;\r\n                    }\r\n                    // override API values as per above\r\n                    Object.assign(statusResponse, { status, overallProgress, isProcessing });\r\n\r\n                    onProgress?.(statusResponse);\r\n\r\n                    // isProcessing is initially false, so wait till overallProgress changes to complete\r\n                    if (overallProgress === 1 && !isProcessing) {\r\n                        // finished, break out of loop\r\n                        break;\r\n                    }\r\n                } catch (error) {\r\n                    // by default will throw error\r\n                    await Promise.resolve(onError(error as Error));\r\n                }\r\n\r\n                await sleep(pollInterval, signal);\r\n            }\r\n            return statusResponse;\r\n        }\r\n    };\r\n    return videoAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport { RevError } from '../rev-error';\r\nimport type { Rev } from '../types/index';\r\nimport type { Webcast } from '../types/webcast';\r\nimport { RateLimitEnum } from '../utils';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\nfunction getSummaryFromResponse<T extends Record<string, any>>(response: T, hitsKey: string) {\r\n    const ignoreKeys = ['scrollId', 'statusCode', 'statusDescription'];\r\n\r\n    const summary = Object.fromEntries(Object.entries(response)\r\n        .filter(([key, value]) => {\r\n            // don't include arrays or scroll type keys\r\n            return !(key === hitsKey || ignoreKeys.includes(key) || Array.isArray(value));\r\n        }));\r\n    return summary;\r\n}\r\n\r\n/** @category Webcasts */\r\nexport class RealtimeReportRequest<T extends Webcast.RealtimeSession = Webcast.RealtimeSession> extends SearchRequest<T> {\r\n    /**\r\n     * The overall summary statistics returned with the first page of results\r\n     */\r\n    declare summary: Webcast.RealtimeSummary;\r\n    /**\r\n     * @hidden\r\n     * @param rev\r\n     * @param eventId\r\n     * @param query\r\n     * @param options\r\n     */\r\n    constructor(rev: RevClient, eventId: string, query: Webcast.RealtimeRequest = {}, options: Rev.SearchOptions<T> = {}) {\r\n        const searchDefinition: Rev.SearchDefinition<T> = {\r\n            endpoint: `/api/v2/scheduled-events/${eventId}/real-time/attendees`,\r\n            totalKey: 'total',\r\n            hitsKey: 'attendees',\r\n            // get summary from initial response\r\n            request: async (endpoint, query, options) => {\r\n                await rev.session.queueRequest(RateLimitEnum.GetWebcastAttendeesRealtime);\r\n                const response = await rev.post<Webcast.RealtimeSummary>(endpoint, query, options);\r\n\r\n                const summary = getSummaryFromResponse(response, 'attendees');\r\n                Object.assign(this.summary, summary);\r\n                return response;\r\n            }\r\n        };\r\n        super(rev, searchDefinition, query, options);\r\n        this.summary = {} as any;\r\n    }\r\n    /**\r\n     * get the aggregate statistics only, instead of actual session data.\r\n     * @returns {Webcast.PostEventSummary}\r\n     */\r\n    async getSummary() {\r\n        // set maxResults to 0 to mark request as done, since first page of sessions will be lost\r\n        this.options.maxResults = 0;\r\n        // must get first page of results to load summary data\r\n        await this.nextPage();\r\n        return this.summary;\r\n    }\r\n}\r\n\r\n/** @category Webcasts */\r\nexport class PostEventReportRequest extends SearchRequest<Webcast.PostEventSession> {\r\n    declare summary: Webcast.PostEventSummary;\r\n    /**\r\n     * @hidden\r\n     * @param rev\r\n     * @param query\r\n     * @param options\r\n     */\r\n    constructor(rev: RevClient, query: { eventId: string, runNumber?: number }, options: Rev.SearchOptions<Webcast.PostEventSession> = {}) {\r\n        const { eventId, runNumber } = query;\r\n        const runQuery = (runNumber && runNumber >= 0)\r\n            ? { runNumber }\r\n            : {};\r\n\r\n        const searchDefinition: Rev.SearchDefinition<Webcast.PostEventSession> = {\r\n            endpoint: `/api/v2/scheduled-events/${eventId}/post-event-report`,\r\n                totalKey: 'totalSessions',\r\n                hitsKey: 'sessions',\r\n                request: async (endpoint, query, options) => {\r\n                    // this endpoint has a particular error response that isn't automatically captured\r\n                    // by the RevError parser, so need to manually check\r\n                    const response = await rev.request<Webcast.PostEventSummary>('GET', endpoint, query, {\r\n                        ...options,\r\n                        responseType: 'json',\r\n                        throwHttpErrors: false\r\n                    });\r\n\r\n                    // will throw on error response\r\n                    await this._assertResponseOk(response);\r\n\r\n                    // get summary removes scrollId and other internal data\r\n                    Object.assign(this.summary, getSummaryFromResponse(response.body, 'sessions'));\r\n                    return response.body;\r\n                }\r\n        };\r\n        super(rev, searchDefinition,  runQuery, options);\r\n        this.summary = {};\r\n    }\r\n    private async _assertResponseOk({response, statusCode, body}: Rev.Response<Webcast.PostEventSummary>): Promise<Webcast.PostEventSummary> {\r\n        if (response.ok) {\r\n            return body;\r\n        }\r\n\r\n        if (statusCode == 400 && (body as PostEventErrorResponse)?.errorDescription) {\r\n            throw new RevError(response, { details: (body as PostEventErrorResponse).errorDescription });\r\n        }\r\n        // bodyUsed should always be true, but this is just a safety check\r\n        const error = (!!body || response.bodyUsed)\r\n            ? new RevError(response, body as string)\r\n            : await RevError.create(response);\r\n        throw error;\r\n    }\r\n    /**\r\n     * get the aggregate statistics only, instead of actual session data.\r\n     * @returns {Webcast.PostEventSummary}\r\n     */\r\n    async getSummary() {\r\n        // set maxResults to 0 to mark request as done, since first page of sessions will be lost\r\n        this.options.maxResults = 0;\r\n        // must get first page of results to load summary data\r\n        await this.nextPage();\r\n        return this.summary;\r\n    }\r\n}\r\n\r\n\r\ninterface PostEventErrorResponse {\r\n    errorDescription: string;\r\n    sessions: [],\r\n    totalSessions: 0\r\n}\r\n\r\n/**\r\n * The Post Event Report returns a special JSON body on 400 error, unlike other endpoints\r\n */\r\nasync function parseAttendeesError(revResponse: Rev.Response<unknown>) {\r\n\r\n}\r\n","import type { Rev } from '../index';\r\nimport type { RevClient } from '../rev-client';\r\nimport type { GuestRegistration, Webcast, WebcastBanner } from '../types/webcast';\r\nimport { titleCase } from '../utils/index';\r\nimport { mergeHeaders } from '../utils/merge-headers';\r\nimport { SearchRequest } from '../utils/request-utils';\r\nimport { PostEventReportRequest, RealtimeReportRequest } from './webcast-report-request';\r\n\r\n/**\r\n * @category Webcasts\r\n */\r\ntype RealtimeSession<T extends Webcast.RealtimeRequest | undefined> = T extends { attendeeDetails: 'All' }\r\n    ? Webcast.RealtimeSessionDetail\r\n    : T extends { attendeeDetails: 'Counts' }\r\n    ? never\r\n    : Webcast.RealtimeSession;\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof webcastAPIFactory>;\r\n/**\r\n * Webcast API methods\r\n * @category Webcasts\r\n * @group API\r\n * @see [Webcast API Docs](https://revdocs.vbrick.com/reference/createevent)\r\n */\r\nexport interface WebcastAPI extends API {};\r\n\r\n/** @ignore */\r\nexport default function webcastAPIFactory(rev: RevClient) {\r\n    const webcastAPI = {\r\n        async list(options: Webcast.ListRequest = { }, requestOptions?: Rev.RequestOptions): Promise<Webcast.ListItem[]> {\r\n            return rev.get('/api/v2/scheduled-events', options, { ...requestOptions, responseType: 'json' });\r\n        },\r\n        search(query: Webcast.SearchRequest, options?: Rev.SearchOptions<Webcast>): Rev.ISearchRequest<Webcast> {\r\n            const searchDefinition: Rev.SearchDefinition<Webcast> = {\r\n                endpoint: `/api/v2/search/scheduled-events`,\r\n                totalKey: 'total',\r\n                hitsKey: 'events',\r\n                request: (endpoint, query, options) => rev.post(endpoint, query, options),\r\n                isPost: true\r\n            };\r\n            return new SearchRequest<Webcast>(rev, searchDefinition, query, options);\r\n        },\r\n        async create(event: Webcast.CreateRequest): Promise<string> {\r\n            const { eventId } = await rev.post(`/api/v2/scheduled-events`, event);\r\n            return eventId;\r\n        },\r\n        async details(eventId: string, requestOptions?: Rev.RequestOptions): Promise<Webcast.Details> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}`, undefined, requestOptions);\r\n        },\r\n        async edit(eventId: string, event: Webcast.CreateRequest): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}`, event);\r\n        },\r\n        /**\r\n         * Partially edits the details of a webcast. You do not need to provide the fields that you are not changing.\r\n         * Webcast status determines which fields are modifiable and when.\r\n         *\r\n         * If the webcast pre-production or main event is in progress, only fields available for inline editing may be patched/edited.\r\n         *\r\n         * If the webcast main event has been run once, only fields available after the webcast has ended are available for editing. That includes all fields with the exception of start/end dates, lobbyTimeMinutes, preProduction, duration, userIds, and groupIds.\r\n         *\r\n         * If the webcast end time has passed and is Completed, only edits to linkedVideoId and redirectVod are allowed.\r\n         *\r\n         * Event Admins can be removed using their email addresses as path pointer for the fields 'EventAdminEmails' and 'EventAdmins', provided that all of the Event Admins associated with the webcast have email addresses. This is also applicable for the field 'Moderators'.\r\n         * @example\r\n         * ```js\r\n         * const rev = new RevClient(...config...);\r\n         * await rev.connect();\r\n         *\r\n         * // using eventadmins\r\n         * await rev.webcast.patch(eventId, [{ 'op': 'remove', 'path': '/EventAdmins/Email', 'value': 'x1@test.com' }]);\r\n         * // change shortcut\r\n         * await rev.webcast.patch(eventId, [{ 'op': 'replace', 'path': '/ShortcutName', 'value': 'weekly-meeting' }]);\r\n         * ```\r\n         */\r\n        async patch(eventId: string, operations: Rev.PatchOperation[], options?: Rev.RequestOptions) {\r\n            await rev.patch(`/api/v2/scheduled-events/${eventId}`, operations, options);\r\n        },\r\n        // async patch - not yet implemented\r\n        async delete(eventId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}`);\r\n        },\r\n        async editAccess(eventId: string, entities: Webcast.EditAttendeesRequest): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/access-control`, entities);\r\n        },\r\n        attendees(\r\n            eventId: string,\r\n            runNumber?: number,\r\n            options?: Rev.SearchOptions<Webcast.PostEventSession>\r\n        ) {\r\n            return new PostEventReportRequest(rev, { eventId, runNumber }, options);\r\n        },\r\n        realtimeAttendees<T extends Webcast.RealtimeRequest | undefined>(\r\n            eventId: string,\r\n            query?: T,\r\n            options?: Rev.SearchOptions<RealtimeSession<T>>\r\n        ) {\r\n            return new RealtimeReportRequest<RealtimeSession<T>>(rev, eventId, query, options);\r\n        },\r\n        async questions(eventId: string, runNumber?: number): Promise<Webcast.Question[]> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/questions`, query, { responseType: 'json' });\r\n        },\r\n        async pollResults(eventId: string, runNumber?: number): Promise<Webcast.PollResults[]> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            // const {polls} = await rev.get(`/api/v2/scheduled-events/${eventId}/poll-results`, query, { responseType: 'json' });\r\n            // workaround for event that never happened returning blank response\r\n            const rawResponse = await rev.get(`/api/v2/scheduled-events/${eventId}/poll-results`, query, { responseType: 'text' });\r\n            const {polls = []} = rawResponse ? JSON.parse(rawResponse) : {};\r\n            return polls;\r\n        },\r\n        async comments(eventId: string, runNumber?: number): Promise<Webcast.Comment[]> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/comments`, query, { responseType: 'json' });\r\n        },\r\n        async reactions(eventId: string): Promise<Webcast.ReactionsSummary[]> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/reactions`, undefined, { responseType: 'json' });\r\n        },\r\n        async status(eventId: string, requestOptions?: Rev.RequestOptions): Promise<Webcast.Status> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/status`, undefined, requestOptions);\r\n        },\r\n        async isPublic(eventId: string, requestOptions?: Rev.RequestOptions): Promise<boolean> {\r\n            const response = await rev.request('GET', `/api/v2/scheduled-events/${eventId}/is-public`, undefined, { ...requestOptions, throwHttpErrors: false, responseType: 'json' });\r\n            return response.statusCode !== 401 && response.body?.isPublic;\r\n        },\r\n        /**\r\n         * This endpoint deletes all events for a given date range or custom field query. The response returns a jobId and a count of webcasts to be deleted. The jobId can be used to check the status of the deletion.\r\n         * @param query Fields that are going to be used to search Webcasts that are to be deleted.\r\n         * @param options\r\n         */\r\n        async bulkDelete(query: Pick<Webcast.SearchRequest, 'startDate' | 'endDate' | 'customFields'>, options?: Rev.RequestOptions): Promise<Webcast.BulkDelete.Response> {\r\n            // using rev.request because rev.delete assumes no response from endpoint\r\n            const {body} = await rev.request('DELETE', `/api/v2/scheduled-events`, query, options);\r\n            return body;\r\n        },\r\n        bulkDeleteStatus(jobId: string): Promise<Webcast.BulkDelete.Status> {\r\n            return rev.get(`/api/v2/scheduled-events/delete-status/${jobId}`);\r\n        },\r\n        async playbackUrls(eventId: string, {ip, userAgent}: Webcast.PlaybackUrlRequest = { }, options?: Rev.RequestOptions): Promise<Webcast.PlaybackUrlsResponse> {\r\n            const query = ip ? { ip } : undefined;\r\n\r\n            const opts: Rev.RequestOptions = {\r\n                ...options,\r\n                ...userAgent && {\r\n                    headers: mergeHeaders(options?.headers, { 'User-Agent': userAgent })\r\n                },\r\n                responseType: 'json'\r\n            };\r\n\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/playback-url`, query, opts);\r\n        },\r\n        /**\r\n         * @deprecated\r\n         * @param eventId\r\n         * @param options\r\n         * @returns\r\n         */\r\n        async playbackUrl(eventId: string, options: Webcast.PlaybackUrlRequest = { }): Promise<Webcast.Playback[]> {\r\n            rev.log('debug', 'webcast.playbackUrl is deprecated - use webcast.playbackUrls instead');\r\n            const {playbackResults} = await webcastAPI.playbackUrls(eventId, options);\r\n            return playbackResults;\r\n        },\r\n        async startEvent(eventId: string, preProduction: boolean = false): Promise<void> {\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/start`, { preProduction });\r\n        },\r\n        async stopEvent(eventId: string, preProduction: boolean = false): Promise<void> {\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/start`, { preProduction });\r\n        },\r\n        async startBroadcast(eventId: string): Promise<void> {\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/broadcast`);\r\n        },\r\n        async stopBroadcast(eventId: string): Promise<void> {\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/broadcast`);\r\n        },\r\n        async startRecord(eventId: string): Promise<void> {\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/record`);\r\n        },\r\n        async stopRecord(eventId: string): Promise<void> {\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/record`);\r\n        },\r\n        async linkVideo(eventId: string, videoId: string, autoRedirect: boolean = true) {\r\n            const payload = {\r\n                videoId,\r\n                redirectVod: autoRedirect\r\n            };\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/linked-video`, payload);\r\n        },\r\n        async unlinkVideo(eventId: string) {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/linked-video`);\r\n        },\r\n        /**\r\n         * Retrieve details of a specific guest user Public webcast registration.\r\n         * @param eventId - Id of the Public webcast\r\n         * @param registrationId - Id of guest user's registration to retrieve\r\n         * @returns\r\n         */\r\n        async guestRegistration(eventId: string, registrationId: string): Promise<GuestRegistration.Details> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`);\r\n        },\r\n        /**\r\n         * Mute attendee for a specified webcast\r\n         */\r\n        async muteAttendee(eventId: string, userId: string, runNumber?: number): Promise<void> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/users/${userId}/mute`, query);\r\n        },\r\n        /**\r\n         * Unmute attendee for a specified webcast\r\n         */\r\n        async unmuteAttendee(eventId: string, userId: string, runNumber?: number): Promise<void> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/users/${userId}/mute`, query);\r\n        },\r\n        /**\r\n         * Hide specific comment for a specified webcast\r\n         */\r\n        async hideComment(eventId: string, commentId: string, runNumber?: number): Promise<void> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/comments/${commentId}/hide`, query);\r\n        },\r\n        /**\r\n         * Unhide specific comment for a specified webcast\r\n         */\r\n        async unhideComment(eventId: string, commentId: string, runNumber?: number): Promise<void> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/comments/${commentId}/hide`, query);\r\n        },\r\n        /**\r\n         * Register one attendee/guest user for an upcoming Public webcast. Make sure you first enable Public webcast pre-registration before adding registrations.\r\n         * @param eventId\r\n         * @param registration\r\n         * @returns\r\n         */\r\n        async createGuestRegistration(eventId: string, registration: GuestRegistration.Request): Promise<GuestRegistration.Details> {\r\n            return rev.post(`/api/v2/scheduled-events/${eventId}/registrations`, registration);\r\n        },\r\n        listGuestRegistrations(\r\n            eventId: string,\r\n            query: GuestRegistration.SearchRequest = {},\r\n            options?: Rev.SearchOptions<GuestRegistration>\r\n        ): Rev.ISearchRequest<GuestRegistration> {\r\n            const searchDefinition: Rev.SearchDefinition<GuestRegistration> = {\r\n                endpoint: `/api/v2/scheduled-events/${eventId}/registrations`,\r\n                /** NOTE: this API doesn't actually return a total, so this will always be undefined */\r\n                totalKey: 'total',\r\n                hitsKey: 'guestUsers'\r\n            };\r\n            return new SearchRequest<GuestRegistration>(rev, searchDefinition, query, options);\r\n        },\r\n        updateGuestRegistration(eventId: string, registrationId: string, registration: GuestRegistration.Request): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`, registration);\r\n        },\r\n        patchGuestRegistration(eventId: string, registrationId: string, registration: Partial<GuestRegistration.Request>): Promise<void> {\r\n            const operations = Object.entries(registration)\r\n                .map(([key, value]) => {\r\n                    let path = `/${titleCase(key)}`;\r\n                    return { op: 'replace', path, value };\r\n                });\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`, operations);\r\n        },\r\n        deleteGuestRegistration(eventId: string, registrationId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`);\r\n        },\r\n        /**\r\n         * Resend email to external presenters for Producer type webcast.\r\n         * @param eventId id of the webcast\r\n         * @param email Email of the external presenter.\r\n         */\r\n        resendEmailToExternalPresenter(eventId: string, email: string): Promise<void> {\r\n            return rev.post(`/api/v2/scheduled-events/${eventId}/presenter-resend-email?email=${encodeURIComponent(email)}`);\r\n        },\r\n        async listEmbeddedEngagements(eventId: string): Promise<Webcast.ContentLink[]> {\r\n            const {contentLinks} = await rev.get(`/api/v2/scheduled-events/${eventId}/embedded-content/links`);\r\n            return contentLinks || [];\r\n        },\r\n        addEmbeddedEngagement(eventId: string, contentLink: Webcast.ContentLink.Request): Promise<Webcast.ContentLink> {\r\n            return rev.post(`/api/v2/scheduled-events/${eventId}/embedded-content/link`, contentLink);\r\n        },\r\n        setEmbeddedEngagementStatus(eventId: string, linkId: string, isEnabled: boolean): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/embedded-content/links/${linkId}/status`, {isEnabled});\r\n        },\r\n        updateEmbeddedEngagement(eventId: string, contentLink: Webcast.ContentLink): Promise<Webcast.ContentLink> {\r\n            const {id, ...payload} = contentLink;\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/embedded-content/links/${id}`, payload);\r\n        },\r\n        deleteEmbeddedEngagement(eventId: string, linkId: string) {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/embedded-content/links/${linkId}`);\r\n        },\r\n        async listBanners(eventId: string): Promise<WebcastBanner[]> {\r\n            const {banners} = await rev.get(`/api/v2/scheduled-events/${eventId}/banners`);\r\n            return banners || [];\r\n        },\r\n        addBanner(eventId: string, banner: WebcastBanner.Request): Promise<WebcastBanner> {\r\n            return rev.post(`/api/v2/scheduled-events/${eventId}/banner`, banner);\r\n        },\r\n        setBannerStatus(eventId: string, bannerId: string, isEnabled: boolean): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/banner/${bannerId}/status`, {isEnabled});\r\n        },\r\n        updateBanner(eventId: string, banner: WebcastBanner): Promise<WebcastBanner> {\r\n            // separate id from the banner data\r\n            const {id, ...payload} = banner;\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/banner/${id}`, payload);\r\n        },\r\n        deleteBanner(eventId: string, bannerId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/banner/${bannerId}`);\r\n        },\r\n        get uploadBranding() {\r\n            return rev.upload.webcastBranding;\r\n        },\r\n        get uploadPresentation() {\r\n            return rev.upload.webcastPresentation;\r\n        },\r\n        get uploadBackgroundImage() {\r\n            return rev.upload.webcastBackground;\r\n        },\r\n        deleteBackgroundImage(eventId: string) {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/background-image`);\r\n        },\r\n        get uploadProducerLayoutBackground() {\r\n            return rev.upload.webcastProducerLayoutBackground;\r\n        },\r\n        deleteProducerLayoutBackground(eventId: string) {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/webcast-producer-bgimage`);\r\n        }\r\n    };\r\n\r\n    return webcastAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Zone } from '../types/zone';\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport type API = ReturnType<typeof zonesAPIFactory>;\r\n\r\n/**\r\n * Zone-related API methods\r\n * @category Administration\r\n * @group API\r\n * @see [Zones API Docs](https://revdocs.vbrick.com/reference/getzones)\r\n */\r\nexport interface ZoneAPI extends API {}\r\n\r\n/** @ignore */\r\nexport default function zonesAPIFactory(rev: RevClient) {\r\n    const zonesAPI = {\r\n        async list(): Promise<{ defaultZone: Zone, zones: Zone[]; }> {\r\n            return rev.get(`/api/v2/zones`, undefined, { responseType: 'json' });\r\n        },\r\n        async flatList(): Promise<Zone.FlatZone[]> {\r\n            const {\r\n                defaultZone,\r\n                zones\r\n            } = await zonesAPI.list();\r\n            const flatZones: Omit<Zone, 'childZones'>[] = [defaultZone];\r\n            function recursiveAdd(inZone: Zone) {\r\n                const {\r\n                    childZones = [],\r\n                    ...zone\r\n                } = inZone;\r\n\r\n                flatZones.push(zone);\r\n                childZones.forEach(recursiveAdd);\r\n            }\r\n            zones.forEach(recursiveAdd);\r\n            return flatZones;\r\n        },\r\n        async create(zone: Zone.CreateRequest): Promise<string> {\r\n            const { zoneId } = await rev.post(`/api/v2/zones`, zone, { responseType: 'json' });\r\n            return zoneId;\r\n        },\r\n        async edit(zoneId: string, zone: Zone.CreateRequest): Promise<void> {\r\n            return rev.put(`/api/v2/zones/${zoneId}`, zone);\r\n        },\r\n        delete(zoneId: string) {\r\n            return rev.delete(`/api/v2/zones/${zoneId}`);\r\n        },\r\n        get devices() {\r\n            return rev.device.listZoneDevices;\r\n        }\r\n    };\r\n    return zonesAPI;\r\n}\r\n","import type { AccountBasicInfo } from '../types/index';\r\nimport type { RevClient } from '../rev-client';\r\n\r\n/** @ignore */\r\nexport type API = ReturnType<typeof environmentAPIFactory>;\r\n/**\r\n * @see [Environment API Docs](https://revdocs.vbrick.com/reference/user-location)\r\n * @category Utilities\r\n * @group API\r\n */\r\nexport interface EnvironmentAPI extends API {};\r\n\r\n/** @ignore */\r\nexport default function environmentAPIFactory(rev: RevClient) {\r\n    let accountId = '';\r\n    let version = '' as AccountBasicInfo['environment']['version'];\r\n    let ulsInfo: undefined | { enabled: boolean, locationUrls: string[] } = undefined;\r\n    let bootstrap: undefined | Promise<AccountBasicInfo> = undefined;\r\n\r\n    async function fallbackGetAccountId(forceRefresh = false): Promise<string> {\r\n        if (!accountId || forceRefresh) {\r\n            const text = await rev.get<string>('/', undefined, { responseType: 'text' }).catch(error => '');\r\n            accountId = (/(['\"])account\\1[:{\\s\\n]*\\1id\\1[\\s\\n:]+\\1([0-9a-f-]{36})\\1/m.exec(text) || [])[2] || '';\r\n        }\r\n        return accountId;\r\n    }\r\n\r\n    async function fallbackGetRevVersion(forceRefresh = false) {\r\n        if (!version || forceRefresh) {\r\n            const text = await rev.get<string>('/js/version.js', undefined, { responseType: 'text' }).catch(error => '');\r\n            version = (/buildNumber['\":\\s\\n]*([\\d.]+)/m.exec(text) || [])[1] || '' as any;\r\n        }\r\n        return version;\r\n    }\r\n\r\n    async function getBootstrapImpl(forceRefresh = false): Promise<AccountBasicInfo> {\r\n        try {\r\n            return await rev.get<AccountBasicInfo>('/api/v2/accounts/bootstrap', undefined, { responseType: 'json' });\r\n        } catch (error) {\r\n            const [id, version] = await Promise.all([\r\n                fallbackGetAccountId(forceRefresh),\r\n                fallbackGetRevVersion(forceRefresh)\r\n            ]);\r\n            return {\r\n                account: { id },\r\n                environment: { version }\r\n            }\r\n        }\r\n    }\r\n\r\n    const environmentAPI = {\r\n        /**\r\n         * Does not require authentication for use\r\n         * get base information about a Rev account. This is a useful call when first initalizing a rev client, in order to ensure connectivity to Rev, as well as for getting the AccountID for use with some APIs\r\n         */\r\n        async bootstrap(forceRefresh = false): Promise<AccountBasicInfo> {\r\n            if (!bootstrap || forceRefresh) {\r\n                bootstrap = getBootstrapImpl(forceRefresh)\r\n                // don't cache errors\r\n                bootstrap.catch((err) => { bootstrap = undefined; });\r\n            }\r\n            return await bootstrap;\r\n        },\r\n        /**\r\n         * Get's the accountId embedded in Rev's main entry point\r\n         * @param forceRefresh ignore cached value if called previously\r\n         * @param useLegacyApi force using regex-based discovery before dedicated API endpoint introduced in Rev 8.0\r\n         */\r\n        async getAccountId(forceRefresh = false, useLegacyApi = false): Promise<string> {\r\n            if (!accountId || forceRefresh) {\r\n                accountId = useLegacyApi\r\n                    ? await fallbackGetAccountId(forceRefresh)\r\n                    : (await getBootstrapImpl(forceRefresh)).account.id;\r\n            }\r\n            return accountId;\r\n        },\r\n        /**\r\n         * Get's the version of Rev returned by /js/version.js\r\n         * @param forceRefresh ignore cached value if called previously\r\n         * @param useLegacyApi force using regex-based discovery before dedicated API endpoint introduced in Rev 8.0\r\n         */\r\n        async getRevVersion(forceRefresh = false, useLegacyApi = false): Promise<string> {\r\n            if (!version || forceRefresh) {\r\n                version = useLegacyApi\r\n                    ? await fallbackGetRevVersion(forceRefresh)\r\n                    : (await getBootstrapImpl(forceRefresh)).environment.version;\r\n            }\r\n            return version;\r\n        },\r\n        /**\r\n         * Use the Get User Location Service API to get a user's IP address for zoning purposes\r\n         * Returns the IP if ULS enabled and one successfully found, otherwise undefined.\r\n         * undefined response indicates Rev should use the user's public IP for zoning.\r\n         * @param timeoutMs    - how many milliseconds to wait for a response (if user is not)\r\n         *                       on VPN / intranet with ULS DME then DNS lookup or request\r\n         *                       can time out, so don't set this too long.\r\n         *                       Default is 10 seconds\r\n         * @param forceRefresh   By default the User Location Services settings is cached\r\n         *                       (not the user's detected IP). Use this to force reloading\r\n         *                       the settings from Rev.\r\n         * @returns\r\n         */\r\n        async getUserLocalIp(timeoutMs = 10 * 1000, forceRefresh = false): Promise<string | undefined> {\r\n            if (!ulsInfo || forceRefresh) {\r\n                ulsInfo = await rev.get('/api/v2/user-location');\r\n            }\r\n            // if User Location Services isn't enabled then return undefined, meaning Rev will just use user's public IP for zoning\r\n            if (!ulsInfo?.enabled || ulsInfo.locationUrls.length === 0) {\r\n                return undefined;\r\n            }\r\n            const controller = new AbortController();\r\n            const getIp = async function (ulsUrl: string) {\r\n                try {\r\n                    let {ip = ''} = await rev.get<{ ip: string }>(ulsUrl, {}, {\r\n                        headers: { Authorization: '' },\r\n                        responseType: 'json',\r\n                        signal: controller.signal\r\n                    });\r\n                    ip = `${ip}`.split(',')[0].trim();\r\n                    if (ip) {\r\n                        // cancel any other requests early\r\n                        controller.abort();\r\n                    }\r\n                    return ip;\r\n                } catch (error) {\r\n                    rev.log('debug', `ULS URL Failed: ${ulsUrl}`, error);\r\n                    return undefined;\r\n                }\r\n            }\r\n\r\n            const timer = setTimeout(() => controller.abort(), timeoutMs);\r\n            try {\r\n                // collect all returned IPs...first response will abort others early\r\n                const ips = await Promise.all(ulsInfo.locationUrls.map(getIp));\r\n                return ips.find(ip => !!ip);\r\n            } finally {\r\n                clearTimeout(timer);\r\n            }\r\n        }\r\n    };\r\n\r\n    return environmentAPI;\r\n}\r\n","import type { RevClient } from './rev-client';\r\nimport type { Rev } from './types';\r\nimport { isPlainObject, sleep } from './utils';\r\nimport interop from './interop/polyfills';\r\nimport { RateLimitEnum, type RateLimitQueues, clearQueues, makeQueues } from './utils/rate-limit-queues';\r\n\r\nconst ONE_MINUTE = 1000 * 60;\r\n// if no expiration default to expiring in 10 minutes\r\nconst DEFAULT_EXPIRE_MINUTES = 10;\r\n\r\n// obsfucate credentials to avoid accidental disclosure\r\nconst _credentials = Symbol('credentials');\r\n\r\ninterface LoginResponse {\r\n    token: string,\r\n    expiration: string,\r\n    userId?: string,\r\n    refreshToken?: string,\r\n    apiKey?: string;\r\n}\r\n\r\nclass SessionKeepAlive {\r\n    private readonly _session!: SessionBase;\r\n    private controller?: AbortController;\r\n    extendOptions: Required<Rev.KeepAliveOptions>;\r\n    error?: undefined | Error;\r\n    private _isExtending: boolean = false;\r\n    constructor(session: SessionBase, options: Rev.KeepAliveOptions = { }) {\r\n        // TODO verify values?\r\n        this.extendOptions = {\r\n            extendThresholdMilliseconds: 3 * ONE_MINUTE,\r\n            keepAliveInterval: 10 * ONE_MINUTE,\r\n            verify: true,\r\n            ...options\r\n        };\r\n\r\n        Object.defineProperties(this, {\r\n            _session: {\r\n                get: () => session,\r\n                enumerable: false\r\n            }\r\n        });\r\n    }\r\n    getNextExtendTime() {\r\n        const { expires } = this._session;\r\n        if (!expires) {\r\n            return 0;\r\n        }\r\n        const {\r\n            keepAliveInterval: interval,\r\n            extendThresholdMilliseconds: threshold\r\n        } = this.extendOptions;\r\n\r\n        // ensure poll isn't repeatedly triggered - 5 seconds min\r\n        const MIN_INTERVAL_MS = 5 * 1000;\r\n\r\n        const timeTillExpiration = expires.getTime() - Date.now();\r\n        // clamp range to within short timespan and max interval\r\n        return Math.max(MIN_INTERVAL_MS, Math.min(timeTillExpiration - threshold, interval));\r\n    }\r\n    private async _poll() {\r\n        const { _session: session } = this;\r\n        // force stop other poll process if already polling\r\n        // keep reference to controller in case of reset\r\n        const controller = this._reset();\r\n        const { signal } = controller;\r\n\r\n        while (session.isConnected && !signal.aborted) {\r\n            const nextExtendTime = this.getNextExtendTime();\r\n            await sleep(nextExtendTime, signal);\r\n\r\n            // check if poll was aborted. if so don't try to extend\r\n            if (signal.aborted) {\r\n                break;\r\n            }\r\n\r\n            // extend session\r\n            // possible this can throw an error\r\n            try {\r\n                // extending may re-login, so pause poll resets for now\r\n                this._isExtending = true;\r\n                await session.lazyExtend(this.extendOptions);\r\n            } catch (err: any) {\r\n                // swallow error, but signal stopped using abort controller\r\n                controller.abort();\r\n                this.error = err;\r\n            } finally {\r\n                this._isExtending = false;\r\n            }\r\n        }\r\n    }\r\n    start() {\r\n        if (this._isExtending) {\r\n            return;\r\n        }\r\n        this._poll();\r\n    }\r\n    stop() {\r\n        if (this._isExtending) {\r\n            return;\r\n        }\r\n        if (this.controller) {\r\n            this.controller.abort();\r\n        }\r\n    }\r\n    private _reset() {\r\n        this.error = undefined;\r\n        this._isExtending = false;\r\n        const oldController = this.controller;\r\n        this.controller = new interop.AbortController();\r\n\r\n        // stop previous poll\r\n        if (oldController) {\r\n            oldController.abort();\r\n        }\r\n        return this.controller;\r\n    }\r\n    get isAlive() {\r\n        return this.controller && !this.controller.signal.aborted;\r\n    }\r\n}\r\n\r\nabstract class SessionBase implements Rev.IRevSession {\r\n    token?: string;\r\n    expires: Date;\r\n    protected readonly rev!: RevClient;\r\n    protected readonly [_credentials]!: Rev.Credentials;\r\n    readonly keepAlive?: SessionKeepAlive;\r\n    readonly _rateLimits?: Partial<RateLimitQueues>;\r\n    constructor(rev: RevClient, credentials: Rev.Credentials, keepAliveOptions?: boolean | Rev.KeepAliveOptions, rateLimits?: boolean | Rev.RateLimits) {\r\n        this.expires = new Date();\r\n\r\n        if (keepAliveOptions === true) {\r\n            this.keepAlive = new SessionKeepAlive(this);\r\n        } else if (isPlainObject(keepAliveOptions)) {\r\n            this.keepAlive = new SessionKeepAlive(this, keepAliveOptions);\r\n        }\r\n\r\n        let rateLimitQueues: undefined | Partial<RateLimitQueues> = undefined;\r\n        if (rateLimits) {\r\n            rateLimitQueues = makeQueues(isPlainObject(rateLimits) ? rateLimits : undefined);\r\n        }\r\n\r\n        // add as private member\r\n        Object.defineProperties(this, {\r\n            rev: {\r\n                get() { return rev; },\r\n                enumerable: false\r\n            },\r\n            [_credentials]: {\r\n                get() { return credentials; },\r\n                enumerable: false\r\n            },\r\n            _rateLimits: {\r\n                get() { return rateLimitQueues; },\r\n                enumerable: false\r\n            }\r\n        });\r\n    }\r\n    async login() {\r\n        this.token = undefined;\r\n        this.expires = new Date();\r\n\r\n        const {\r\n            expiration,\r\n            ...session\r\n        } = await this._login();\r\n\r\n        Object.assign(this, session);\r\n\r\n        const expires = new Date(expiration);\r\n        // if invalid date or date in past returned - just assume 10 min expiration\r\n        if (isNaN(expires.getTime()) || expires.getTime() < this.expires.getTime()) {\r\n            this.expires.setUTCMinutes(this.expires.getUTCMinutes() + DEFAULT_EXPIRE_MINUTES);\r\n        } else {\r\n            this.expires = expires;\r\n        }\r\n\r\n        if (this.keepAlive) {\r\n            this.keepAlive.start();\r\n        }\r\n    }\r\n    async extend() {\r\n        const { expiration } = await this._extend();\r\n        this.expires = new Date(expiration);\r\n    }\r\n    async logoff() {\r\n        if (this.keepAlive) {\r\n            this.keepAlive.stop();\r\n        }\r\n        try {\r\n            await this._logoff();\r\n        } finally {\r\n            this.token = undefined;\r\n            this.expires = new Date();\r\n        }\r\n    }\r\n    async verify() {\r\n        try {\r\n            await this.rev.auth.verifySession();\r\n            return true;\r\n        } catch (err) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @returns wasExtended - whether session was extended / re-logged in\r\n     */\r\n    async lazyExtend(options: Rev.KeepAliveOptions = { }) {\r\n        const {\r\n            extendThresholdMilliseconds: threshold = 3 * ONE_MINUTE,\r\n            verify: shouldVerify = true\r\n        } = options;\r\n\r\n        const { expires } = this;\r\n        const timeLeft = expires\r\n            ? expires.getTime() - Date.now()\r\n            : -1;\r\n\r\n        // login if session expired\r\n        if (timeLeft <= 0) {\r\n            await this.login();\r\n            return true;\r\n        }\r\n\r\n        // extend if within extend window\r\n        if (timeLeft > threshold) {\r\n            try {\r\n                await this.extend();\r\n                // successful extend, nothing more to do\r\n                return true;\r\n            } catch (error) {\r\n                this.rev.log('warn', 'Error extending session - re-logging in', error);\r\n            }\r\n            // check if valid session if plenty of time left\r\n        } else if (!shouldVerify || await this.verify()) {\r\n            // valid, no change\r\n            return false;\r\n        }\r\n\r\n        // if reached here then need to re-login\r\n        await this.login();\r\n        return true;\r\n    }\r\n    async queueRequest(queue: `${RateLimitEnum}`) {\r\n        await this._rateLimits?.[queue]?.();\r\n    }\r\n    /**\r\n     * Abort pending executions. All unresolved promises are rejected with a `AbortError` error.\r\n     * @param {string} [message] - message parameter for rejected AbortError\r\n     */\r\n    async clearQueues(message?: string) {\r\n        await clearQueues(this._rateLimits ?? {}, message);\r\n    }\r\n    /**\r\n     * check if expiration time of session has passed\r\n     */\r\n    get isExpired() {\r\n        const { expires } = this;\r\n        if (!expires) {\r\n            return true;\r\n        }\r\n        return Date.now() > expires.getTime();\r\n    }\r\n    /**\r\n     * returns true if session isn't expired and has a token\r\n     */\r\n    get isConnected() {\r\n        return !!this.token && !this.isExpired;\r\n    }\r\n    get username() {\r\n        return this[_credentials].username;\r\n    }\r\n    get hasRateLimits() {\r\n        return !!this._rateLimits;\r\n    }\r\n    protected abstract _login(): Promise<LoginResponse>;\r\n    protected abstract _extend(): Promise<{ expiration: string; }>;\r\n    protected abstract _logoff(): Promise<void>;\r\n    public abstract toJSON(): Rev.IRevSessionState;\r\n}\r\n\r\n/**\r\n * Use OAuth2Session instead if possible\r\n * @deprecated\r\n */\r\nexport class OAuthSession extends SessionBase {\r\n    refreshToken?: string;\r\n    async _login() {\r\n        const { oauthConfig, authCode } = this[_credentials];\r\n        if (!oauthConfig || !authCode) {\r\n            throw new TypeError('OAuth Config / auth code not specified');\r\n        }\r\n        const {\r\n            accessToken: token,\r\n            expiration,\r\n            refreshToken,\r\n            userId\r\n        } = await this.rev.auth.loginOAuth(oauthConfig, authCode);\r\n        return { token, expiration, refreshToken, userId };\r\n    }\r\n    async _extend() {\r\n        const { [_credentials]: { oauthConfig } } = this;\r\n\r\n        const {\r\n            // other API calls call this \"token\" instead of \"accessToken\", hence the rename\r\n            accessToken: token,\r\n            expiration,\r\n            refreshToken\r\n        } = await this.rev.auth.extendSessionOAuth(oauthConfig as any, <string>this.refreshToken);\r\n\r\n        // unlike other extend methods this updates the token + refreshToken each time\r\n        Object.assign(this, { token, refreshToken });\r\n        return { expiration };\r\n    }\r\n    async _logoff() {\r\n        // nothing to do\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires,\r\n            refreshToken: this.refreshToken\r\n        };\r\n    }\r\n}\r\n\r\nexport class OAuth2Session extends SessionBase {\r\n    refreshToken?: string;\r\n    async _login() {\r\n        const { oauthConfig, code, codeVerifier } = this[_credentials];\r\n        if (!oauthConfig || !code || !codeVerifier) {\r\n            throw new TypeError('OAuth Config / auth code / verifier not specified');\r\n        }\r\n        const {\r\n            access_token: token,\r\n            expires_in,\r\n            refresh_token: refreshToken,\r\n            userId\r\n        } = await this.rev.auth.loginOAuth2(oauthConfig, code, codeVerifier);\r\n        const expiresTime = Date.now() + parseInt(expires_in, 10) * 1000;\r\n        const expiration = new Date(expiresTime).toISOString();\r\n        return { token, expiration, refreshToken, userId };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport class UserSession extends SessionBase {\r\n    userId?: string;\r\n    async _login() {\r\n        const { username, password } = this[_credentials];\r\n        if (!username || !password) {\r\n            throw new TypeError('username/password not specified');\r\n        }\r\n        const {\r\n            token,\r\n            expiration,\r\n            id: userId\r\n        } = await this.rev.auth.loginUser(username, password);\r\n        return { token, expiration, userId };\r\n    }\r\n    async _extend() {\r\n        const { userId } = this;\r\n\r\n        return this.rev.auth.extendSessionUser(<string>userId);\r\n    }\r\n    async _logoff() {\r\n        const { userId } = this;\r\n\r\n        return this.rev.auth.logoffUser(<string>userId);\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires,\r\n            userId: this.userId\r\n        };\r\n    }\r\n}\r\n\r\nexport class ApiKeySession extends SessionBase {\r\n    async _login() {\r\n        const { apiKey, secret } = this[_credentials];\r\n        if (!apiKey || !secret) {\r\n            throw new TypeError('apiKey/secret not specified');\r\n        }\r\n        return this.rev.auth.loginToken(apiKey, secret);\r\n    }\r\n    async _extend() {\r\n        const { apiKey } = this[_credentials];\r\n        return this.rev.auth.extendSessionToken(<string>apiKey);\r\n    }\r\n    async _logoff() {\r\n        const { apiKey } = this[_credentials];\r\n        return this.rev.auth.logoffToken(<string>apiKey);\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires,\r\n            apiKey: this[_credentials].apiKey\r\n        };\r\n    }\r\n}\r\n\r\nexport class JWTSession extends SessionBase {\r\n    async _login() {\r\n        const { jwtToken } = this[_credentials];\r\n        if (!jwtToken) {\r\n            throw new TypeError('JWT Token not specified');\r\n        }\r\n        const {accessToken: token, expiration} = await this.rev.auth.loginJWT(jwtToken);\r\n        return { token, expiration, issuer: 'vbrick' };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport class GuestRegistrationSession extends SessionBase {\r\n    async _login() {\r\n        const { webcastId, guestRegistrationToken } = this[_credentials];\r\n        if (!guestRegistrationToken || !webcastId) {\r\n            throw new TypeError('Guest Registration Token or Webcast ID not specified');\r\n        }\r\n        const {accessToken: token} = await this.rev.auth.loginGuestRegistration(webcastId, guestRegistrationToken);\r\n\r\n        // expires time is not sent, so just assume 15 minutes\r\n        const expiresTime = Date.now() + 1000 * 60 * 15;\r\n        const expiration = new Date(expiresTime).toISOString();\r\n\r\n        return { token, expiration, issuer: 'vbrick' };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport class AccessTokenSession extends SessionBase {\r\n    // just verify user on login\r\n    async _login() {\r\n        const {token} = this[_credentials].session ?? {};\r\n\r\n        // restore token if set to undefined\r\n        this.token ||= token;\r\n\r\n        const {expiration} = await this.rev.auth.extendSession();\r\n\r\n        return {\r\n            token: this.token || '',\r\n            expiration,\r\n            issuer: 'vbrick'\r\n        };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n    override get isConnected() {\r\n        return true;\r\n    }\r\n    override get isExpired() {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport class PublicOnlySession extends SessionBase {\r\n    async _login() {\r\n        this.rev.log('debug', 'Using client with no authentication (publicOnly) - non-public endpoints will return 401');\r\n        // no verify\r\n        return {\r\n            token: this.token || '',\r\n            // very long expiration\r\n            expiration: new Date(Date.now() + 24 * 60 * ONE_MINUTE).toISOString(),\r\n            issuer: 'vbrick'\r\n        };\r\n    }\r\n    async _extend() {\r\n        return {\r\n            expiration: new Date(Date.now() + 24 * 60 * ONE_MINUTE).toISOString()\r\n        }\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n    override get isConnected() {\r\n        return true;\r\n    }\r\n    override get isExpired() {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function createSession(rev: RevClient, credentials: Rev.Credentials, keepAliveOptions?: boolean | Rev.KeepAliveOptions, rateLimits?: boolean | Rev.RateLimits) {\r\n    let session: Rev.IRevSession;\r\n\r\n    const {\r\n        session: sessionState = {} as Rev.IRevSessionState,\r\n        publicOnly,\r\n        ...creds\r\n    } = credentials;\r\n\r\n    const {\r\n        token,\r\n        expiration,\r\n        refreshToken,\r\n        userId\r\n    } = sessionState;\r\n\r\n    const now = Date.now();\r\n    const expires = new Date(expiration || now);\r\n    const hasSession = (token && typeof token === 'string') && (expires.getTime() > now);\r\n\r\n    const isOAuth2Login = credentials.oauthConfig && (credentials.code && credentials.codeVerifier);\r\n    const isLegacyOauthLogin = credentials.oauthConfig && (credentials.authCode || (hasSession && refreshToken));\r\n    const isApiKeyLogin = credentials.apiKey && (credentials.secret || (hasSession && !userId));\r\n    const isUsernameLogin = credentials.username && (credentials.password || (hasSession && userId));\r\n    const isJWTLogin = credentials.jwtToken;\r\n    const isGuestRegistration = credentials.webcastId && credentials.guestRegistrationToken;\r\n\r\n    // prefer oauth first, then apikey then username if multiple params specified\r\n    if (isOAuth2Login) {\r\n        session = new OAuth2Session(rev, creds, keepAliveOptions, rateLimits);\r\n    } else if (isLegacyOauthLogin) {\r\n        session = new OAuthSession(rev, creds, keepAliveOptions, rateLimits);\r\n        if (refreshToken) {\r\n            (session as OAuthSession).refreshToken = refreshToken;\r\n        }\r\n    } else if (isApiKeyLogin) {\r\n        session = new ApiKeySession(rev, creds, keepAliveOptions, rateLimits);\r\n    } else if (isJWTLogin) {\r\n        session = new JWTSession(rev, creds, keepAliveOptions, rateLimits);\r\n    } else if (isGuestRegistration) {\r\n        session = new GuestRegistrationSession(rev, creds, keepAliveOptions, rateLimits);\r\n    } else if (isUsernameLogin) {\r\n        session = new UserSession(rev, creds, keepAliveOptions, rateLimits);\r\n        if (userId) {\r\n            (session as UserSession).userId = userId;\r\n        }\r\n    } else if (publicOnly) {\r\n        session = new PublicOnlySession(rev, creds, false, rateLimits);\r\n    } else if (hasSession) {\r\n        session = new AccessTokenSession(rev, { session: sessionState }, keepAliveOptions, rateLimits);\r\n    } else {\r\n        throw new TypeError('Must specify credentials (username+password, apiKey+secret or oauthConfig+authCode)');\r\n    }\r\n\r\n    if (hasSession) {\r\n        session.token = token;\r\n        session.expires = expires;\r\n    }\r\n    return session;\r\n}\r\n","import * as api from './api';\r\nimport polyfills, { onInitialize, shouldInitialize } from './interop/polyfills';\r\nimport { RevError } from './rev-error';\r\nimport { createSession } from './rev-session';\r\nimport type { Rev } from './types';\r\nimport { RateLimitEnum, isPlainObject, retry } from './utils';\r\nimport { decodeBody } from './utils/request-utils';\r\n\r\n/**\r\n * @categoryDescription Getting Started\r\n * @see {@link RevClient}, the main entry point for using this library\r\n */\r\n\r\n/** @inline */\r\ntype PayloadType = { [key: string]: any; } | Record<string, any> | any[];\r\n\r\n/**\r\n * All API interactions are wrapped up in the `RevClient` class.\r\n *\r\n * @example\r\n * ```js\r\nimport {RevClient} from '/path/to/rev-client.js';\r\n\r\n// create client object\r\nconst rev = new RevClient({\r\n    url: 'https://my.rev.url',\r\n    apiKey: 'my.user.apikey',\r\n    secret: 'my.user.secret',\r\n    // or can login via username + password\r\n    // username: 'my.username',\r\n    // password: 'my.password',\r\n    logEnabled: true, // turn on debug logging\r\n    keepAlive: true // automatically extend session\r\n    rateLimits: true // automatically enforce rate limiting (avoid 429 error responses)\r\n});\r\n\r\n(async () => {\r\n    // call login api and start session. will throw error if invalid login\r\n    await rev.connect();\r\n\r\n    // get details of current user\r\n    const currentUser = await rev.user.details('me');\r\n    console.log(currentUser);\r\n});\r\n```\r\n *\r\n * @category Getting Started\r\n *\r\n * @groupDescription APIs\r\n * Methods to call the Rev APIs  are broken up into namespaces.\r\n * They roughly match up to the categories in the [Rev API Docs](https://revdocs.vbrick.com/reference/developer-hub)\r\n * Documentation for the individual api namespaces are broken out into separate pages:\r\n * * `.admin`: {@link AdminAPI | admin api}\r\n *\r\n * * **`.admin`**: {@link AdminAPI | Admin Methods}\r\n * * **`.audit`**: {@link AuditAPI | Audit Methods}\r\n * * **`.auth`**: {@link AuthAPI | Auth Methods}\r\n * * **`.category`**: {@link CategoryAPI | Category Methods}\r\n * * **`.channel`**: {@link ChannelAPI | Channel Methods}\r\n * * **`.device`**: {@link DeviceAPI | Device Methods}\r\n * * **`.environment`**: {@link EnvironmentAPI | Environment Methods}\r\n * * **`.group`**: {@link GroupAPI | Group Methods}\r\n * * **`.playlist`**: {@link PlaylistAPI | Playlist Methods}\r\n * * **`.recording`**: {@link RecordingAPI | Recording Methods}\r\n * * **`.upload`**: {@link UploadAPI | Upload Methods}\r\n * * **`.user`**: {@link UserAPI | User Methods}\r\n * * **`.video`**: {@link VideoAPI | Video Methods}\r\n * * **`.webcast`**: {@link WebcastAPI | Webcast Methods}\r\n * * **`.zones`**: {@link ZoneAPI | Zone Methods}\r\n *\r\n *\r\n * @groupDescription Session\r\n * Methods to maintain the authentication session (accessToken)\r\n *\r\n * @groupDescription Request\r\n * Methods to directly make (authenticated) HTTP requests\r\n *\r\n * @groupDescription Properties\r\n * instance properties\r\n *\r\n * @groupDescription Internal\r\n * for internal use\r\n *\r\n */\r\nexport class RevClient {\r\n    /**\r\n     * The Rev tenant url (i.e. https://my.rev.url)\r\n     * @group Properties\r\n     */\r\n    url: string;\r\n    /**\r\n     * turns on/off debug logging to console\r\n     * @group Internal\r\n     */\r\n    logEnabled: boolean;\r\n    /**\r\n     ** This is an internal class that handles authentication and maintaining the session. It should not be used directly.\r\n     * @group Internal\r\n     */\r\n    session: Rev.IRevSession;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly admin!: api.AdminAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly audit!: api.AuditAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly auth!: api.AuthAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly category!: api.CategoryAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly channel!: api.ChannelAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly device!: api.DeviceAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly environment!: api.EnvironmentAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly group!: api.GroupAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly playlist!: api.PlaylistAPI;\r\n    /**\r\n     *\r\n     * @group APIs\r\n     */\r\n    readonly recording!: api.RecordingAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly upload!: api.UploadAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly user!: api.UserAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly video!: api.VideoAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly webcast!: api.WebcastAPI;\r\n    /**\r\n     * @group APIs\r\n     */\r\n    readonly zones!: api.ZoneAPI;\r\n    /**\r\n     * @internal\r\n     */\r\n    private _streamPreference: Rev.RequestOptions['responseType'];\r\n    /**\r\n     *\r\n     * @param options The configuration options including target Rev URL and authentication credentials\r\n     */\r\n    constructor(options: Rev.Options) {\r\n        if (!isPlainObject(options) || !options.url) {\r\n            throw new TypeError('Missing configuration options for client - url and username/password or apiKey/secret');\r\n        }\r\n        const {\r\n            url,\r\n            log,\r\n            logEnabled = false,\r\n            keepAlive = true,\r\n            // NOTE default to false rate limiting for now. In future this may change\r\n            rateLimits = false,\r\n            defaultStreamPreference = 'stream',\r\n            ...credentials\r\n        } = options;\r\n\r\n        // get just the origin of provided url\r\n        const urlObj = new URL(url);\r\n        this.url = urlObj.origin;\r\n\r\n        // will throw error if credentials are invalid\r\n        this.session = createSession(this, credentials, keepAlive, rateLimits);\r\n\r\n        // add logging functionality\r\n        this.logEnabled = !!logEnabled;\r\n        if (log) {\r\n            this.log = (severity: Rev.LogSeverity, ...args: any[]) => {\r\n                if (!this.logEnabled) {\r\n                    return;\r\n                }\r\n                log(severity, ...args);\r\n            };\r\n        }\r\n        this._streamPreference = defaultStreamPreference;\r\n\r\n        // add all API endpoints\r\n        Object.defineProperties(this, {\r\n            admin: { value: api.admin(this), writable: false },\r\n            // NOTE rate limiting option passed into api factory since its\r\n            audit: { value: api.audit(this, rateLimits), writable: false },\r\n            auth: { value: api.auth(this), writable: false },\r\n            category: { value: api.category(this), writable: false },\r\n            channel: { value: api.channel(this), writable: false },\r\n            device: { value: api.device(this), writable: false },\r\n            environment: { value: api.environment(this), writable: false },\r\n            group: { value: api.group(this), writable: false },\r\n            playlist: { value: api.playlist(this), writable: false },\r\n            recording: { value: api.recording(this), writable: false },\r\n            upload: { value: api.upload(this), writable: false },\r\n            user: { value: api.user(this), writable: false },\r\n            video: { value: api.video(this), writable: false },\r\n            webcast: { value: api.webcast(this), writable: false },\r\n            // COMBAK - DEPRECATED\r\n            webcasts: { get: () => {\r\n                this.log('debug', 'webcasts is deprecated - use rev.webcast instead');\r\n                return this.webcast;\r\n            }, enumerable: false },\r\n            zones: { value: api.zones(this), writable: false }\r\n        });\r\n    }\r\n    /**\r\n     * make a REST request.\r\n     * The Authorization http header for the current session will automatically be added.\r\n     *\r\n     * @group Request\r\n     * @param method HTTP Method\r\n     * @param endpoint API endpoint path\r\n     * @param data Request body if PUT/POST/PATCH or query parameters object if GET/DELETE/HEAD. objects/arrays are automatically stringified\r\n     * @param options additional request options, including additional HTTP Headers if necessary.\r\n     * @returns the decoded response body as well as statuscode/headers/and raw response\r\n     *\r\n     */\r\n    async request<T = any>(method: Rev.HTTPMethod, endpoint: string, data: any = undefined, options: Rev.RequestOptions = { }): Promise<Rev.Response<T>> {\r\n        // support for dynamically loading fetch polyfill\r\n        if (shouldInitialize()) await onInitialize();\r\n\r\n        const url = new URL(endpoint, this.url);\r\n        // ensure url matches Rev url, to avoid sending authorization header elsewhere\r\n        if (url.origin !== this.url) {\r\n            throw new TypeError(`Invalid endpoint - must be relative to ${this.url}`);\r\n        }\r\n\r\n        let {\r\n            headers: optHeaders,\r\n            responseType,\r\n            throwHttpErrors = true,\r\n            ...requestOpts\r\n        } = options;\r\n\r\n        // setup headers for JSON communication (by default)\r\n        const headers = new polyfills.Headers(optHeaders);\r\n\r\n        // add authorization header from stored token\r\n        if (this.session.token && !headers.has('Authorization')) {\r\n            headers.set('Authorization', `VBrick ${this.session.token}`);\r\n        }\r\n        if (headers.get('Authorization') === '') {\r\n            // if Auth is explicitly set to '' then remove from list\r\n            headers.delete('Authorization');\r\n        }\r\n\r\n        const fetchOptions: RequestInit = {\r\n            mode: 'cors',\r\n            method,\r\n            ...requestOpts,\r\n            headers\r\n        };\r\n\r\n        // default to JSON request payload, but allow it to be overridden\r\n        let shouldSetAsJSON = !headers.has('Content-Type');\r\n        const normalizedMethod = method.toUpperCase();\r\n\r\n        // add provided data to request body or as query string parameters\r\n        if (data) {\r\n            if (['POST', 'PUT', 'PATCH'].includes(normalizedMethod)) {\r\n                if (typeof data === 'string') {\r\n                    fetchOptions.body = data;\r\n                } else if (data instanceof polyfills.FormData) {\r\n                    shouldSetAsJSON = false;\r\n                    fetchOptions.body = data;\r\n                } else if (isPlainObject(data) || Array.isArray(data)) {\r\n                    fetchOptions.body = JSON.stringify(data);\r\n                } else {\r\n                    fetchOptions.body = data;\r\n                }\r\n            } else if (isPlainObject(data)) {\r\n                // add values to query string of URL\r\n                for (let [key, value] of Object.entries(data)) {\r\n                    if (value instanceof Date) value = value.toISOString();\r\n                    url.searchParams.append(key, value);\r\n                }\r\n            } else {\r\n                throw new TypeError(`Invalid payload for request to ${method} ${endpoint}`);\r\n            }\r\n        }\r\n\r\n        // default to JSON communication\r\n        if (!headers.has('Accept')) {\r\n            headers.set('Accept', 'application/json');\r\n        }\r\n        // set to JSON payload\r\n        if (shouldSetAsJSON && fetchOptions.body) {\r\n            headers.set('Content-Type', 'application/json');\r\n        }\r\n\r\n        // OPTIONAL log request and response\r\n        this.log('debug', `Request ${method} ${endpoint}`);\r\n\r\n        if (this.session.hasRateLimits) {\r\n            switch (normalizedMethod) {\r\n                case 'GET':\r\n                    await this.session.queueRequest(RateLimitEnum.Get);\r\n                    break;\r\n                case 'POST':\r\n                case 'PATCH':\r\n                case 'PUT':\r\n                case 'DELETE':\r\n                    await this.session.queueRequest(RateLimitEnum.Post);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // NOTE: will throw error on AbortError or client fetch errors\r\n        const response = await polyfills.fetch(`${url}`, {\r\n            ...fetchOptions,\r\n            method,\r\n            headers\r\n        });\r\n\r\n        const {\r\n            ok,\r\n            status: statusCode,\r\n            statusText,\r\n            headers: responseHeaders\r\n        } = response;\r\n\r\n        // check for error response code\r\n        if (!ok) {\r\n            if (throwHttpErrors) {\r\n                const err = await RevError.create(response);\r\n                this.log('debug', `Response ${method} ${endpoint} ${statusCode} ${err.code || statusText}`);\r\n                throw err;\r\n            }\r\n            // if not throwwing then force responseType to auto (could be text or json)\r\n            responseType = undefined;\r\n        }\r\n\r\n        this.log('debug', `Response ${method} ${endpoint} ${statusCode} ${statusText}`);\r\n\r\n        let body: any = response.body;\r\n\r\n        switch (responseType) {\r\n            case 'json':\r\n                // safety check for empty response\r\n                if (`${responseHeaders.get('content-length')}` === '0') {\r\n                    body = null;\r\n                } else {\r\n                    body = await response.json();\r\n                }\r\n                break;\r\n            case 'text':\r\n                body = await response.text();\r\n                break;\r\n            case 'blob':\r\n                body = await response.blob();\r\n                break;\r\n            case 'stream':\r\n                switch (this._streamPreference) {\r\n                    case 'webstream': body = polyfills.asWebStream(response.body); break;\r\n                    case 'nativestream': body = polyfills.asPlatformStream(response.body); break;\r\n                    default: body = response.body;\r\n                }\r\n                body = response.body;\r\n                break;\r\n            case 'webstream':\r\n                body = polyfills.asWebStream(response.body);\r\n                break;\r\n            case 'nativestream':\r\n                body = polyfills.asPlatformStream(response.body);\r\n                break;\r\n            default:\r\n                // if no mimetype in response then assume JSON unless otherwise specified\r\n                body = await decodeBody(response, headers.get('Accept'));\r\n        }\r\n\r\n        return {\r\n            statusCode,\r\n            headers: responseHeaders,\r\n            body,\r\n            response\r\n        };\r\n    }\r\n    /**\r\n     *\r\n     * Make a GET Request\r\n     * @group Request\r\n     * @param endpoint API path\r\n     * @param data Query parameters as json object\r\n     * @param options Additional request options\r\n     * @returns Depends on options.responseType/API response - usually JSON object except for binary download endpoints\r\n     */\r\n    async get<T = any>(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<T> {\r\n        const { body } = await this.request('GET', endpoint, data, options);\r\n        return body;\r\n    }\r\n    /**\r\n     *\r\n     * Make a POST Request\r\n     * @group Request\r\n     * @param endpoint API path\r\n     * @param data Request body\r\n     * @param options Additional request options\r\n     * @returns Depends on options.responseType/API response - usually JSON object\r\n     */\r\n    async post<T = any>(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<T> {\r\n        const { body } = await this.request('POST', endpoint, data, options);\r\n        return body;\r\n    }\r\n    /**\r\n     *\r\n     * Make a GET Request\r\n     * @group Request\r\n     * @param endpoint API path\r\n     * @param data Request body\r\n     * @param options Additional request options\r\n     * @returns Depends on options.responseType/API response - usually JSON object or void\r\n     */\r\n    async put<T = any>(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<T> {\r\n        const { body } = await this.request('PUT', endpoint, data, options);\r\n        return body;\r\n    }\r\n    /**\r\n     *\r\n     * Make a PATCH Request\r\n     * @group Request\r\n     * @param endpoint API path\r\n     * @param data Request body\r\n     * @param options Additional request options\r\n     * @returns\r\n     */\r\n    async patch(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<void> {\r\n        await this.request('PATCH', endpoint, data, options);\r\n    }\r\n    /**\r\n     *\r\n     * Make a DELETE Request\r\n     * @group Request\r\n     * @param endpoint API path\r\n     * @param data query parameters as JSON object\r\n     * @param options Additional request options\r\n     * @returns\r\n     */\r\n    async delete(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<void> {\r\n        await this.request('DELETE', endpoint, data, options);\r\n    }\r\n    /**\r\n     *\r\n     * authenticate with Rev\r\n     * @group Session\r\n     */\r\n    async connect() {\r\n\r\n        // Rarely the login call will fail on first attempt, therefore this code attempts to login\r\n        // multiple times\r\n        await retry(\r\n            () => this.session.login(),\r\n            // Do not re-attempt logins with invalid user/password or rate limiting - it can lock out the user\r\n            (err: RevError) => ![401, 429].includes(err.status));\r\n    }\r\n    /**\r\n     *\r\n     * end rev session\r\n     * @group Session\r\n     */\r\n    async disconnect() {\r\n        try {\r\n            await this.session.logoff();\r\n        } catch (error) {\r\n            this.log('warn', `Error in logoff, ignoring: ${error}`);\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * Call the Extend Session API to maintain the current session's expiration time\r\n     * Note that this API call is automatically handled unless `keepAlive: false` was specified in configuring the client.\r\n     * @group Session\r\n     */\r\n    async extendSession() {\r\n        return this.session.extend();\r\n    }\r\n    /**\r\n     *\r\n     * Returns true/false based on if the session is currently valid\r\n     * @group Session\r\n     * @returns Promise<boolean>\r\n     */\r\n    async verifySession() {\r\n        return this.session.verify();\r\n    }\r\n    /**\r\n     *\r\n     * Returns true if session is connected and token's expiration date is in the future\r\n     * @group Properties\r\n     */\r\n    get isConnected() {\r\n        return this.session.isConnected;\r\n    }\r\n    /**\r\n     *\r\n     * the current session's `accessToken`\r\n     * @group Properties\r\n     */\r\n    get token() {\r\n        return this.session.token;\r\n    }\r\n    /**\r\n     *\r\n     * `Date` value when current `accessToken` will expire\r\n     * @group Properties\r\n     */\r\n    get sessionExpires() {\r\n        return this.session.expires;\r\n    }\r\n    /**\r\n     *\r\n     * get/set serialized session state (accessToken, expiration, and userId/apiKey)\r\n     * Useful if you need to create a new RevClient instance with the same accessToken\r\n     * @group Properties\r\n     */\r\n    get sessionState() {\r\n        return this.session.toJSON();\r\n    }\r\n    /**\r\n     *\r\n     * get/set serialized session state (accessToken, expiration, and userId/apiKey)\r\n     * Useful if you need to create a new RevClient instance with the same accessToken\r\n     * @group Properties\r\n     */\r\n    set sessionState(state: Rev.IRevSessionState) {\r\n        this.session.token = `${state.token}`;\r\n        this.session.expires = new Date(state.expiration);\r\n        for (let key of ['apiKey', 'refreshToken', 'userId'] as (keyof Rev.IRevSessionState)[]) {\r\n            if (key in state) {\r\n                (this.session as any)[key] = `${state[key] || ''}`;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * used internally to write debug log entries. Does nothing if `logEnabled` is `false`\r\n     * @group Internal\r\n     * @param severity\r\n     * @param args\r\n     * @returns\r\n     */\r\n    log(severity: Rev.LogSeverity, ...args: any[]) {\r\n        if (!this.logEnabled) {\r\n            return;\r\n        }\r\n\r\n        const ts = (new Date()).toJSON().replace('T', ' ').slice(0, -5);\r\n        console.debug(`${ts} REV-CLIENT [${severity}]`, ...args);\r\n    }\r\n}\r\n"],"mappings":"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","names":["src_exports","__export","RevClient","RevError","ScrollError","src_default","utils","mimeTypes","getMimeForExtension","extension","defaultType","getExtensionForMime","contentType","defaultExtension","match","ext","mime","sanitizeUploadOptions","filename","defaultContentType","name","_toString","isPlainObject","val","prototype","isBlobLike","titleCase","val","LOCAL_PROTOCOLS","uploadParser","value","options","url","polyfills_default","file","contentType","response","body","headers","RevError","filename","defaultContentType","sanitized","sanitizeUploadOptions","isBlobLike","appendJSONToForm","form","fieldName","data","appendFileToForm","input","uploadOptions","uploadMultipart","rev","method","endpoint","optHeaders","randomValues","byteLength","values","c","sha256Hash","value","bytes","hashed","binary","hmacSign","message","secret","enc","cryptoKey","signed","polyfills","args","uploadParser","form","headers","uploadOptions","options","stream","polyfills_default","isPendingInitialize","initializePromise","pendingInitialize","shouldInitialize","onInitialize","pending","overrides","setPolyfills","overrideCallback","ONE_MINUTE","rateLimit","fn","options","perSecond","perMinute","perHour","signal","limit","interval","queue","currentTick","activeCount","throttled","args","timeout","resolve","reject","execute","now","abortHandler","message","dispose","polyfills_default","rate_limit_default","defaultRateLimits","fn","normalizeRateLimitOptions","rateLimits","makeQueue","key","value","defaultValue","perMinute","limit","rate_limit_default","makeQueues","entries","clearQueues","message","asValidDate","val","defaultValue","retry","fn","shouldRetry","maxAttempts","sleepMilliseconds","attempt","err","sleep","ms","signal","done","timer","cleanup","tryParseJson","RevError","_RevError","response","body","status","statusText","url","__publicField","isPlainObject","code","detail","tryParseJson","err","ScrollError","PagedRequest","options","__publicField","items","current","total","err","onProgress","onError","signal","page","result","done","error","maxResults","pageCount","results","hit","decodeBody","response","acceptType","contentType","contentLength","SearchRequest","PagedRequest","rev","searchDefinition","query","options","items","current","total","hitsKey","err","__publicField","_ignore","queryOpt","endpoint","totalKey","isPost","request","transform","requestFn","scrollId","rawItems","statusCode","statusDescription","done","error","ScrollError","adminAPIFactory","rev","roles","customFields","adminAPI","cache","response","name","fromCache","role","r","field","cf","registrationField","fieldId","query","options","searchDefinition","SearchRequest","schedules","videoId","params","parseCSV","raw","cur","inQuote","fieldQuoted","field","row","out","i","n","processField","headers","line","obj","parseEntry","line","tryParseJson","AuditRequest","PagedRequest","rev","endpoint","label","toDate","fromDate","beforeRequest","options","items","current","total","__publicField","from","to","response","body","headers","parseCSV","remaining","done","asValidDate","defaultFrom","auditAPIFactory","rev","optRateLimits","requestsPerMinute","normalizeRateLimitOptions","makeOptTransform","opts","lock","makeQueue","req","locks","accountId","options","AuditRequest","userId","groupId","deviceId","videoId","eventId","mergeHeaders","source","other","merged","polyfills_default","value","key","PLACEHOLDER","getOAuth2AuthorizationUrl","config","code_challenge","state","url","getOAuth2PKCEVerifier","codeVerifier","polyfills_default","codeChallenge","buildLegacyOAuthQuery","oauthSecret","hmacSign","RESPONSE_TYPE","apiKey","redirectUri","verifier","signature","parseLegacyOAuthRedirectResponse","query","authCode","error","authAPIFactory","rev","authAPI","apiKey","secret","options","username","password","userId","jwtToken","webcastId","opts","mergeHeaders","config","state","verifier","codeChallenge","codeVerifier","getOAuth2PKCEVerifier","_cfg","getOAuth2AuthorizationUrl","code","oauthSecret","query","buildLegacyOAuthQuery","url","parseLegacyOAuthRedirectResponse","authCode","GRANT_AUTH","redirectUri","refreshToken","GRANT_REFRESH","categoryAPIFactory","rev","category","categoryId","parentCategoryId","includeAllDescendants","payload","categories","channelAPIFactory","rev","channel","channelId","operations","options","start","ChannelListRequest","members","member","endpoint","searchText","searchDefinition","query","SearchRequest","__publicField","items","current","total","params","maxResults","onProgress","delta","results","hit","deviceAPIFactory","rev","dme","deviceId","groupAPIFactory","rev","groupAPI","group","groupId","searchText","options","searchDefinition","hits","formatGroupSearchHit","query","SearchRequest","userIds","result","userId","out","details","error","hit","getSummaryFromResponse","response","hitsKey","ignoreKeys","key","value","PlaylistDetailsRequest","SearchRequest","rev","playlistId","query","options","searchDefinition","endpoint","__publicField","videos","playlistAPIFactory","rev","name","videos","payload","playlistId","query","options","PlaylistDetailsRequest","actions","parsePlaylist","entry","id","featurePlaylistId","featuredPlaylist","playlistName","extra","rawResult","hasFeatured","output","isPlainObject","recordingAPIFactory","rev","sipAddress","sipPin","title","videoId","status","payload","result","isPlainObject","request","scheduledRecordingId","recordingId","splitOptions","options","defaultType","filename","contentType","contentLength","useChunkedTransfer","defaultContentType","requestOptions","uploadAPIFactory","rev","file","metadata","uploadOptions","form","polyfills_default","defaultUsername","appendJSONToForm","filePayload","appendFileToForm","videoId","uploadMultipart","language","lang","chapters","action","index","chapter","title","time","imageFile","fileUploadOptions","chapterEntry","fileOpts","eventId","request","logoOptions","backgroundOptions","logoImagePayload","backgroundImagePayload","meta","channelId","userId","userAPIFactory","rev","details","userLookupValue","options","lookupType","requestOptions","query","result","userAPI","user","userId","username","email","type","response","groupId","operations","searchText","assignable","searchDefinition","items","formatUserSearchHit","SearchRequest","id","unread","notificationId","sortField","sortOrder","Users","hit","videoDownloadAPI","rev","download","videoId","options","downloadChapter","chapter","imageUrl","body","downloadSupplemental","fileId","endpoint","isPlainObject","opts","downloadTranscription","language","downloadThumbnail","query","imageId","thumbnailUrl","downloadThumbnailSheet","thumbnailSheet","thumbnailSheetsUri","sheetIndex","videoExternalAccessAPI","rev","videoId","q","options","searchDefinition","payload","SearchRequest","request","DEFAULT_INCREMENT","DEFAULT_SORT","addDays","date","numDays","d","parseOptions","options","incrementDays","sortDirection","videoIds","startDate","endDate","otherOptions","s","parseDates","startArg","endArg","now","asValidDate","VideoReportRequest","PagedRequest","rev","endpoint","__publicField","scrollId","isAscending","rangeStart","rangeEnd","done","query","page","items","value","videoReportAPI","report","videoId","isPlainObject","summaryStatistics","payload","videoAPIFactory","rev","comments","videoId","showAll","videoAPI","title","payload","customField","options","metadata","chapters","err","RevError","supplementalFiles","thumbnailCfg","transcriptionFiles","requestOptions","query","searchDefinition","endpoint","SearchRequest","videos","result","rawVideo","out","details","error","video","ip","userAgent","opts","mergeHeaders","videoDownloadAPI","videoReportAPI","videoExternalAccessAPI","removedSegments","keepRanges","operations","fields","description","language","transcriptionId","source","target","status","locale","s","fileId","fileIds","startTime","commentIds","trackIndex","id","audioTracks","index","t","op","request","languageName","languageId","track","value","audioTrack","existing","pollIntervalSeconds","timeoutMinutes","signal","ignorePlaybackWhileTranscoding","onProgress","onError","ONE_MINUTE","timeoutDate","pollInterval","statusResponse","isProcessing","overallProgress","sleep","getSummaryFromResponse","response","hitsKey","ignoreKeys","key","value","RealtimeReportRequest","SearchRequest","rev","eventId","query","options","searchDefinition","endpoint","summary","PostEventReportRequest","runNumber","runQuery","statusCode","body","RevError","webcastAPIFactory","rev","webcastAPI","options","requestOptions","query","searchDefinition","endpoint","SearchRequest","event","eventId","operations","entities","runNumber","PostEventReportRequest","RealtimeReportRequest","rawResponse","polls","response","body","jobId","ip","userAgent","opts","mergeHeaders","playbackResults","preProduction","videoId","autoRedirect","payload","registrationId","userId","commentId","registration","key","value","titleCase","email","contentLinks","contentLink","linkId","isEnabled","id","banners","banner","bannerId","zonesAPIFactory","rev","zonesAPI","defaultZone","zones","flatZones","recursiveAdd","inZone","childZones","zone","zoneId","environmentAPIFactory","rev","accountId","version","ulsInfo","bootstrap","fallbackGetAccountId","forceRefresh","text","error","fallbackGetRevVersion","getBootstrapImpl","id","err","useLegacyApi","timeoutMs","controller","getIp","ulsUrl","ip","timer","ONE_MINUTE","DEFAULT_EXPIRE_MINUTES","_credentials","SessionKeepAlive","session","options","__publicField","expires","interval","threshold","MIN_INTERVAL_MS","timeTillExpiration","controller","signal","nextExtendTime","sleep","err","oldController","polyfills_default","_a","SessionBase","rev","credentials","keepAliveOptions","rateLimits","isPlainObject","rateLimitQueues","makeQueues","expiration","shouldVerify","timeLeft","error","queue","message","clearQueues","OAuthSession","oauthConfig","authCode","token","refreshToken","userId","OAuth2Session","code","codeVerifier","expires_in","expiresTime","UserSession","username","password","ApiKeySession","apiKey","secret","JWTSession","jwtToken","GuestRegistrationSession","webcastId","guestRegistrationToken","AccessTokenSession","PublicOnlySession","createSession","sessionState","publicOnly","creds","now","hasSession","isOAuth2Login","isLegacyOauthLogin","isApiKeyLogin","isUsernameLogin","isJWTLogin","isGuestRegistration","RevClient","options","__publicField","isPlainObject","url","log","logEnabled","keepAlive","rateLimits","defaultStreamPreference","credentials","urlObj","createSession","severity","args","adminAPIFactory","auditAPIFactory","authAPIFactory","categoryAPIFactory","channelAPIFactory","deviceAPIFactory","environmentAPIFactory","groupAPIFactory","playlistAPIFactory","recordingAPIFactory","uploadAPIFactory","userAPIFactory","videoAPIFactory","webcastAPIFactory","zonesAPIFactory","method","endpoint","data","shouldInitialize","onInitialize","optHeaders","responseType","throwHttpErrors","requestOpts","headers","polyfills_default","fetchOptions","shouldSetAsJSON","normalizedMethod","key","value","response","ok","statusCode","statusText","responseHeaders","err","RevError","body","decodeBody","retry","error","state","ts","utils","rate_limit_default","getExtensionForMime","getMimeForExtension","setPolyfills","src_default","RevClient"]}