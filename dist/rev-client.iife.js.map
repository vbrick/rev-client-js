{"version":3,"sources":["../src/index.ts","../src/utils/file-utils.ts","../src/utils/is-utils.ts","../src/utils/multipart-utils.ts","../src/interop/polyfills.ts","../src/utils/rate-limit.ts","../src/utils/rate-limit-queues.ts","../src/utils/index.ts","../src/rev-error.ts","../src/utils/paged-request.ts","../src/utils/request-utils.ts","../src/api/admin.ts","../src/utils/parse-csv.ts","../src/api/audit-request.ts","../src/api/audit.ts","../src/utils/merge-headers.ts","../src/api/oauth.ts","../src/api/auth.ts","../src/api/category.ts","../src/api/channel.ts","../src/api/device.ts","../src/api/group.ts","../src/api/playlist-details-request.ts","../src/api/playlist.ts","../src/api/recording.ts","../src/api/upload.ts","../src/api/user.ts","../src/api/video-report-request.ts","../src/api/video-download.ts","../src/api/video-external-access.ts","../src/api/video.ts","../src/api/webcast-report-request.ts","../src/api/webcast.ts","../src/api/zones.ts","../src/api/environment.ts","../src/rev-session.ts","../src/rev-client.ts"],"sourcesContent":["export * from './rev-client';\r\nexport * from './rev-error';\r\nexport type * from './types';\r\n\r\nimport {rateLimit} from './utils';\r\nimport {getExtensionForMime, getMimeForExtension} from './utils/file-utils';\r\nimport { setPolyfills } from './interop/polyfills';\r\nexport const utils = {\r\n    rateLimit,\r\n    getExtensionForMime,\r\n    getMimeForExtension,\r\n    setPolyfills\r\n};\r\n\r\nimport { RevClient } from './rev-client';\r\nexport default RevClient;\r\n","\r\nexport const mimeTypes = {\r\n    '.7z': 'application/x-7z-compressed',\r\n    '.asf': 'video/x-ms-asf',\r\n    '.avi': 'video/x-msvideo',\r\n    '.csv': 'text/csv',\r\n    '.doc': 'application/msword',\r\n    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\r\n    '.f4v': 'video/x-f4v',\r\n    '.flv': 'video/x-flv',\r\n    '.gif': 'image/gif',\r\n    '.jpg': 'image/jpeg',\r\n    '.m4a': 'audio/mp4',\r\n    '.m4v': 'video/x-m4v',\r\n    '.mkv': 'video/x-matroska',\r\n    '.mov': 'video/quicktime',\r\n    '.mp3': 'audio/mpeg',\r\n    '.mp4': 'video/mp4',\r\n    '.mpg': 'video/mpeg',\r\n    '.pdf': 'application/pdf',\r\n    '.png': 'image/png',\r\n    '.ppt': 'application/vnd.ms-powerpoint',\r\n    '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',\r\n    '.rar': 'application/x-rar-compressed',\r\n    '.srt': 'application/x-subrip',\r\n    '.svg': 'image/svg+xml',\r\n    '.swf': 'application/x-shockwave-flash',\r\n    '.ts': 'video/mp2t',\r\n    '.txt': 'text/plain',\r\n    '.wmv': 'video/x-ms-wmv',\r\n    '.xls': 'application/vnd.ms-excel',\r\n    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\r\n    '.zip': 'application/zip',\r\n    '.mks': 'video/x-matroska',\r\n    '.mts': 'model/vnd.mts',\r\n    '.vtt': 'text/vtt',\r\n    '.wma': 'audio/x-ms-wma'\r\n};\r\n\r\nexport function getMimeForExtension(extension: string = '', defaultType = 'video/mp4') {\r\n    extension = extension.toLowerCase();\r\n    if (extension && (extension in mimeTypes)) {\r\n        return mimeTypes[extension as keyof typeof mimeTypes];\r\n    }\r\n    return defaultType;\r\n}\r\n\r\nexport function getExtensionForMime(contentType: string, defaultExtension = '.mp4') {\r\n    const match = contentType && Object.entries(mimeTypes)\r\n        .find(([ext, mime]) => contentType.startsWith((mime)));\r\n    return match\r\n        ? match[0]\r\n        : defaultExtension;\r\n\r\n}\r\n\r\nexport function sanitizeUploadOptions(filename = 'upload', contentType = '', defaultContentType?: string) {\r\n    // sanitize content type\r\n    if (contentType === 'application/octet-stream') {\r\n        contentType = '';\r\n    }\r\n    if (/charset/.test(contentType)) {\r\n        contentType = contentType.replace(/;?.*charset.*$/, '');\r\n    }\r\n    let name = filename.replace(/\\.[^\\.]+$/, '');\r\n    let ext = filename.replace(name, '');\r\n    if (!ext) {\r\n        ext = getExtensionForMime(contentType || defaultContentType || '');\r\n    }\r\n\r\n    filename = `${name}${ext}`;\r\n\r\n    // extra check for transcription filetype\r\n    if (!contentType || ['.vtt', '.srt'].includes(ext)) {\r\n        contentType = getMimeForExtension(ext, defaultContentType);\r\n    }\r\n\r\n\r\n    return { filename, contentType };\r\n}\r\n\r\n","const { toString: _toString } = Object.prototype;\r\n\r\nexport function isPlainObject<T = { [key: string]: any; } | any[]>(val: unknown): val is T {\r\n    if (_toString.call(val) !== '[object Object]') {\r\n        return false;\r\n    }\r\n    const prototype = Object.getPrototypeOf(val);\r\n    return prototype === null || prototype === Object.getPrototypeOf({ });\r\n}\r\n\r\nexport function isBlobLike(val: unknown): val is Blob | File {\r\n    return typeof (val as Blob)?.stream === 'function';\r\n}\r\n\r\nexport function isReadable<T = any>(val: unknown): val is AsyncIterable<T> {\r\n    return typeof (val as AsyncIterable<T>)[Symbol.asyncIterator] === 'function';\r\n}\r\n\r\nexport function titleCase(val: string) {\r\n    return `${val[0]}${val.slice(1)}`;\r\n}\r\n\r\n// exclude 0 / false from falsy check\r\nexport function isBlank(val: any) {\r\n    return val == undefined || val === '';\r\n}\r\n","import polyfills from '../interop/polyfills';\r\nimport type { RevClient } from '../rev-client';\r\nimport { RevError } from '../rev-error';\r\nimport type { Rev } from '../types';\r\nimport { sanitizeUploadOptions } from './file-utils';\r\nimport { isBlobLike } from './is-utils';\r\n\r\nexport const uploadParser = {\r\n    async string(value: string | URL, options: Rev.UploadFileOptions) {\r\n        const url = value instanceof URL\r\n            ? value\r\n            : new URL(value, 'invalid://');\r\n\r\n        if (!/^data|blob|file/.test(url.protocol)) {\r\n            throw new TypeError('Only Blob / DateURI URLs are supported');\r\n        }\r\n        if (options.disableExternalResources && url.protocol === 'file:') {\r\n            throw new Error('file: protocol not allowed');\r\n        }\r\n        const file = await (await polyfills.fetch(url)).blob();\r\n        return uploadParser.blob(file, options)\r\n    },\r\n    async stream(value: AsyncIterable<Uint8Array>, options: Rev.UploadFileOptions) {\r\n        const {contentType} = options;\r\n        // allow web streams only\r\n        if (!(value instanceof ReadableStream)) {\r\n            throw new TypeError('Only Blob / Files are supported for file uploads. Pass a File/Blob object');\r\n        }\r\n        // FormData doesn't support readable streams unfortunately, so read to blob\r\n        const response = new Response(value, {\r\n            headers: contentType ? { 'content-type': contentType } : {}\r\n        });\r\n        return uploadParser.response(response, options);\r\n    },\r\n    async response(response: Response, options: Rev.UploadFileOptions) {\r\n        const { body, headers } = response;\r\n        if (!response.ok || !body) {\r\n            const err = await RevError.create(response);\r\n            throw err;\r\n        }\r\n        return uploadParser.blob(\r\n            await response.blob(),\r\n            options\r\n        );\r\n    },\r\n    async blob(value: Blob | File, options: Rev.UploadFileOptions) {\r\n        let {\r\n            filename = (value as File).name ?? 'upload',\r\n            contentType = value.type ?? '',\r\n            defaultContentType\r\n        } = options;\r\n    \r\n        const sanitized = sanitizeUploadOptions(filename, contentType, defaultContentType);\r\n\r\n        if (value.type !== sanitized.contentType && typeof value.slice === 'function') {\r\n            value = new File([value], sanitized.filename, { type: sanitized.contentType });\r\n        }\r\n        return {\r\n            file: value,\r\n            options: {\r\n                ...options,\r\n                ...value.size && { contentLength: value.size },\r\n                ...sanitized\r\n            }\r\n        };\r\n    },\r\n    async parse(value: Rev.FileUploadType, options: Rev.UploadFileOptions) {\r\n        if (typeof value === 'string' || value instanceof URL) {\r\n            return uploadParser.string(value, options);\r\n        }\r\n        if (value instanceof polyfills.Response) {\r\n            return uploadParser.response(value, options);\r\n        }\r\n        if (!isBlobLike(value)) {\r\n            throw new TypeError('Only Blob / Files are supported for file uploads. Pass a File/Blob object');\r\n        }\r\n        return uploadParser.blob(value, options);\r\n    }\r\n}\r\n\r\n\r\nexport function appendJSONToForm(form: FormData, fieldName: string, data: any) {\r\n    form.append(fieldName, JSON.stringify(data));\r\n}\r\n/**\r\n * This method is included for isometric support of uploading files in node.js and browser.\r\n * @param form FormData instance\r\n * @param fieldName name of field to add to form\r\n * @param file the file. Can be Blob or File on browser. On node.js it can be anything the 'form-data' package will accept\r\n * @param options optional filename, contentType and contentLength of upload. Otherwise it will try to guess based on input\r\n */\r\n\r\nexport async function appendFileToForm(form: FormData, fieldName: string, input: Rev.FileUploadType, uploadOptions: Rev.UploadFileOptions = {}): Promise<Rev.UploadFileOptions> {\r\n    const {\r\n        file,\r\n        options\r\n    } = await polyfills.uploadParser.parse(input, uploadOptions)\r\n    form.append(fieldName, file, options.filename);\r\n    return options;\r\n}\r\n/**\r\n * helper to upload multipart forms with files attached.\r\n * This is to work around issues with node.js's FormData implementation\r\n * @param rev Rev Client\r\n * @param method\r\n * @param endpoint\r\n * @param form\r\n * @param useChunkedTransfer\r\n * @param options\r\n * @returns\r\n */\r\n\r\nexport async function uploadMultipart(\r\n    rev: RevClient,\r\n    method: Rev.HTTPMethod,\r\n    endpoint: string,\r\n    form: FormData,\r\n    uploadOptions: Rev.UploadFileOptions,\r\n    options: Rev.RequestOptions = {}\r\n) {\r\n    const {\r\n        headers: optHeaders\r\n    } = options;\r\n\r\n    // coerce to Headers object, may be undefined\r\n    const headers = new polyfills.Headers(optHeaders);\r\n    options.headers = headers;\r\n\r\n    // switches to transfer encoding upload if necessary in node\r\n    // returns the body payload (on node.js it mutates options to set the body)\r\n    const data = polyfills.beforeFileUploadRequest(form, headers, uploadOptions, options);\r\n\r\n    const { body } = await rev.request(method, endpoint, data, options);\r\n    return body;\r\n}\r\n","/**\r\n * There are slight differences in handling browser and node.js environments.\r\n * This folder wraps all components that get polyfilled in node.js, as well as\r\n * allowing uploading a video from the local filesystem on node.js\r\n */\r\nimport { isBlobLike } from '../utils/is-utils';\r\nimport { uploadParser } from '../utils/multipart-utils';\r\nimport type { Rev } from '../types/rev';\r\n\r\n\r\n/**\r\n * used in OAuth - get random verifier string\r\n * @param byteLength\r\n */\r\nfunction randomValues(byteLength: number) {\r\n    const values = crypto.getRandomValues(new Uint8Array(byteLength / 2));\r\n    return Array.from(values)\r\n        .map(c => c.toString(16).padStart(2, '0'))\r\n        .join('');\r\n}\r\n\r\n/**\r\n * sha256 hash function for oauth2 pkce\r\n * @param value\r\n * @returns\r\n */\r\nasync function sha256Hash(value: string) {\r\n    const bytes = new TextEncoder().encode(value);\r\n    const hashed = await crypto.subtle.digest('SHA-256', bytes);\r\n    const binary = String.fromCharCode(...(new Uint8Array(hashed)));\r\n    return btoa(binary)\r\n        .replace(/\\//g, '_')\r\n        .replace(/\\+/g, '-')\r\n        .replace(/=+$/, '');\r\n}\r\n\r\n\r\n/**\r\n * used to sign the verifier in OAuth workflow\r\n */\r\nasync function hmacSign(message: string, secret: string) {\r\n    const enc = new TextEncoder();\r\n    const cryptoKey = await crypto.subtle\r\n        .importKey(\r\n            'raw',\r\n            enc.encode(secret),\r\n            { name: 'HMAC', hash: 'SHA-256' },\r\n            true,\r\n            ['sign']\r\n        );\r\n    const signed = await crypto.subtle.sign('HMAC', cryptoKey, enc.encode(message));\r\n    return btoa(String.fromCharCode(...new Uint8Array(signed)));\r\n}\r\n\r\nexport const polyfills = {\r\n    AbortController: globalThis.AbortController,\r\n    AbortSignal: globalThis.AbortSignal,\r\n    createAbortError(message: string): Error {\r\n        return new DOMException(message, 'AbortError');\r\n    },\r\n    fetch: globalThis.fetch,\r\n    FormData: globalThis.FormData,\r\n    File: globalThis.File,\r\n    Headers: globalThis.Headers,\r\n    Request: globalThis.Request,\r\n    Response: globalThis.Response,\r\n    uploadParser,\r\n    randomValues,\r\n    sha256Hash,\r\n    hmacSign,\r\n    beforeFileUploadRequest(form: FormData, headers: Headers, uploadOptions: Rev.UploadFileOptions, options: Rev.RequestOptions): FormData | undefined {\r\n        return form;\r\n    },\r\n    asPlatformStream<TIn = any, TOut = TIn>(stream: TIn): TOut {\r\n        // nothing - this is used for fixing node's stream response\r\n        return stream as any;\r\n    },\r\n    asWebStream<TIn = any>(stream: TIn): ReadableStream {\r\n        // nothing - this is used for fixing node's stream response\r\n        return stream as any;\r\n    }\r\n}\r\nexport default polyfills;\r\n\r\nexport type RevPolyfills = typeof polyfills;\r\n\r\n// logic for overriding polyfills before first network request\r\ntype InitializeCallback = (polyfills: RevPolyfills) => Promise<void> | void;\r\nlet isPendingInitialize = false;\r\nlet initializePromise: Promise<void> | undefined = undefined;\r\nconst pendingInitialize: InitializeCallback[] = [];\r\n\r\nexport function shouldInitialize() {\r\n    return !!isPendingInitialize;\r\n}\r\n\r\nexport function onInitialize() {\r\n    if (!isPendingInitialize) {\r\n        return;\r\n    }\r\n    \r\n    initializePromise ||= (async () => {\r\n        while (pendingInitialize.length > 0) {\r\n            const pending = pendingInitialize.shift();\r\n            if (typeof pending !== 'function') continue;\r\n            try {\r\n                const overrides = await pending(polyfills);\r\n                Object.assign(polyfills, overrides);\r\n            } catch (error) {\r\n                // ignore\r\n            }\r\n        }\r\n        isPendingInitialize = false;\r\n        initializePromise = undefined;\r\n    })();\r\n\r\n    return initializePromise;\r\n}\r\n\r\nexport function setPolyfills(overrideCallback: (polyfills: RevPolyfills) => Promise<void> | void) {\r\n    pendingInitialize.push(overrideCallback);\r\n    isPendingInitialize = true;\r\n}","import polyfills from '../interop/polyfills';\r\n\r\nconst ONE_MINUTE = 60 * 1000;\r\n\r\ninterface RateLimitOptions{\r\n    /**\r\n     * how many to allow in parallel in any given interval\r\n     * @default 1\r\n     */\r\n    limit?: number,\r\n    /**\r\n     * interval in milliseconds\r\n     */\r\n    interval?: number,\r\n    /**\r\n     * set limit to X per second\r\n     */\r\n    perSecond?: number,\r\n    /**\r\n     * set limit to X per minute (can be fraction, i.e. 0.5 for 1 every 2 minutes)\r\n     */\r\n    perMinute?: number,\r\n    /**\r\n     * set limit to X per hour\r\n     */\r\n    perHour?: number,\r\n    /**\r\n     * cancel with AbortController\r\n     */\r\n    signal?: AbortSignal\r\n}\r\n\r\nexport type ThrottledFunction<T extends (...args: any[]) => any> = (\r\n    (...args: Parameters<T>) => ReturnType<T> extends PromiseLike<infer Return> ? Promise<Return> : Promise<ReturnType<T>>\r\n) & {\r\n    /**\r\n     * Abort pending executions. All unresolved promises are rejected with a `AbortError` error.\r\n     * @param {string} [message] - message parameter for rejected AbortError\r\n     * @param {boolean} [dispose] - remove abort signal listener as well\r\n     */\r\n    abort: (message?: string, dispose?: boolean) => void;\r\n};\r\n\r\ninterface RateLimitOptionsWithFn<T> extends RateLimitOptions {\r\n    /**\r\n     * function to rate limit\r\n     */\r\n    fn: T\r\n}\r\nfunction rateLimit<T extends (...args: any) => any>(options: RateLimitOptionsWithFn<T>): ThrottledFunction<T>;\r\nfunction rateLimit<T extends (...args: any) => any>(fn: T, options: RateLimitOptions): ThrottledFunction<T>;\r\nfunction rateLimit<T extends (...args: any) => any>(fn: T | RateLimitOptionsWithFn<T>, options?: RateLimitOptions): ThrottledFunction<T>;\r\n\r\n// adapted from https://github.com/sindresorhus/p-throttle\r\nfunction rateLimit<T extends (...args: any) => any> (fn: T | RateLimitOptionsWithFn<T>, options: RateLimitOptions = {}) {\r\n    if (fn && (typeof fn === 'object')) {\r\n        options = Object.assign({}, fn, options);\r\n        fn = undefined as unknown as T;\r\n    }\r\n    if (!fn) {\r\n        fn = (options as RateLimitOptionsWithFn<T>).fn;\r\n    }\r\n\r\n    if (typeof fn !== 'function') {\r\n        throw new TypeError('Rate limit function is not a function');\r\n    }\r\n\r\n    const {\r\n        perSecond,\r\n        perMinute,\r\n        perHour,\r\n        signal\r\n    } = options;\r\n\r\n    let limit = parseFloat(options.limit as unknown as string) || 1;\r\n    let interval = parseInt(options.interval as unknown as string, 10);\r\n\r\n    if (perSecond) {\r\n        limit = parseFloat(perSecond as unknown as string);\r\n        interval = 1000;\r\n    }\r\n    if (perMinute) {\r\n        limit = parseFloat(perMinute as unknown as string);\r\n        interval = ONE_MINUTE;\r\n    }\r\n    if (perHour) {\r\n        limit = parseFloat(perHour as unknown as string);\r\n        interval = ONE_MINUTE * 60;\r\n    }\r\n\r\n    if (limit < 1) {\r\n        interval /= limit;\r\n        limit = 1;\r\n    } else {\r\n        // just make sure it isn't a faction for some silly reason\r\n        limit = Math.floor(limit);\r\n    }\r\n\r\n    if (!Number.isFinite(limit)) {\r\n        throw new TypeError(`Invalid limit ${limit}`);\r\n    }\r\n\r\n    if (!Number.isFinite(interval) || interval <= 0) {\r\n        throw new TypeError('Invalid interval option');\r\n    }\r\n\r\n    const queue:Map<NodeJS.Timeout, (err: Error) => any> = new Map();\r\n\r\n    let currentTick = 0;\r\n    let activeCount = 0;\r\n\r\n    type Return = ReturnType<T> extends PromiseLike<infer R> ? Promise<R> : Promise<ReturnType<T>>;\r\n\r\n    const throttled = function (...args: Parameters<T>) {\r\n        let timeout: NodeJS.Timeout;\r\n        return new Promise((resolve, reject) => {\r\n            const execute = () => {\r\n                resolve((fn as T).apply(null, args));\r\n                queue.delete(timeout);\r\n            };\r\n\r\n            const now = Date.now();\r\n\r\n            if ((now - currentTick) > interval) {\r\n                activeCount = 1;\r\n                currentTick = now;\r\n            } else if (activeCount < limit) {\r\n                activeCount++;\r\n            } else {\r\n                currentTick += interval;\r\n                activeCount = 1;\r\n            }\r\n\r\n            timeout = setTimeout(execute, currentTick - now);\r\n\r\n            // used for sending cancel error\r\n            queue.set(timeout, reject);\r\n        }) as Return;\r\n    };\r\n\r\n    let abortHandler = signal\r\n        ? () => throttled.abort(signal.reason ? `${signal.reason}` : undefined, true)\r\n        : undefined;\r\n\r\n    throttled.abort = (message: string = 'Cancelled rate-limit queue', dispose: boolean = false) => {\r\n        if (dispose) {\r\n            signal?.removeEventListener('abort', abortHandler!);\r\n        }\r\n        for (const [timeout, reject] of queue.entries()) {\r\n            clearTimeout(timeout);\r\n            reject(polyfills.createAbortError(message));\r\n        }\r\n\r\n        queue.clear();\r\n    };\r\n\r\n    signal?.addEventListener('abort', abortHandler!);\r\n\r\n    return throttled;\r\n}\r\n\r\nexport default rateLimit;\r\n","import rateLimit, {ThrottledFunction} from \"./rate-limit\";\r\n\r\nexport enum RateLimitEnum {\r\n    Get = 'get',\r\n    Post = 'post',\r\n    SearchVideos = 'searchVideos',\r\n    UploadVideo = 'uploadVideo',\r\n    AuditEndpoints = 'auditEndpoint',\r\n    UpdateVideoMetadata = 'updateVideo',\r\n    GetUsersByLoginDate = 'loginReport',\r\n    GetVideoDetails = 'videoDetails',\r\n    GetWebcastAttendeesRealtime = 'attendeesRealtime',\r\n    GetVideoViewReport = 'viewReport'\r\n}\r\n\r\nexport type RateLimits = { [K in RateLimitEnum]?: number }\r\nexport type RateLimitQueues = { [K in RateLimitEnum]?: () => Promise<void> };\r\n\r\nexport const defaultRateLimits: Required<RateLimits> = {\r\n    [RateLimitEnum.Get]: 24000,\r\n    [RateLimitEnum.Post]: 3600,\r\n    [RateLimitEnum.SearchVideos]: 120,\r\n    [RateLimitEnum.UploadVideo]: 30,\r\n    [RateLimitEnum.UpdateVideoMetadata]: 30,\r\n    [RateLimitEnum.GetVideoDetails]: 2000,\r\n    [RateLimitEnum.GetWebcastAttendeesRealtime]: 2,\r\n    [RateLimitEnum.AuditEndpoints]: 60,\r\n    [RateLimitEnum.GetUsersByLoginDate]: 10,\r\n    [RateLimitEnum.GetVideoViewReport]: 120,\r\n};\r\n\r\n// passthrough placeholder for ratelimit\r\nconst fn = () => Promise.resolve();\r\n\r\nexport function normalizeRateLimitOptions(rateLimits?: boolean | RateLimits): RateLimits {\r\n    return {\r\n        // include defaults if true or object\r\n        ...rateLimits && defaultRateLimits,\r\n        ...(typeof rateLimits === 'object') && rateLimits\r\n    };\r\n}\r\n\r\nexport function makeQueue(key: RateLimitEnum, value?: number) {\r\n    const defaultValue = defaultRateLimits[key];\r\n    const perMinute = value ?? defaultValue;\r\n    // 0, -1, null or Infinity get treated as no rate limiting\r\n    if (!isFinite(perMinute) || perMinute <= 0) {\r\n        return fn;\r\n    }\r\n    // split into 5 sec increments to even out request flow\r\n    const limit = perMinute / 12;\r\n    const interval = 5000;\r\n    return rateLimit({ fn, limit, interval });\r\n}\r\n\r\n/**\r\n * create a dict of rate limited-locks based on input options\r\n * @param rateLimits\r\n * @returns\r\n */\r\nexport function makeQueues(rateLimits: RateLimits = {}): RateLimitQueues {\r\n    const entries = (Object.keys(defaultRateLimits) as RateLimitEnum[])\r\n        .map(key => [key, makeQueue(key, rateLimits[key])]);\r\n\r\n    return Object.fromEntries(entries);\r\n}\r\n\r\nexport function clearQueues(rateLimits: RateLimitQueues, message?: string) {\r\n    const fns = Object.values(rateLimits) as Array<Partial<ThrottledFunction<() => void>>>;\r\n    fns.forEach(fn => fn.abort?.(message));\r\n}\r\n","export {default as rateLimit} from './rate-limit';\r\nexport {RateLimitEnum, RateLimits} from './rate-limit-queues';\r\n\r\nexport * from './is-utils';\r\n\r\nexport function asValidDate(val: string | Date | undefined): Date | undefined;\r\nexport function asValidDate(val: string | Date | undefined, defaultValue: Date): Date;\r\nexport function asValidDate(val: string | Date | undefined, defaultValue?: Date): Date | undefined {\r\n    if (!val) {\r\n        return defaultValue;\r\n    }\r\n    if (!(val instanceof Date)) {\r\n        val = new Date(val);\r\n    }\r\n    return isNaN(val.getTime())\r\n    ? defaultValue\r\n    : val;\r\n}\r\n\r\n/**\r\n * Retry a function multiple times, sleeping before attempts\r\n * @param {() => Promise<T>} fn function to attempt. Return value if no error thrown\r\n * @param {(err: Error, attempt: number) => boolean} [shouldRetry] callback on error.\r\n * @param {number} [maxAttempts] maximum number of retry attempts before throwing error\r\n * @param {number} [sleepMilliseconds] milliseconds to wait between attempts\r\n * @returns {Promise<T>}\r\n */\r\nexport async function retry<T, E extends Error>(fn: () => Promise<T>, shouldRetry: (err: E, attempt?: number) => boolean = () => true, maxAttempts: number = 3, sleepMilliseconds: number = 1000) {\r\n    let attempt = 0;\r\n    while (attempt < maxAttempts) {\r\n        try {\r\n            const result = await fn();\r\n            return result;\r\n        } catch (err: any) {\r\n            attempt += 1;\r\n            if (attempt >= maxAttempts || !shouldRetry(err, attempt)) {\r\n                throw err;\r\n            }\r\n            await sleep(sleepMilliseconds);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * delay async execution, with optional early exit using abort signal\r\n * @param ms\r\n * @param signal\r\n * @returns\r\n */\r\nexport async function sleep(ms: number, signal?: AbortSignal) {\r\n    return new Promise<void>(done => {\r\n        let timer: ReturnType<typeof setTimeout>;\r\n        const cleanup = () => {\r\n            clearTimeout(timer);\r\n            signal?.removeEventListener('abort', cleanup);\r\n            done();\r\n        };\r\n        timer = setTimeout(cleanup, ms);\r\n        signal?.addEventListener('abort', cleanup);\r\n    });\r\n}\r\n\r\n/** try to parse as json */\r\nexport function tryParseJson(val: string): any {\r\n    if (val !== 'null' && val) {\r\n        try {\r\n            return JSON.parse(val);\r\n        } catch (err) {\r\n            // nothing\r\n        }\r\n    }\r\n    return null;\r\n};\r\n","import { isPlainObject, tryParseJson } from './utils';\r\n\r\nexport class RevError extends Error {\r\n    status: number;\r\n    url: string;\r\n    code: string;\r\n    detail: string;\r\n    constructor(response: Response, body: { [key: string]: any; } | string) {\r\n        const {\r\n            status = 500,\r\n            statusText = '',\r\n            url\r\n        } = response;\r\n        super(`${status} ${statusText}`);\r\n        // Chrome/node specific function\r\n        if ('captureStackTrace' in Error) {\r\n            (Error as any).captureStackTrace(this, this.constructor);\r\n        }\r\n\r\n        this.status = status;\r\n        this.url = url;\r\n        this.code = `${status}`;\r\n        this.detail = statusText;\r\n        // Some Rev API responses include additional details in its body\r\n        if (isPlainObject<Record<string, string>>(body)) {\r\n            if (body.code) {\r\n                this.code = body.code;\r\n            }\r\n            if (body.detail) {\r\n                this.detail = body.detail;\r\n            }\r\n        } else if (typeof body === 'string') {\r\n            body = body.trim();\r\n            // try to parse as JSON\r\n            if (body.startsWith('{')) {\r\n                const { code, detail } = tryParseJson(body) || { };\r\n                if (code) { this.code = code; }\r\n                if (detail) { this.detail = detail; }\r\n            } else if (this.status === 429) {\r\n                this.detail = 'Too Many Requests';\r\n            } else if (/^(<!DOCTYPE|<html)/.test(body)) {\r\n                // if html then strip out the extra cruft\r\n                this.detail = body\r\n                    .replace(/.*<body>\\s+/s, '')\r\n                    .replace(/<\\/body>.*/s, '')\r\n                    .slice(0, 256);\r\n            }\r\n        }\r\n    }\r\n    get name() {\r\n        return 'RevError';\r\n    }\r\n    get [Symbol.toStringTag]() {\r\n        return 'RevError';\r\n    }\r\n    static async create(response: Response) {\r\n        let body: any;\r\n\r\n        try {\r\n            // retrieve body - constructor will decode as json\r\n            body = await response.text();\r\n        } catch (err) {\r\n            body = {\r\n                code: 'Unknown',\r\n                detail: `Unable to parse error response body: ${err}`\r\n            };\r\n        }\r\n        return new RevError(response, body);\r\n    }\r\n}\r\n\r\nexport class ScrollError extends Error {\r\n    status: number;\r\n    code: string;\r\n    detail: string;\r\n    constructor(status: number = 408, code: string = 'ScrollExpired', detail: string = 'Timeout while fetching all results in search request') {\r\n        super('Search Scroll Expired');\r\n        Error.captureStackTrace(this, this.constructor);\r\n        this.status = status;\r\n        this.code = code;\r\n        this.detail = detail;\r\n    }\r\n    get name() {\r\n        return this.constructor.name;\r\n    }\r\n    get [Symbol.toStringTag]() {\r\n        return this.constructor.name;\r\n    }\r\n}\r\n","import { Rev } from '../types/rev';\r\n\r\nexport interface IPageResponse<T> {\r\n    items: T[],\r\n    done: boolean,\r\n    total?: number,\r\n    pageCount?: number,\r\n    error?: Error\r\n}\r\n\r\n/**\r\n * Interface to iterate through results from API endpoints that return results in pages.\r\n * Use in one of three ways:\r\n * 1) Get all results as an array: await request.exec() == <array>\r\n * 2) Get each page of results: await request.nextPage() == { current, total, items: <array> }\r\n * 3) Use for await to get all results one at a time: for await (let hit of request) { }\r\n */\r\nexport abstract class PagedRequest<ItemType> implements Rev.ISearchRequest<ItemType> {\r\n    current: number;\r\n    total: number | undefined;\r\n    done: boolean;\r\n    options: Required<Rev.SearchOptions<ItemType>>;\r\n    constructor(options: Rev.SearchOptions<ItemType> = {}) {\r\n        this.options = {\r\n            maxResults: Infinity,\r\n            onProgress: (items: ItemType[], current: number, total?: number) => {},\r\n            onError: (err => { throw err; }),\r\n            onScrollError: (err => {\r\n                console.warn(\"DEPRECATED: use onError instead of onScrollError with rev search requests\");\r\n                this.options.onError(err);\r\n            }),\r\n            signal: undefined as any,\r\n            ...options\r\n        };\r\n\r\n        this.current = 0;\r\n        this.total = undefined;\r\n        this.done = false;\r\n    }\r\n    protected abstract _requestPage(): Promise<IPageResponse<ItemType>>;\r\n    /**\r\n     * Get the next page of results from API\r\n     */\r\n    async nextPage(): Promise<Rev.SearchPage<ItemType>> {\r\n        const {\r\n            onProgress,\r\n            onError,\r\n            signal\r\n        } = this.options;\r\n\r\n        if (signal?.aborted) this.done = true;\r\n\r\n        if (this.done) {\r\n            return {\r\n                current: this.current,\r\n                total: this.current,\r\n                done: this.done,\r\n                items: []\r\n            };\r\n        }\r\n\r\n        const page = await this._requestPage();\r\n        const result = this._parsePage(page);\r\n\r\n        let {\r\n            current,\r\n            items,\r\n            total,\r\n            done,\r\n            error\r\n        } = result;\r\n\r\n        onProgress(items, current, total);\r\n\r\n        if (error) {\r\n            onError(error);\r\n        }\r\n\r\n        return {\r\n            current,\r\n            items,\r\n            total,\r\n            done\r\n        };\r\n    }\r\n    /**\r\n     * update internal variables based on API response\r\n     * @param page\r\n     * @returns\r\n     */\r\n    protected _parsePage(page: IPageResponse<ItemType>) {\r\n        const { maxResults } = this.options;\r\n\r\n        let {\r\n            items = [],\r\n            done = this.done,\r\n            total,\r\n            pageCount,\r\n            error,\r\n        } = page;\r\n\r\n        // let request function set done status\r\n        if (done) {\r\n            this.done = true;\r\n        }\r\n\r\n        // update total\r\n        if (isFinite(total!)) {\r\n            this.total = Math.min(total!, maxResults);\r\n        }\r\n\r\n        if (!pageCount) {\r\n            pageCount = items.length;\r\n        }\r\n\r\n        const current = this.current;\r\n\r\n        // limit results to specified max results\r\n        if (current + pageCount >= maxResults) {\r\n            pageCount = maxResults - current;\r\n            items = items.slice(0, pageCount);\r\n            this.done = true;\r\n        }\r\n\r\n        this.current += pageCount;\r\n\r\n        if (this.current === this.total) {\r\n            this.done = true;\r\n        }\r\n\r\n        if (this.done) {\r\n            // set total to current for results where not otherwise known in advance\r\n            this.total = this.current;\r\n        }\r\n\r\n        if (error) {\r\n            this.done = true;\r\n        }\r\n\r\n        return {\r\n            current,\r\n            total: this.total,\r\n            done: this.done,\r\n            error,\r\n            items\r\n        };\r\n    }\r\n    /**\r\n     * Go through all pages of results and return as an array.\r\n     * TIP: Use the {maxResults} option to limit the maximum number of results\r\n     *\r\n     */\r\n    async exec(): Promise<ItemType[]> {\r\n        const results: ItemType[] = [];\r\n        // use async iterator\r\n        for await (let hit of this) {\r\n            results.push(hit);\r\n        }\r\n        return results;\r\n    }\r\n    async* [Symbol.asyncIterator]() {\r\n        const {signal} = this.options;\r\n        do {\r\n            const {\r\n                items\r\n            } = await this.nextPage();\r\n\r\n            for await (let hit of items) {\r\n                if (signal?.aborted) break;\r\n                yield hit;\r\n            }\r\n        } while (!this.done);\r\n    }\r\n}\r\n\r\n","import { ScrollError } from '../rev-error';\r\nimport type { RevClient } from '../rev-client';\r\nimport type { Rev } from '../types';\r\nimport { IPageResponse, PagedRequest } from './paged-request';\r\n\r\nexport async function decodeBody(response: Response, acceptType?: string | null) {\r\n    const contentType = response.headers.get('Content-Type') || acceptType || '';\r\n    const contentLength = response.headers.get('Content-Length');\r\n\r\n    if (contentType.startsWith('application/json') && contentLength !== '0') {\r\n        try {\r\n            return await response.json();\r\n        } catch (err) {\r\n            // keep going\r\n        }\r\n    }\r\n\r\n    if (contentType.startsWith('text')) {\r\n        return response.text();\r\n    }\r\n\r\n    return response.body;\r\n}\r\n\r\n/**\r\n * Interface to iterate through results from API endpoints that return results in pages.\r\n * Use in one of three ways:\r\n * 1) Get all results as an array: await request.exec() == <array>\r\n * 2) Get each page of results: await request.nextPage() == { current, total, items: <array> }\r\n * 3) Use for await to get all results one at a time: for await (let hit of request) { }\r\n */\r\nexport class SearchRequest<T> extends PagedRequest<T> {\r\n    declare options: Required<Rev.SearchOptions<T>>;\r\n    private query: Record<string, any>;\r\n    private _reqImpl: () => Promise<IPageResponse<T>>;\r\n    constructor(\r\n        rev: RevClient,\r\n        searchDefinition: Rev.SearchDefinition<T>,\r\n        query: Record<string, any> = {},\r\n        options: Rev.SearchOptions<T> = {}\r\n    ) {\r\n        super({\r\n            onProgress: (items: T[], current: number, total?: number | undefined) => {\r\n                const {hitsKey} = searchDefinition;\r\n                rev.log('debug', `searching ${hitsKey}, ${current}-${current + items.length} of ${total}...`);\r\n            },\r\n            onError: (err => { throw err; }),\r\n            ...options\r\n        });\r\n\r\n        // make copy of query object\r\n        const {\r\n            scrollId: _ignore,\r\n            ...queryOpt\r\n        } = query;\r\n        this.query = queryOpt;\r\n\r\n        this._reqImpl = this._buildReqFunction(rev, searchDefinition);\r\n\r\n        this.current = 0;\r\n        this.total = Infinity;\r\n        this.done = false;\r\n    }\r\n    protected _requestPage() {\r\n        return this._reqImpl();\r\n    }\r\n    private _buildReqFunction(rev: RevClient, searchDefinition: Rev.SearchDefinition<T>) {\r\n        const {\r\n            endpoint,\r\n            totalKey,\r\n            hitsKey,\r\n            isPost = false,\r\n            request,\r\n            transform\r\n        } = searchDefinition;\r\n\r\n        const requestFn = request || (isPost\r\n            ? rev.post.bind(rev)\r\n            : rev.get.bind(rev)\r\n        );\r\n\r\n        return async () => {\r\n\r\n            const response: Record<string, any> = await requestFn(endpoint, this.query, { responseType: 'json' });\r\n\r\n            let {\r\n                scrollId,\r\n                [totalKey]: total,\r\n                [hitsKey]: rawItems = [],\r\n                statusCode,\r\n                statusDescription\r\n            } = response;\r\n\r\n            let done = false;\r\n\r\n            this.query.scrollId = scrollId;\r\n            if (!scrollId) {\r\n                done = true;\r\n            }\r\n\r\n            const items: T[] = (typeof transform === 'function')\r\n                ? await Promise.resolve(transform(rawItems))\r\n                : rawItems;\r\n\r\n            if (items.length === 0) {\r\n                done = true;\r\n            }\r\n\r\n            // check for error response\r\n            const error = (statusCode >= 400 && !!statusDescription)\r\n                ? new ScrollError(statusCode, statusDescription)\r\n                : undefined;\r\n\r\n            return {\r\n                total,\r\n                done,\r\n                pageCount: rawItems.length,\r\n                items,\r\n                error\r\n            };\r\n        };\r\n    }\r\n}\r\n","import { Admin, Rev, Role, RegistrationField } from '..';\r\nimport type { RevClient } from '../rev-client';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\n// if true allow storing/retrieving from cached values. 'Force' means refresh value saved in cache. false means bypass cache\r\ntype CacheOption = boolean | 'Force'\r\n\r\nexport default function adminAPIFactory(rev: RevClient) {\r\n    let roles: Role.Details[];\r\n    let customFields: Admin.CustomField[];\r\n\r\n    const adminAPI = {\r\n        /**\r\n        * get mapping of role names to role IDs\r\n        * @param cache - if true allow storing/retrieving from cached values. 'Force' means refresh value saved in cache\r\n        */\r\n        async roles(cache: CacheOption = true): Promise<Role.Details[]> {\r\n            // retrieve from cached values if already stored. otherwise get from API\r\n            // if cache is 'Force' then refresh from\r\n            if (roles && cache === true) {\r\n                return roles;\r\n            }\r\n            const response = await rev.get('/api/v2/users/roles');\r\n            if (cache) {\r\n                roles = response;\r\n            }\r\n            return response;\r\n        },\r\n        /**\r\n        * Get a Role (with the role id) based on its name\r\n        * @param name Name of the Role OR RoleType. You can specify the specific enum value (preferred, only Rev 7.53+), or the localized string value in the current user's language, i.e. \"Media Viewer\" for english\r\n        * @param fromCache - if true then use previously cached Role listing (more efficient)\r\n        */\r\n        async getRoleByName(name: Role.RoleType | Role.RoleName, fromCache: CacheOption = true): Promise<Role> {\r\n            const roles = await adminAPI.roles(fromCache);\r\n            const role = roles.find(r => r.roleType === name || r.name === name);\r\n            if (!role) {\r\n                throw new TypeError(`Invalid Role Name ${name}. Valid values are: ${roles.flatMap(r => r.roleType ? [r.roleType, r.name] : [r.name]).join(', ')}`);\r\n            }\r\n            return {\r\n                id: role.id,\r\n                name: role.roleType || role.name\r\n            };\r\n        },\r\n        /**\r\n        * get list of custom fields\r\n        * @param cache - if true allow storing/retrieving from cached values. 'Force' means refresh value saved in cache\r\n        */\r\n        async customFields(cache: CacheOption = true): Promise<Admin.CustomField[]> {\r\n            // retrieve from cached values if already stored. otherwise get from API\r\n            // if cache is 'Force' then refresh from\r\n            if (customFields && cache === true) {\r\n                return customFields;\r\n            }\r\n            const response = await rev.get('/api/v2/video-fields', undefined, { responseType: 'json' });\r\n            if (cache) {\r\n                customFields = response;\r\n            }\r\n            return response;\r\n        },\r\n        /**\r\n        * Get a Custom Field based on its name\r\n        * @param name name of the Custom Field\r\n        * @param fromCache if true then use previously cached Role listing (more efficient)\r\n        */\r\n        async getCustomFieldByName(name: string, fromCache: CacheOption = true): Promise<Admin.CustomField> {\r\n            const customFields = await adminAPI.customFields(fromCache);\r\n            const field = customFields.find(cf => cf.name === name);\r\n            if (!field) {\r\n                throw new TypeError(`Invalid Custom Field Name ${name}. Valid values are: ${customFields.map(cf => cf.name).join(', ')}`);\r\n            }\r\n            return field;\r\n        },\r\n        async brandingSettings(): Promise<Admin.BrandingSettings> {\r\n            return rev.get('/api/v2/accounts/branding-settings');\r\n        },\r\n        async webcastRegistrationFields(): Promise<RegistrationField & { id: string }> {\r\n            const response = await rev.get('/api/v2/accounts/webcast-registration-fields');\r\n            return response.registrationFields;\r\n        },\r\n        async createWebcastRegistrationField(registrationField: RegistrationField.Request): Promise<string> {\r\n            const response = await rev.post('/api/v2/accounts/webcast-registration-fields', registrationField);\r\n            return response.fieldId;\r\n        },\r\n        async updateWebcastRegistrationField(fieldId: string, registrationField: Partial<RegistrationField.Request>): Promise<void> {\r\n            return rev.put(`/api/v2/accounts/webcast-registration-fields/${fieldId}`, registrationField);\r\n        },\r\n        async deleteWebcastRegistrationField(fieldId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/accounts/webcast-registration-fields/${fieldId}`);\r\n        },\r\n        listIQCreditsUsage(query: { startDate?: string | Date, endDate?: string | Date }, options?: Rev.SearchOptions<Admin.IQCreditsSession>): Rev.ISearchRequest<Admin.IQCreditsSession> {\r\n            const searchDefinition: Rev.SearchDefinition<Admin.IQCreditsSession> = {\r\n                endpoint: `/api/v2/analytics/accounts/iq-credits-usage`,\r\n                totalKey: 'total',\r\n                hitsKey: 'sessions'\r\n            };\r\n            return new SearchRequest<Admin.IQCreditsSession>(rev, searchDefinition, query, options);\r\n        },\r\n        /**\r\n        * get system health - returns 200 if system is active and responding, otherwise throws error\r\n        */\r\n        async verifySystemHealth(): Promise<boolean> {\r\n            await rev.get('/api/v2/system-health');\r\n            return true;\r\n        },\r\n        /**\r\n        * gets list of scheduled maintenance windows\r\n        */\r\n        async maintenanceSchedule(): Promise<{start: string, end: string}[]> {\r\n            const {schedules} = await rev.get('/api/v2/maintenance-schedule');\r\n            return schedules;\r\n        },\r\n        /**\r\n         * gets the user location service URL\r\n         */\r\n        async userLocationService(): Promise<{ enabled: boolean, locationUrls: string[] }> {\r\n            return rev.get('/api/v2/user-location');\r\n        },\r\n        /**\r\n         * returns an array of all expiration rules\r\n         */\r\n        async expirationRules(): Promise<Admin.ExpirationRule[]> {\r\n            return rev.get('/api/v2/expiration-rules');\r\n        },\r\n        async featureSettings(videoId?: string): Promise<Admin.FeatureSettings> {\r\n            const params = videoId ? { videoId } : undefined;\r\n            return rev.get('/api/v2/videos/feature-settings', params);\r\n        }\r\n    };\r\n    return adminAPI;\r\n}\r\n","/**\r\n * simple helper function to parse CSV data into JSON\r\n */\r\nexport function parseCSV(raw: string) {\r\n    raw = raw.replace(/(\\r\\n|\\n|\\r)/gm, '\\n').replace(/\\n$/g, '');\r\n\r\n    let cur = '';\r\n    let inQuote = false;\r\n    let fieldQuoted = false;\r\n    let field: string | undefined = '';\r\n    let row: (string | undefined)[] = [];\r\n    let out: (string | undefined)[][] = [];\r\n    let i: number;\r\n    const n = raw.length;\r\n\r\n    function processField(field: string) {\r\n        if (fieldQuoted) { return field; }\r\n        if (field === '') { return undefined; }\r\n        return field.trim();\r\n    }\r\n\r\n    for (i = 0; i < n; i += 1) {\r\n        cur = raw.charAt(i);\r\n\r\n        if (!inQuote && (cur === ',' || cur === '\\n')) {\r\n            field = processField(field);\r\n            row.push(field);\r\n            if (cur === '\\n') {\r\n                out.push(row);\r\n                row = [];\r\n            }\r\n            field = '';\r\n            fieldQuoted = false;\r\n        } else if (cur === '\"') {\r\n            if (!inQuote) {\r\n                inQuote = true;\r\n                fieldQuoted = true;\r\n            } else {\r\n                if (raw.charAt(i + 1) === '\"') {\r\n                    field += '\"';\r\n                    i += 1;\r\n                } else {\r\n                    inQuote = false;\r\n                }\r\n            }\r\n        } else {\r\n            field += cur === '\\n' ? '\\n' : cur;\r\n        }\r\n    }\r\n\r\n    // Add the last field\r\n    field = processField(field);\r\n    row.push(field);\r\n    out.push(row);\r\n\r\n    const headers: string[] = out.shift() as string[];\r\n    return out\r\n        .map((line: (string | undefined)[]) => {\r\n            const obj: Record<string, string> = { };\r\n            line\r\n                .forEach((field, i) => {\r\n                    if (field !== undefined) {\r\n                        obj[headers[i]] = field;\r\n                    }\r\n                });\r\n            return obj;\r\n        });\r\n}\r\n","import { RevClient } from '..';\r\nimport { Audit } from '../types';\r\nimport { asValidDate, tryParseJson } from '../utils';\r\nimport { IPageResponse, PagedRequest } from '../utils/paged-request';\r\nimport { parseCSV } from '../utils/parse-csv';\r\nimport { RateLimitEnum, makeQueue } from '../utils/rate-limit-queues';\r\n\r\nfunction parseEntry<T extends Audit.Entry>(line: Record<string, any>): T {\r\n    return {\r\n        messageKey: line['MessageKey'],\r\n        entityKey: line['EntityKey'],\r\n        when: line['When'],\r\n        entityId: line['EntityId'],\r\n        principal: tryParseJson(line['Principal']) || {},\r\n        message: tryParseJson(line['Message']) || {},\r\n        currentState: tryParseJson(line['CurrentState']) || {},\r\n        previousState: tryParseJson(line['PreviousState']) || {}\r\n    } as T;\r\n}\r\n\r\nexport class AuditRequest<T extends Audit.Entry> extends PagedRequest<T> {\r\n    declare options: Required<Omit<Audit.Options<T>, 'toDate' | 'fromDate'>>;\r\n    private params: {\r\n        toDate?: string,\r\n        fromDate?: string,\r\n        nextContinuationToken?: string;\r\n    }\r\n    private _req: () => Promise<IPageResponse<T>>;\r\n    constructor(\r\n        rev: RevClient,\r\n        endpoint: string,\r\n        label: string = 'audit records',\r\n        {toDate, fromDate, beforeRequest, ...options}: Audit.Options<T> = {}\r\n    ) {\r\n        super({\r\n            onProgress: (items: T[], current: number, total?: number | undefined) => {\r\n                rev.log('debug', `loading ${label}, ${current} of ${total}...`);\r\n            },\r\n            ...options\r\n        });\r\n\r\n        const {from, to} = this._parseDates(fromDate, toDate);\r\n\r\n        this.params = {\r\n            toDate: to.toISOString(),\r\n            fromDate: from.toISOString()\r\n        };\r\n\r\n        this._req = this._buildReqFunction(rev, endpoint, beforeRequest);\r\n    }\r\n    protected _requestPage() { return this._req(); }\r\n    private _buildReqFunction(rev: RevClient, endpoint: string, beforeRequest?: (request: PagedRequest<T>) => Promise<void>) {\r\n        return async () => {\r\n            await beforeRequest?.(this);\r\n            const response = await rev.request('GET', endpoint, this.params, { responseType: 'text' });\r\n\r\n            const {\r\n                body,\r\n                headers\r\n            } = response;\r\n\r\n            let items = parseCSV(body)\r\n                .map(line => parseEntry<T>(line));\r\n\r\n            const total = parseInt(headers.get('totalRecords') || '', 10);\r\n\r\n            Object.assign(this.params, {\r\n                nextContinuationToken: headers.get('nextContinuationToken') || undefined,\r\n                fromDate: headers.get('nextfromDate') || undefined\r\n            });\r\n\r\n            let done = !this.params.nextContinuationToken;\r\n\r\n\r\n            return {\r\n                items,\r\n                total,\r\n                done\r\n            } as IPageResponse<T>;\r\n        }\r\n    }\r\n    private _parseDates(fromDate?: Date | string, toDate?: Date | string) {\r\n        let to = asValidDate(toDate, new Date());\r\n\r\n        // default to one year older than toDate\r\n        const defaultFrom = new Date(to);\r\n        defaultFrom.setFullYear(to.getFullYear() - 1);\r\n\r\n        let from = asValidDate(fromDate, defaultFrom);\r\n\r\n        if (to < from) {\r\n            [to, from] = [from, to];\r\n        }\r\n        return {from, to};\r\n    }\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Audit, Rev } from '../types';\r\nimport { RateLimitEnum, makeQueue, normalizeRateLimitOptions } from '../utils/rate-limit-queues';\r\nimport { AuditRequest } from './audit-request';\r\n\r\nexport default function auditAPIFactory(rev: RevClient, optRateLimits?: Rev.Options['rateLimits']) {\r\n    // The Audit API endpoints each have their own bucket of limits, so we keep track of each one here\r\n\r\n    // parse the incoming rate limit option and pass into AuditRequest object\r\n    const requestsPerMinute = normalizeRateLimitOptions(optRateLimits)[RateLimitEnum.AuditEndpoints];\r\n    function makeOptTransform() {\r\n        if (!requestsPerMinute) return (opts?: Audit.Options<any>) => opts;\r\n        const lock = makeQueue(RateLimitEnum.AuditEndpoints, requestsPerMinute);\r\n        return (opts: Audit.Options<any> = {}) => ({\r\n            ...opts,\r\n            async beforeRequest(req: AuditRequest<any>) {\r\n                await lock();\r\n                return opts.beforeRequest?.(req);\r\n            }\r\n        } as Audit.Options<any>);\r\n    }\r\n    const locks = {\r\n        accountAccess: makeOptTransform(),\r\n        userAccess: makeOptTransform(),\r\n        accountUsers: makeOptTransform(),\r\n        user: makeOptTransform(),\r\n        accountGroups: makeOptTransform(),\r\n        group: makeOptTransform(),\r\n        accountDevices: makeOptTransform(),\r\n        device: makeOptTransform(),\r\n        accountVideos: makeOptTransform(),\r\n        video: makeOptTransform(),\r\n        accountWebcasts: makeOptTransform(),\r\n        webcast: makeOptTransform(),\r\n        principal: makeOptTransform()\r\n    };\r\n\r\n\r\n    const auditAPI = {\r\n        /**\r\n        * Logs of user login / logout / failed login activity\r\n        */\r\n        accountAccess(accountId: string, options?: Audit.Options<Audit.UserAccessEntry>) {\r\n            const opts = locks.accountAccess(options);\r\n            return new AuditRequest<Audit.UserAccessEntry>(rev, `/network/audit/accounts/${accountId}/userAccess`, 'UserAccess', opts);\r\n        },\r\n        userAccess(userId: string, accountId: string, options?: Audit.Options<Audit.UserAccessEntry>) {\r\n            const opts = locks.userAccess(options);\r\n            return new AuditRequest<Audit.UserAccessEntry>(rev, `/network/audit/accounts/${accountId}/userAccess/${userId}`, `UserAccess_${userId}`, opts);\r\n        },\r\n        /**\r\n        * Operations on User Records (create, delete, etc)\r\n        */\r\n        accountUsers(accountId: string, options?: Audit.Options<Audit.UserEntry>) {\r\n            const opts = locks.accountUsers(options);\r\n            return new AuditRequest<Audit.UserEntry>(rev, `/network/audit/accounts/${accountId}/users`, 'User', opts);\r\n        },\r\n        user(userId: string, accountId: string, options?: Audit.Options<Audit.UserEntry>) {\r\n            const opts = locks.user(options);\r\n            return new AuditRequest<Audit.UserEntry>(rev, `/network/audit/accounts/${accountId}/users/${userId}`, 'User', opts);\r\n        },\r\n        /**\r\n        * Operations on Group Records (create, delete, etc)\r\n        */\r\n        accountGroups(accountId: string, options?: Audit.Options<Audit.GroupEntry>) {\r\n            const opts = locks.accountGroups(options);\r\n            return new AuditRequest<Audit.GroupEntry>(rev, `/network/audit/accounts/${accountId}/groups`, 'Groups', opts);\r\n        },\r\n        group(groupId: string, accountId: string, options?: Audit.Options<Audit.GroupEntry>) {\r\n            const opts = locks.group(options);\r\n            return new AuditRequest<Audit.GroupEntry>(rev, `/network/audit/accounts/${accountId}/groups/${groupId}`, 'Group', opts);\r\n        },\r\n        /**\r\n        * Operations on Device Records (create, delete, etc)\r\n        */\r\n        accountDevices(accountId: string, options?: Audit.Options<Audit.DeviceEntry>) {\r\n            const opts = locks.accountDevices(options);\r\n            return new AuditRequest<Audit.DeviceEntry>(rev, `/network/audit/accounts/${accountId}/devices`, 'Devices', opts);\r\n        },\r\n        device(deviceId: string, accountId: string, options?: Audit.Options<Audit.DeviceEntry>) {\r\n            const opts = locks.device(options);\r\n            return new AuditRequest<Audit.DeviceEntry>(rev, `/network/audit/accounts/${accountId}/devices/${deviceId}`, 'Device', opts);\r\n        },\r\n        /**\r\n        * Operations on Video Records (create, delete, etc)\r\n        */\r\n        accountVideos(accountId: string, options?: Audit.Options<Audit.VideoEntry>) {\r\n            const opts = locks.accountVideos(options);\r\n            return new AuditRequest<Audit.VideoEntry>(rev, `/network/audit/accounts/${accountId}/videos`, 'Videos', opts);\r\n        },\r\n        video(videoId: string, accountId: string, options?: Audit.Options<Audit.VideoEntry>) {\r\n            const opts = locks.video(options);\r\n            return new AuditRequest<Audit.VideoEntry>(rev, `/network/audit/accounts/${accountId}/videos/${videoId}`, 'Video', opts);\r\n        },\r\n        /**\r\n        * Operations on Webcast Records (create, delete, etc)\r\n        */\r\n        accountWebcasts(accountId: string, options?: Audit.Options<Audit.WebcastEntry>) {\r\n            const opts = locks.accountWebcasts(options);\r\n            return new AuditRequest<Audit.WebcastEntry>(rev, `/network/audit/accounts/${accountId}/scheduledEvents`, 'Webcasts', opts);\r\n        },\r\n        webcast(eventId: string, accountId: string, options?: Audit.Options<Audit.WebcastEntry>) {\r\n            const opts = locks.webcast(options);\r\n            return new AuditRequest<Audit.WebcastEntry>(rev, `/network/audit/accounts/${accountId}/scheduledEvents/${eventId}`, `Webcast`, opts);\r\n        },\r\n        /**\r\n        * All operations a single user has made\r\n        */\r\n        principal(userId: string, accountId: string, options?: Audit.Options<Audit.Entry<string>>) {\r\n            const opts = locks.principal(options);\r\n            return new AuditRequest<Audit.Entry<string>>(rev, `/network/audit/accounts/${accountId}/principals/${userId}`, 'Principal', opts);\r\n        }\r\n    };\r\n\r\n    return auditAPI;\r\n}\r\n","import polyfills from '../interop/polyfills';\r\n\r\nexport function mergeHeaders(source?: HeadersInit, other?: HeadersInit) {\r\n    const merged = new polyfills.Headers(source);\r\n    new polyfills.Headers(other).forEach((value, key) => merged.set(key, value));\r\n    return merged;\r\n}\r\n","import type { OAuth } from '../types/auth';\r\nimport polyfills from '../interop/polyfills';\r\nimport type { Rev } from '../types/rev';\r\n\r\nconst PLACEHOLDER = 'http://rev';\r\n\r\nexport function getOAuth2AuthorizationUrl(config: OAuth.ServerConfig, code_challenge: string, state?: string) {\r\n    // construct URL with query params\r\n    const url = new URL('/api/v2/oauth2/authorize', config.revUrl);\r\n    url.search = new URLSearchParams({\r\n        client_id: config.oauthApiKey,\r\n        code_challenge,\r\n        response_type: 'code',\r\n        redirect_uri: config.redirectUri,\r\n        ...state && {state}\r\n    }).toString();\r\n\r\n    return url.toString();\r\n}\r\n\r\n/**\r\n *\r\n * @param codeVerifier value can be any string 43-128 characters in length, just these characters: [A-Za-z0-9._~-]\r\n */\r\nexport async function getOAuth2PKCEVerifier(codeVerifier = polyfills.randomValues(48)) {\r\n    // setup pkce\r\n    // value can be any string 43-128 characters in length, just these characters: [A-Za-z0-9._~-]\r\n    // this line uses random values to create 64char string\r\n    const codeChallenge = await polyfills.sha256Hash(codeVerifier);\r\n    return { codeVerifier, codeChallenge };\r\n}\r\n\r\n/**\r\n * Constructs the query parameters for the Rev /oauth/authorization endpoint\r\n * @param config OAuth signing settings, retrieved from Rev Admin -> Security -> API Keys page, along with revUrl\r\n * @param state optional state to pass back to redirectUri once complete\r\n * @returns A valid oauth flow endpoint + query\r\n */\r\nexport async function buildLegacyOAuthQuery(config: OAuth.Config, oauthSecret: string, state: string = '1') {\r\n    const { hmacSign } = polyfills;\r\n\r\n    const RESPONSE_TYPE = 'code';\r\n\r\n    const {\r\n        oauthApiKey: apiKey,\r\n        redirectUri\r\n    } = config;\r\n\r\n    const timestamp = new Date();\r\n    const verifier = `${apiKey}::${timestamp.toISOString()}`;\r\n\r\n    const signature = await hmacSign(verifier, oauthSecret);\r\n\r\n    return {\r\n        apiKey,\r\n        signature,\r\n        verifier,\r\n        'redirect_uri': redirectUri,\r\n        'response_type': RESPONSE_TYPE,\r\n        state\r\n    };\r\n}\r\n\r\n/**\r\n * Parse the query parameters returned to the redirectUri from Rev\r\n * @param url The URL with query parameters, or object with the query parrameters\r\n * @returns\r\n */\r\nexport function parseLegacyOAuthRedirectResponse(url: string | URL | URLSearchParams | Record<string, string>): OAuth.RedirectResponse {\r\n    if (typeof url === 'string') {\r\n        // just in case only the query string is returned, include base\r\n        url = new URL(url, PLACEHOLDER);\r\n    }\r\n\r\n    if (url instanceof URL) {\r\n        url = url.searchParams;\r\n    }\r\n\r\n    const query: Record<string, string> = (url instanceof URLSearchParams)\r\n        ? Object.fromEntries(url)\r\n        : url;\r\n\r\n    const {\r\n        'auth_code': authCode = '',\r\n        state = '',\r\n        error = undefined\r\n    } = query;\r\n\r\n    return {\r\n        isSuccess: !error,\r\n        // URL parsing parses pluses (+) as spaces, which can cause later validation to fail\r\n        authCode: `${authCode}`.replace(/ /g, '+'),\r\n        state,\r\n        error\r\n    };\r\n}\r\n\r\n/**\r\n * Format the oauth configuration and oauth response into the constructor arguments for RevClient\r\n * @param revUrl\r\n * @param config\r\n * @param response\r\n * @returns {Rev.Options}\r\n */\r\nexport function buildLegacyOAuthRevOptions(revUrl: string, config: OAuth.Config, response: OAuth.RedirectResponse): Rev.Options {\r\n    const {\r\n        oauthApiKey,\r\n        redirectUri\r\n    } = config;\r\n\r\n    const {\r\n        authCode\r\n    } = response;\r\n\r\n    return {\r\n        url: revUrl,\r\n        authCode,\r\n        oauthConfig: {\r\n            oauthApiKey,\r\n            redirectUri\r\n        }\r\n    };\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport { Auth, OAuth } from '../types/auth';\r\nimport { Rev } from '../types/rev';\r\nimport { mergeHeaders } from '../utils/merge-headers';\r\nimport {buildLegacyOAuthQuery, getOAuth2AuthorizationUrl, getOAuth2PKCEVerifier, parseLegacyOAuthRedirectResponse} from './oauth';\r\n\r\nexport default function authAPIFactory(rev: RevClient) {\r\n\r\n    const authAPI = {\r\n        async loginToken(apiKey: string, secret: string, options?: Rev.RequestOptions): Promise<Auth.LoginResponse> {\r\n            return rev.post('/api/v2/authenticate', {\r\n                apiKey,\r\n                secret\r\n            }, options);\r\n        },\r\n        async extendSessionToken(apiKey: string): Promise<Auth.ExtendResponse> {\r\n            return rev.post(`/api/v2/auth/extend-session-timeout/${apiKey}`);\r\n        },\r\n        async logoffToken(apiKey: string): Promise<void> {\r\n            return rev.delete(`/api/v2/tokens/${apiKey}`);\r\n        },\r\n        async loginUser(username: string, password: string, options?: Rev.RequestOptions): Promise<Auth.UserLoginResponse> {\r\n            return rev.post('/api/v2/user/login', {\r\n                username,\r\n                password\r\n            }, options);\r\n        },\r\n        async logoffUser(userId: string): Promise<void> {\r\n            return rev.post('/api/v2/user/logoff', { userId });\r\n        },\r\n        async extendSessionUser(userId: string): Promise<Auth.ExtendResponse> {\r\n            return rev.post('/api/v2/user/extend-session-timeout', { userId });\r\n        },\r\n        async loginJWT(jwtToken: string, options?: Rev.RequestOptions): Promise<Auth.JWTLoginResponse> {\r\n            return rev.get('/api/v2/jwtauthenticate', { jwt_token: jwtToken }, options);\r\n        },\r\n        async loginGuestRegistration(webcastId: string, jwtToken: string, options?: Rev.RequestOptions): Promise<Auth.GuestRegistrationResposne> {\r\n            const opts = {\r\n                ...options,\r\n                headers: mergeHeaders(options?.headers, { 'x-requested-with': 'xmlhttprequest' })\r\n            };\r\n            return rev.post(`/external/auth/jwt/${webcastId}`, { token: `vbrick_rev ${jwtToken}`}, options);\r\n        },\r\n        async extendSession(): Promise<Auth.ExtendResponse> {\r\n            return rev.post('/api/v2/user/extend-session');\r\n        },\r\n        async verifySession(): Promise<void> {\r\n            return rev.get('/api/v2/user/session');\r\n        },\r\n\r\n        /**\r\n         * @deprecated - use logoffUser - put here because it's a common misspelling\r\n         */\r\n        get logoutUser() { return authAPI.logoffUser; },\r\n        /**\r\n         * @deprecated - use logoffToken - put here because it's a common misspelling\r\n         */\r\n        get logoutToken() { return authAPI.logoffToken; },\r\n        /**\r\n         * generate the Authorization URL for the OAuth2 flow as well as the codeVerifier for the\r\n         * subsequent Access Token request. You *must* store the codeVerifier somehow (i.e. serverside database matched to user's state/cookies/session, or on browser SessionStorage) to be able to complete the OAuth2 login flow.\r\n         * @param config OAuth signing settings, retrieved from Rev Admin -> Security -> API Keys page\r\n         * @param oauthSecret Secret from Rev Admin -> Security. This is a DIFFERENT value from the\r\n         *                    User Secret used for API login. Do not expose client-side!\r\n         * @param state optional state to pass back to redirectUri once complete\r\n         * @param verifier the code_verifier to use when generating the code challenge. Can be any string 43-128 characters in length, just these characters: [A-Za-z0-9._~-]. If not provided then code will automatically generate a suitable value\r\n         * @returns A valid oauth flow URL + the code_verifier to save for later verification\r\n         */\r\n        async buildOAuth2Authentication(config: OAuth.ServerConfig, state: string = '1', verifier?: string): Promise<OAuth.AuthenticationData> {\r\n            const {codeChallenge, codeVerifier} = await getOAuth2PKCEVerifier(verifier);\r\n            const url = getOAuth2AuthorizationUrl(config, codeChallenge, state);\r\n            return {\r\n                url: `${url}`,\r\n                codeVerifier\r\n            };\r\n        },\r\n        async loginOAuth2(config: OAuth.Config, code: string, codeVerifier: string, options?: Rev.RequestOptions): Promise<OAuth.AuthTokenResponse> {\r\n            return rev.post('/api/v2/oauth2/token', {\r\n                // sometimes the authCode can get mangled, with the pluses in the code being replaced by spaces.\r\n                code: code.replace(/ /g, '+'),\r\n                client_id: config.oauthApiKey,\r\n                grant_type: 'authorization_code',\r\n                redirect_uri: config.redirectUri,\r\n                code_verifier: codeVerifier\r\n            }, options);\r\n        },\r\n        /**\r\n         * @deprecated\r\n         * @param config OAuth signing settings, retrieved from Rev Admin -> Security -> API Keys page\r\n         * @param oauthSecret Secret from Rev Admin -> Security. This is a DIFFERENT value from the\r\n         *                    User Secret used for API login. Do not expose client-side!\r\n         * @param state optional state to pass back to redirectUri once complete\r\n         * @returns A valid oauth flow URL\r\n         */\r\n        async buildOAuthAuthenticationURL(config: OAuth.Config, oauthSecret: string, state: string = '1'): Promise<string> {\r\n            const query = await buildLegacyOAuthQuery(config, oauthSecret, state);\r\n            const url = new URL('/api/v2/oauth/authorization', rev.url);\r\n            url.search = `${new URLSearchParams(query)}`;\r\n            return `${url}`;\r\n        },\r\n        /**\r\n         * @deprecated\r\n         */\r\n        buildOAuthAuthenticationQuery: buildLegacyOAuthQuery,\r\n        /**\r\n         * @deprecated\r\n         */\r\n        parseOAuthRedirectResponse: parseLegacyOAuthRedirectResponse,\r\n        /**\r\n         * @deprecated\r\n         * @param config\r\n         * @param authCode\r\n         * @returns\r\n         */\r\n        async loginOAuth(config: OAuth.Config, authCode: string): Promise<OAuth.LoginResponse> {\r\n            const GRANT_AUTH = 'authorization_code';\r\n\r\n            const {\r\n                oauthApiKey: apiKey,\r\n                redirectUri\r\n            } = config;\r\n\r\n            // sometimes the authCode can get mangled, with the pluses in the code\r\n            // being replaced by spaces. This is just to make sure that isn't a problem (even though already done in parseOAuthRedirectResponse)\r\n            authCode = authCode.replace(/ /g, '+');\r\n\r\n            // COMBAK I don't think it matters if rev-client is logged in and passing Authorization headers or not.\r\n            return rev.post('/api/v2/oauth/token', {\r\n                authCode,\r\n                apiKey,\r\n                redirectUri,\r\n                grantType: GRANT_AUTH\r\n            });\r\n        },\r\n        /**\r\n         * @deprecated\r\n         * @param config\r\n         * @param refreshToken\r\n         * @returns\r\n         */\r\n        async extendSessionOAuth(config: OAuth.Config, refreshToken: string): Promise<OAuth.LoginResponse> {\r\n            const GRANT_REFRESH = 'refresh_token';\r\n\r\n            const {\r\n                oauthApiKey: apiKey\r\n            } = config;\r\n\r\n            return rev.post('/api/v2/oauth/token', {\r\n                apiKey,\r\n                refreshToken,\r\n                grantType: GRANT_REFRESH\r\n            });\r\n        }\r\n    };\r\n\r\n    return authAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Category } from '../types';\r\n\r\nexport default function categoryAPIFactory(rev: RevClient) {\r\n    const categoryAPI = {\r\n        async create(category: Category.CreateRequest): Promise<Category.CreateResponse> {\r\n            return rev.post('/api/v2/categories', category, { responseType: 'json' });\r\n        },\r\n        async details(categoryId: string): Promise<Category.Details> {\r\n            return rev.get(`/api/v2/categories/${categoryId}`, undefined, { responseType: 'json' });\r\n        },\r\n        async update(categoryId: string, category: Category.EditRequest): Promise<void> {\r\n            return rev.put(`/api/v2/categories/${categoryId}`, category);\r\n        },\r\n        async delete(categoryId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/categories/${categoryId}`);\r\n        },\r\n        /**\r\n         * get list of categories in system\r\n         * @see {@link https://revdocs.vbrick.com/reference#getcategories}\r\n         */\r\n        async list(parentCategoryId?: string, includeAllDescendants?: boolean): Promise<Category[]> {\r\n            // only pass parameters if defined\r\n            const payload: Record<string, any> = Object.assign(\r\n                { },\r\n                parentCategoryId && { parentCategoryId },\r\n                includeAllDescendants != undefined && { includeAllDescendants }\r\n            );\r\n            const { categories } = await rev.get('/api/v2/categories', payload, { responseType: 'json' });\r\n            return categories;\r\n        },\r\n        /**\r\n         * get list of categories that current user has ability to add videos to\r\n         */\r\n        async listAssignable(): Promise<Category.Assignable[]> {\r\n            return rev.get('/api/v2/assignable-categories');\r\n        }\r\n    };\r\n    return categoryAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { AccessControl, Channel, Rev } from '../types';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\nexport default function channelAPIFactory(rev: RevClient) {\r\n    const channelAPI = {\r\n        async create(channel: Channel.CreateRequest): Promise<string> {\r\n            const {channelId} = await rev.post('/api/v2/channels', channel, { responseType: 'json' });\r\n            return channelId;\r\n        },\r\n        async update(channelId: string, channel: Channel.CreateRequest): Promise<void> {\r\n            return rev.put(`/api/v2/channels/${channelId}`, channel);\r\n        },\r\n        async delete(channelId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/channels/${channelId}`);\r\n        },\r\n        /**\r\n         * get list of channels in system\r\n         * @see {@link https://revdocs.vbrick.com/reference/getchannels}\r\n         */\r\n        list(start: number = 0, options: Channel.SearchOptions = {}): ChannelListRequest {\r\n            return new ChannelListRequest(rev, start, options);\r\n        },\r\n        async addMembers(channelId: string, members: Channel.Member[]) {\r\n            const operations = members\r\n                .map(member => {\r\n                    return { op: 'add', path: '/Members/-', value: member };\r\n                });\r\n            await rev.patch(`/api/v2/channels/${channelId}`, operations);\r\n        },\r\n        async removeMembers(channelId: string, members: Array<string | Channel.Member>) {\r\n            const operations = members\r\n                .map(member => {\r\n                    const entityId = typeof member === 'string'\r\n                        ? member\r\n                        : member.id;\r\n\r\n                    return { op: 'remove', path: '/Members', value: entityId };\r\n                });\r\n\r\n            await rev.patch(`/api/v2/channels/${channelId}`, operations);\r\n        },\r\n        /**\r\n         *\r\n         * @param {string} [searchText]\r\n         * @param {Rev.SearchOptions<{Id: string, Name: string}>} [options]\r\n         */\r\n        search(searchText?: string, options: Rev.AccessEntitySearchOptions<AccessControl.SearchHit> & { type?: AccessControl.EntitySearchType } = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/access-entity${options?.assignable ? '/assignable' : ''}`,\r\n                totalKey: 'totalEntities',\r\n                hitsKey: 'accessEntities'\r\n            };\r\n            const query: Record<string, any> = {\r\n                type: options.type || 'Channel',\r\n                ...searchText && {q: searchText}\r\n            };\r\n            return new SearchRequest<AccessControl.SearchHit>(rev, searchDefinition, query, options);\r\n        }\r\n    };\r\n    return channelAPI;\r\n}\r\n\r\nexport class ChannelListRequest implements Rev.ISearchRequest<Channel.SearchHit> {\r\n    currentPage: number;\r\n    current: number;\r\n    total: number;\r\n    done: boolean;\r\n    options: Required<Pick<Channel.SearchOptions, 'maxResults' | 'onProgress' | 'pageSize'>>;\r\n    private _req: () => Promise<Channel.SearchHit[]>;\r\n    constructor(rev: RevClient, start: number = 0, options: Channel.SearchOptions = {}) {\r\n        this.options = {\r\n            maxResults: Infinity,\r\n            pageSize: 10,\r\n            onProgress: (items: Channel.SearchHit[], current: number, total: number) => {\r\n                rev.log('debug', `loading channels, ${current} of ${total}...`);\r\n            },\r\n            ...options\r\n        };\r\n\r\n        this.current = 0;\r\n        this.total = Infinity;\r\n        this.done = false;\r\n        this.currentPage = start;\r\n\r\n        this._req = () => {\r\n            const params = {\r\n                page: this.currentPage,\r\n                size: this.options.pageSize\r\n            };\r\n            return rev.get('/api/v2/channels', params, { responseType: 'json' });\r\n        }\r\n\r\n    }\r\n    async nextPage() {\r\n        const {\r\n            maxResults,\r\n            onProgress\r\n        } = this.options;\r\n\r\n        let current = this.current;\r\n\r\n        let items: Channel.SearchHit[] = await this._req();\r\n\r\n        if (!Array.isArray(items) || items.length == 0) {\r\n            this.done = true;\r\n            items = [];\r\n        }\r\n\r\n        if (current + items.length >= maxResults) {\r\n            const delta = maxResults - current;\r\n            items = items.slice(0, delta);\r\n            this.done = true;\r\n        }\r\n        this.total = current + items.length;\r\n\r\n        onProgress(items, current, this.total);\r\n\r\n        this.current += items.length;\r\n        this.currentPage += 1;\r\n\r\n        return {\r\n            current,\r\n            total: this.total,\r\n            done: this.done,\r\n            items\r\n        };\r\n    }\r\n    /**\r\n     * Go through all pages of results and return as an array.\r\n     * TIP: Use the {maxResults} option to limit the maximum number of results\r\n     *\r\n     */\r\n    async exec(): Promise<Channel.SearchHit[]> {\r\n        const results: Channel.SearchHit[] = [];\r\n        // use async iterator\r\n        for await (let hit of this) {\r\n            results.push(hit);\r\n        }\r\n        return results;\r\n    }\r\n    async* [Symbol.asyncIterator]() {\r\n        do {\r\n            const {\r\n                items\r\n            } = await this.nextPage();\r\n\r\n            for await (let hit of items) {\r\n                yield hit;\r\n            }\r\n        } while (!this.done);\r\n    }\r\n}\r\n","import type { RevClient } from '../rev-client';\r\n\r\nimport type { Device } from '../types';\r\n\r\nexport default function deviceAPIFactory(rev: RevClient) {\r\n    const deviceAPI = {\r\n        async listDMEs(): Promise<Device.DmeDetails[]> {\r\n            const response = await rev.get('/api/v2/devices/dmes');\r\n            return response.devices;\r\n        },\r\n        async listZoneDevices(): Promise<Device.ZoneDevice[]> {\r\n            const response = await rev.get('/api/v2/zonedevices');\r\n            return response.devices;\r\n        },\r\n        async listPresentationProfiles(): Promise<Device.PresentationProfile[]> {\r\n            return rev.get('/api/v2/presentation-profiles');\r\n        },\r\n        async add(dme: Device.CreateDMERequest) {\r\n            return rev.post('/api/v2/devices/dmes', dme);\r\n        },\r\n        async healthStatus(deviceId: string): Promise<Device.DmeHealthStatus> {\r\n            return rev.get(`/api/v2/devices/dmes/${deviceId}/health-status`);\r\n        },\r\n        async delete(deviceId: string) {\r\n            return rev.delete(`/api/v2/devices/dmes/${deviceId}`);\r\n        },\r\n        async rebootDME(deviceId: string) {\r\n            return rev.put(`/api/v2/devices/dmes/${deviceId}`);\r\n        }\r\n    };\r\n    return deviceAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Group, Rev, User } from '../types';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\nexport default function groupAPIFactory(rev: RevClient) {\r\n    const groupAPI = {\r\n        /**\r\n         * Create a group. Returns the resulting Group ID\r\n         * @param {{name: string, userIds: string[], roleIds: string[]}} group\r\n         * @returns {Promise<string>}\r\n         */\r\n        async create(group: Group.CreateRequest) {\r\n            const { groupId } = await rev.post('/api/v2/groups', group);\r\n            return groupId;\r\n        },\r\n        async delete(groupId: string) {\r\n            await rev.delete(`/api/v2/groups/${groupId}`);\r\n        },\r\n        async details(groupId: string): Promise<Group.Details> {\r\n            return rev.get(`/api/v2/groups/${groupId}`);\r\n        },\r\n        /**\r\n         *\r\n         * @param {string} [searchText]\r\n         * @param {Rev.SearchOptions<{Id: string, Name: string}>} [options]\r\n         */\r\n        search(searchText?: string, options: Rev.AccessEntitySearchOptions<Group.SearchHit> = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/access-entity${options?.assignable ? '/assignable' : ''}`,\r\n                totalKey: 'totalEntities',\r\n                hitsKey: 'accessEntities',\r\n                transform: (hits: Group.RawSearchHit[]) => hits.map(formatGroupSearchHit)\r\n            };\r\n            const query: Record<string, any> = { type: 'group' };\r\n            if (searchText) {\r\n                query.q = searchText;\r\n            }\r\n            return new SearchRequest<Group.SearchHit>(rev, searchDefinition, query, options);\r\n        },\r\n        list(options: Rev.SearchOptions<Group.SearchHit> = { }) {\r\n            return groupAPI.search(undefined, options);\r\n        },\r\n        listUsers(groupId: string, options: Rev.SearchOptions<string> = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/groups/${groupId}/users`,\r\n                totalKey: 'totalUsers',\r\n                hitsKey: 'userIds'\r\n            };\r\n            return new SearchRequest<string>(rev, searchDefinition, undefined, options);\r\n        },\r\n        /**\r\n         * get all users in a group with full details\r\n         * @param groupId\r\n         * @param options\r\n         * @returns\r\n         */\r\n        listUserDetails(groupId: string, options: Rev.SearchOptions<User & { error?: Error }> = { }) {\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/groups/${groupId}/users`,\r\n                totalKey: 'totalUsers',\r\n                hitsKey: 'userIds',\r\n                transform: async (userIds: string[]) => {\r\n                    const result: User[] = [];\r\n                    for (let userId of userIds) {\r\n                        const out: User & {error: Error} = { userId } as any;\r\n                        try {\r\n                            const details = await rev.user.details(userId);\r\n                            Object.assign(out, details);\r\n                        } catch (error: any) {\r\n                            out.error = error;\r\n                        }\r\n                        result.push(out);\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n            return new SearchRequest<User & {userId: string, error?: Error}>(rev, searchDefinition, undefined, options);\r\n        }\r\n    };\r\n    return groupAPI;\r\n}\r\n\r\nfunction formatGroupSearchHit(hit: Group.RawSearchHit): Group.SearchHit {\r\n    return {\r\n        id: hit.Id,\r\n        name: hit.Name,\r\n        entityType: hit.EntityType\r\n    };\r\n}\r\n","import RevClient from \"..\";\r\nimport { Playlist, Rev, Video } from \"../types\";\r\nimport { RateLimitEnum } from \"../utils\";\r\nimport { SearchRequest } from \"../utils/request-utils\";\r\n\r\nfunction getSummaryFromResponse<T extends Record<string, any>>(response: T, hitsKey: string) {\r\n    const ignoreKeys = ['scrollId', 'statusCode', 'statusDescription'];\r\n\r\n    const summary = Object.fromEntries(Object.entries(response)\r\n        .filter(([key, value]) => {\r\n            // don't include arrays or scroll type keys\r\n            return !(key === hitsKey || ignoreKeys.includes(key) || Array.isArray(value));\r\n        }));\r\n    return summary as Omit<Playlist.DetailsResponse, 'scrollId'>;\r\n}\r\n\r\nexport class PlaylistDetailsRequest extends SearchRequest<Video.Details> {\r\n    playlist: Playlist & Omit<Playlist.DetailsResponse, 'scrollId'> = {} as any;\r\n    get playlistName() {\r\n        return this.playlist.playlistDetails?.name || this.playlist.name;\r\n    }\r\n    get searchFilter() {\r\n        return this.playlist?.playlistType === 'Dynamic'\r\n            ? this.playlist.playlistDetails?.searchFilter || this.playlist.searchFilter\r\n            : undefined;\r\n    }\r\n    constructor(rev: RevClient, playlistId: string, query: { count?: number } = {}, options: Rev.SearchOptions<Video.Details> = {}) {\r\n        const searchDefinition: Rev.SearchDefinition<Video.Details> = {\r\n            endpoint: `/api/v2/playlists/${playlistId}`,\r\n            totalKey: 'totalVideos',\r\n            hitsKey: 'videos',\r\n            // get summary from initial response\r\n            request: async (endpoint, query, options) => {\r\n                await rev.session.queueRequest(RateLimitEnum.SearchVideos);\r\n                const response = await rev.get<Playlist.DetailsResponse>(endpoint, query, options);\r\n                // checking for playlist for possible future compatibility\r\n                Object.assign(this.playlist, getSummaryFromResponse(response, 'videos'));\r\n                return response;\r\n            }\r\n        };\r\n        super(rev, searchDefinition, query, options);\r\n    }\r\n    async getPlaylistInfo() {\r\n        // set maxResults to 0 to mark request as done, since first page of sessions will be lost\r\n        this.options.maxResults = 0;\r\n        // must get first page of results to load summary data\r\n        const {items: videos} = await this.nextPage();\r\n\r\n        return {\r\n            ...this.playlist,\r\n            ...this.playlist?.playlistDetails,\r\n            videos,\r\n            playlistName: this.playlistName,\r\n            searchFilter: this.searchFilter\r\n        };\r\n    }\r\n}\r\n\r\n","import type { RevClient } from '../rev-client';\r\nimport { Rev, Video } from '../types';\r\nimport type { Playlist } from '../types/playlist';\r\nimport { isPlainObject } from '../utils';\r\nimport { SearchRequest } from '../utils/request-utils';\r\nimport { PlaylistDetailsRequest } from './playlist-details-request';\r\n\r\nexport default function playlistAPIFactory(rev: RevClient) {\r\n    const playlistAPI = {\r\n        async create(name: string, videos: string[] | Video.SearchOptions): Promise<string> {\r\n            const isStatic = Array.isArray(videos);\r\n            const payload = isStatic\r\n                ? { name, playlistType: 'Static', videoIds: videos }\r\n                : { name, playlistType: 'Dynamic', playlistDetails: videos };\r\n\r\n            const { playlistId } = await rev.post('/api/v2/playlists', payload, { responseType: 'json' });\r\n            return playlistId;\r\n        },\r\n        async details(playlistId: string, query: { count?: number }): Promise<Playlist.DetailsResponse> {\r\n            return rev.get(`/api/v2/playlists/${playlistId}`, query, { responseType: 'json' });\r\n        },\r\n        listVideos(playlistId: string, query: { count?: number }, options?: Rev.SearchOptions<Video.Details>)  {\r\n            return new PlaylistDetailsRequest(rev, playlistId, query, options);\r\n        },\r\n        async update(playlistId: string, actions: Playlist.UpdateAction[] | Video.SearchOptions): Promise<void> {\r\n            const isStatic = Array.isArray(actions);\r\n            const payload = isStatic\r\n                ? { playlistVideoDetails: actions }\r\n                : { playlistDetails: actions };\r\n\r\n            return rev.put(`/api/v2/playlists/${playlistId}`, payload);\r\n        },\r\n        async updateFeatured(actions: Playlist.UpdateAction[]): Promise<void> {\r\n            const payload = {\r\n                playlistVideoDetails: actions\r\n            };\r\n            return rev.put(`/api/v2/playlists/featured-playlist`, payload);\r\n        },\r\n        async delete(playlistId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/playlists/${playlistId}`);\r\n        },\r\n        /**\r\n         * get list of playlists in system.\r\n         * NOTE: return type is slightly different than API documentation\r\n         * @see {@link https://revdocs.vbrick.com/reference#getplaylists}\r\n         */\r\n        async list(): Promise<Playlist.List> {\r\n            // ensure raw response is in consistent format\r\n            function parsePlaylist(entry: Record<string, string> & { videos: any; }): Playlist {\r\n                const {\r\n                    id,\r\n                    playlistId,\r\n                    featurePlaylistId,\r\n                    featuredPlaylist,\r\n                    name,\r\n                    playlistName,\r\n                    ...extra\r\n                } = entry;\r\n                return {\r\n                    ...(extra as any),\r\n                    id: id ?? playlistId ?? featurePlaylistId ?? featuredPlaylist,\r\n                    name: name ?? playlistName,\r\n                    videos: entry.videos ?? entry.Videos as any,\r\n                };\r\n            }\r\n\r\n            const rawResult = await rev.get('/api/v2/playlists', undefined, { responseType: 'json' });\r\n            // rawResult may return in strange format, so cleanup and return consistent output\r\n\r\n            const hasFeatured = !Array.isArray(rawResult);\r\n\r\n            const rawPlaylists = hasFeatured\r\n                ? rawResult.playlists\r\n                : rawResult;\r\n\r\n\r\n            const output: Playlist.List = {\r\n                playlists: rawPlaylists.map(parsePlaylist)\r\n            };\r\n\r\n            if (hasFeatured) {\r\n                if (isPlainObject(rawResult.featuredPlaylist)) {\r\n                    output.featuredPlaylist = parsePlaylist(rawResult.featuredPlaylist);\r\n                } else if (Array.isArray(rawResult.videos)) {\r\n                    output.featuredPlaylist = parsePlaylist(rawResult);\r\n                }\r\n            }\r\n            return output;\r\n        }\r\n    };\r\n    return playlistAPI;\r\n}\r\n","import { Recording } from '..';\r\nimport type { RevClient } from '../rev-client';\r\nimport { Video } from '../types/video';\r\nimport { isPlainObject } from '../utils';\r\n\r\nexport default function recordingAPIFactory(rev: RevClient) {\r\n    const recordingAPI = {\r\n        async startVideoConferenceRecording(sipAddress: string, sipPin: string, title?: string): Promise<string> {\r\n            const { videoId } = await rev.post('/api/v2/vc/start-recording', { title, sipAddress, sipPin }, { responseType: 'json' });\r\n            return videoId;\r\n        },\r\n        async getVideoConferenceStatus(videoId: string): Promise<Video.StatusEnum> {\r\n            const { status } = await rev.get(`/api/v2/vc/recording-status/${videoId}`, undefined, { responseType: 'json' });\r\n            return status;\r\n        },\r\n        async stopVideoConferenceRecording(videoId: string): Promise<string> {\r\n            const payload = { videoId };\r\n            const result = await rev.post(`/api/v2/vc/stop-recording`, payload, { responseType: 'json' });\r\n            return isPlainObject<{ message: string; }>(result)\r\n                ? result.message\r\n                : result;\r\n        },\r\n        async startPresentationProfileRecording(request: Recording.PresentationProfileRequest): Promise<string> {\r\n            const { scheduledRecordingId } = await rev.post('/api/v2/pp/start-recording', request, { responseType: 'json' });\r\n            return scheduledRecordingId;\r\n        },\r\n        async getPresentationProfileStatus(recordingId: string): Promise<Recording.PresentationProfileStatus> {\r\n            const result = await rev.get(`/api/v2/pp/recording-status/${recordingId}`, undefined, { responseType: 'json' });\r\n            return result;\r\n        },\r\n        async stopPresentationProfileRecording(recordingId: string): Promise<Recording.StopPresentationProfileResponse> {\r\n            const payload = { scheduledRecordingId: recordingId };\r\n            const result = await rev.get(`/api/v2/vc/recording-status`, payload, { responseType: 'json' });\r\n            return result;\r\n        }\r\n    };\r\n    return recordingAPI;\r\n}\r\n","import polyfills from '../interop/polyfills';\r\nimport type { RevClient } from '../rev-client';\r\nimport { Rev, Transcription, Video } from '../types';\r\nimport { LiteralString } from '../types/rev';\r\nimport { RateLimitEnum } from '../utils';\r\nimport { appendFileToForm, appendJSONToForm, uploadMultipart } from '../utils/multipart-utils';\r\n\r\nfunction splitOptions(options: Rev.UploadFileOptions & Rev.RequestOptions, defaultType?: string) {\r\n    const {\r\n        filename,\r\n        contentType,\r\n        contentLength,\r\n        useChunkedTransfer,\r\n        defaultContentType = defaultType,\r\n        ...requestOptions\r\n    } = options;\r\n\r\n    return {\r\n        requestOptions,\r\n        uploadOptions: {\r\n            filename,\r\n            contentType,\r\n            contentLength,\r\n            useChunkedTransfer,\r\n            defaultContentType\r\n        }\r\n    };\r\n}\r\n\r\ntype PresentationChaptersOptions = Rev.RequestOptions & Rev.UploadFileOptions & {\r\n    contentType?: LiteralString<'application/vnd.ms-powerpoint'\r\n                | 'application/vnd.openxmlformats-officedocument.presentationml.presentation'>;\r\n};\r\n\r\ntype TranscriptionOptions = Rev.RequestOptions & Rev.UploadFileOptions & {\r\n    contentType?: LiteralString<'text/plain'\r\n                | 'text/vtt'\r\n                | 'application/x-subrip'>;\r\n};\r\n\r\ntype SupplementalOptions = Rev.RequestOptions & Omit<Rev.UploadFileOptions, 'filename' | 'contentLength'> & {\r\n    contentType?: LiteralString<'application/x-7z-compressed'\r\n                | 'text/csv'\r\n                | 'application/msword'\r\n                | 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'\r\n                | 'image/gif'\r\n                | 'image/jpeg'\r\n                | 'application/pdf'\r\n                | 'image/png'\r\n                | 'application/vnd.ms-powerpoint'\r\n                | 'application/vnd.openxmlformats-officedocument.presentationml.presentation'\r\n                | 'application/x-rar-compressed'\r\n                | 'image/svg+xml'\r\n                | 'text/plain'\r\n                | 'application/vnd.ms-excel'\r\n                | 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'\r\n                | 'application/zip'>\r\n};\r\n\r\nexport default function uploadAPIFactory(rev: RevClient) {\r\n    const { FormData } = polyfills;\r\n\r\n\r\n\r\n    const uploadAPI = {\r\n        /**\r\n         * Upload a video, and returns the resulting video ID\r\n         */\r\n        async video(\r\n            file: Rev.FileUploadType,\r\n            metadata: Video.UploadMetadata = { uploader: rev.session.username ?? '' },\r\n            options: Rev.UploadFileOptions = {}): Promise<string> {\r\n\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'video/mp4');\r\n\r\n            // prepare payload\r\n            const form = new FormData();\r\n\r\n            // at bare minimum the uploader needs to be defined\r\n            if (!metadata.uploader) {\r\n                // if using username login then uploader can be set to current user\r\n                const defaultUsername = rev.session.username;\r\n                if (defaultUsername) {\r\n                    metadata.uploader = defaultUsername;\r\n                } else {\r\n                    throw new TypeError('metadata must include uploader parameter');\r\n                }\r\n            }\r\n\r\n            // add video metadata to body (as json)\r\n            appendJSONToForm(form, 'video', metadata);\r\n\r\n            // append file (works around some node's form-data library quirks)\r\n            const filePayload = await appendFileToForm(form, 'VideoFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await rev.session.queueRequest(RateLimitEnum.UploadVideo);\r\n\r\n            const { videoId } = await uploadMultipart(rev, 'POST', '/api/v2/uploads/videos', form, filePayload, requestOptions);\r\n            return videoId;\r\n        },\r\n        async replaceVideo(videoId: string, file: Rev.FileUploadType, options: Rev.UploadFileOptions = {}): Promise<void> {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'video/mp4');\r\n            const form = new FormData();\r\n            const filePayload = await appendFileToForm(form, 'VideoFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Replacing ${videoId} with ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await rev.session.queueRequest(RateLimitEnum.UploadVideo);\r\n\r\n            await uploadMultipart(rev, 'PUT', `/api/v2/uploads/videos/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        async transcription(videoId: string, file: Rev.FileUploadType, language: Transcription.SupportedLanguage = 'en', options: TranscriptionOptions = { }): Promise<void> {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'application/x-subrip');\r\n\r\n            const form = new FormData();\r\n            const lang = language.toLowerCase();\r\n\r\n            // uploads will fail if files end with the txt file extension, so make sure it's set to a valid value\r\n            if (uploadOptions.contentType === 'text/plain' || uploadOptions.filename?.endsWith('txt')) {\r\n                uploadOptions.filename = `${uploadOptions.filename || 'upload'}.srt`;\r\n            }\r\n\r\n            const filePayload = await appendFileToForm(form, 'File', file, uploadOptions);\r\n            const metadata = {\r\n                files: [\r\n                    { language: lang, fileName: filePayload.filename }\r\n                ]\r\n            };\r\n            appendJSONToForm(form, 'TranscriptionFiles', metadata);\r\n\r\n            rev.log('info', `Uploading transcription to ${videoId} (${lang} ${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/transcription-files/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        async supplementalFile(videoId: string, file: Rev.FileUploadType, options: SupplementalOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options);\r\n\r\n            const form = new FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'File', file, uploadOptions);\r\n            const metadata = {\r\n                files: [\r\n                    { fileName: filePayload.filename }\r\n                ]\r\n            };\r\n            appendJSONToForm(form, 'SupplementalFiles', metadata);\r\n\r\n            rev.log('info', `Uploading supplemental content to ${videoId} (${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/supplemental-files/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        /**\r\n         *\r\n         * @param videoId id of video to add chapters to\r\n         * @param chapters list of chapters. Must have time value and one of title or imageFile\r\n         * @param action replace = POST/replace existing with this payload\r\n         *               append = PUT/add or edit without removing existing\r\n         * @param options  additional upload + request options\r\n         */\r\n        async chapters(videoId: string, chapters: Video.Chapter.Request[], action: 'append' | 'replace' = 'replace', options: Rev.RequestOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/png');\r\n\r\n            const form = new FormData();\r\n\r\n            type ChapterPayload = Video.Chapter.Request & {imageFile?: string};\r\n\r\n            const metadata: {chapters: ChapterPayload[]} = {\r\n                chapters: []\r\n            };\r\n\r\n            for (let chapter of chapters) {\r\n                const {\r\n                    title, time, imageFile, uploadOptions: fileUploadOptions = {}\r\n                } = chapter;\r\n\r\n                const chapterEntry: ChapterPayload = { time };\r\n                if (title) {\r\n                    chapterEntry.title = title;\r\n                }\r\n                if (imageFile) {\r\n                    const filePayload = await appendFileToForm(form, 'File', imageFile, { ...uploadOptions, ...fileUploadOptions });\r\n                    // add image filename based on what was appended to form\r\n                    chapterEntry.imageFile = filePayload.filename;\r\n                }\r\n                metadata.chapters.push(chapterEntry);\r\n            }\r\n\r\n            appendJSONToForm(form, 'Chapters', metadata);\r\n\r\n            rev.log('info', `${action === 'replace' ? 'Uploading' : 'Updating'} ${metadata.chapters.length} chapters to ${videoId}`);\r\n\r\n            const method = action === 'replace'\r\n                ? 'POST'\r\n                : 'PUT';\r\n\r\n            await uploadMultipart(rev, method, `/api/v2/uploads/chapters/${videoId}`, form, uploadOptions, requestOptions);\r\n        },\r\n        async thumbnail(videoId: string, file: Rev.FileUploadType, options: Rev.RequestOptions & Rev.UploadFileOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'image/jpeg');\r\n\r\n            const form = new FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'ThumbnailFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading thumbnail for ${videoId} (${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/images/${videoId}`, form, filePayload, requestOptions);\r\n        },\r\n        async presentationChapters(videoId: string, file: Rev.FileUploadType, options: PresentationChaptersOptions = {}) {\r\n            const { uploadOptions, requestOptions } = splitOptions(options, 'application/vnd.ms-powerpoint');\r\n\r\n            const form = new FormData();\r\n\r\n            const filePayload = await appendFileToForm(form, 'PresentationFile', file, uploadOptions);\r\n\r\n            rev.log('info', `Uploading presentation for ${videoId} (${filePayload.filename} (${filePayload.contentType})`);\r\n\r\n            await uploadMultipart(rev, 'POST', `/api/v2/uploads/video-presentations/${videoId}`, form, filePayload, requestOptions);\r\n        }\r\n    };\r\n\r\n    return uploadAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Rev, User } from '../types';\r\nimport { LiteralString } from '../types/rev';\r\nimport { RateLimitEnum, isPlainObject } from '../utils';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\nexport default function userAPIFactory(rev: RevClient) {\r\n    /**\r\n     * Get details about a specific user\r\n     * @param userLookupValue default is search by userId\r\n     * @param type            specify that userLookupValue is email or\r\n     *                        username instead of userId\r\n     * @returns {User}        User details\r\n     */\r\n    function details(userId: string, options?: User.DetailsOptions): Promise<User>;\r\n    /** @deprecated - use {lookupType: 'username'} */\r\n    function details(username: string, type: 'username'): Promise<User>;\r\n    /** @deprecated - use {lookupType: 'email'} */\r\n    function details(email: string, type: 'email'): Promise<User>;\r\n    async function details(userLookupValue: string, options: User.DetailsLookup | User.DetailsOptions = {}) {\r\n        const {lookupType, ...requestOptions} = typeof options === 'string'\r\n            ? {lookupType: options}\r\n            : options;\r\n\r\n        const query = (lookupType === 'username' || lookupType === 'email')\r\n            ? { type: lookupType }\r\n            : undefined;\r\n\r\n        return rev.get<User>(`/api/v2/users/${userLookupValue}`, query, {...requestOptions, responseType: 'json'});\r\n    }\r\n\r\n    const userAPI = {\r\n        /**\r\n         * get the list of roles available in the system (with role name and id)\r\n         */\r\n        get roles() {\r\n            return rev.admin.roles;\r\n        },\r\n        /**\r\n         * Create a new User in Rev\r\n         * @param user\r\n         * @returns the User ID of the created user\r\n         */\r\n        async create(user: User.Request): Promise<string> {\r\n            const { userId } = await rev.post('/api/v2/users', user);\r\n            return userId;\r\n        },\r\n        async delete(userId: string): Promise<void> {\r\n            await rev.delete(`/api/v2/users/${userId}`);\r\n        },\r\n        details,\r\n        /**\r\n         * Use the Details API to get information about currently logged in user\r\n         * @param requestOptions\r\n         */\r\n        async profile(requestOptions?: Rev.RequestOptions) {\r\n            return details('me', requestOptions);\r\n        },\r\n        /**\r\n         * get user details by username\r\n         * @deprecated - use details(username, {lookupType: 'username'})\r\n         */\r\n        async getByUsername(username: string) {\r\n            // equivalent to rev.get<User>(`/api/v2/users/${username}`, { type: 'username' });\r\n            return userAPI.details(username, {lookupType: 'username'});\r\n        },\r\n        /**\r\n         * get user details by email address\r\n         * @deprecated - use details(email, 'email')\r\n         */\r\n        async getByEmail(email: string) {\r\n            return userAPI.details(email, {lookupType: 'email'});\r\n        },\r\n        /**\r\n         * Check if user exists in the system. Instead of throwing on a 401/403 error if\r\n         * user does not exist it returns false. Returns user details if does exist,\r\n         * instead of just true\r\n         * @param userLookupValue userId, username, or email\r\n         * @param type\r\n         * @returns User if exists, otherwise false\r\n         */\r\n        async exists(userLookupValue: string, type?: User.DetailsLookup): Promise<User | false> {\r\n            const query = (type === 'username' || type === 'email')\r\n            ? { type }\r\n            : undefined;\r\n\r\n            const response = await rev.request<User>('GET', `/api/v2/users/${userLookupValue}`, query, { responseType: 'json', throwHttpErrors: false });\r\n\r\n            return response.statusCode === 200\r\n                ? response.body\r\n                : false;\r\n        },\r\n        /**\r\n         * use PATCH API to add user to the specified group\r\n         * https://revdocs.vbrick.com/reference#edituserdetails\r\n         * @param {string} userId id of user in question\r\n         * @param {string} groupId\r\n         * @returns {Promise<void>}\r\n         */\r\n        async addToGroup(userId: string, groupId: string) {\r\n            const operations = [\r\n                { op: 'add', path: '/GroupIds/-', value: groupId }\r\n            ];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        /**\r\n         * use PATCH API to add user to the specified group\r\n         * https://revdocs.vbrick.com/reference#edituserdetails\r\n         * @param {string} userId id of user in question\r\n         * @param {string} groupId\r\n         * @returns {Promise<void>}\r\n         */\r\n        async removeFromGroup(userId: string, groupId: string) {\r\n            const operations = [\r\n                { op: 'remove', path: '/GroupIds', value: groupId }\r\n            ];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        async suspend(userId: string) {\r\n            const operations = [{ op: 'replace', path: '/ItemStatus', value: 'Suspended' }];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        async unsuspend(userId: string) {\r\n            const operations = [{ op: 'replace', path: '/ItemStatus', value: 'Active' }];\r\n            await rev.patch(`/api/v2/users/${userId}`, operations);\r\n        },\r\n        /**\r\n         * search for users based on text query. Leave blank to return all users.\r\n         *\r\n         * @param {string} [searchText]\r\n         * @param {Rev.SearchOptions<{Id: string, Name: string}>} [options]\r\n         */\r\n        search(searchText?: string, options: Rev.AccessEntitySearchOptions<User.SearchHit> = { }): Rev.ISearchRequest<User.SearchHit> {\r\n            const {\r\n                assignable = false\r\n            } = options;\r\n            const searchDefinition = {\r\n                endpoint: `/api/v2/search/access-entity${assignable ? '/assignable' : ''}`,\r\n                totalKey: 'totalEntities',\r\n                hitsKey: 'accessEntities',\r\n                /**\r\n                 * the result of this search is uppercase keys. This transforms them to camelcase to match other API responses\r\n                 */\r\n                transform: (items: User.RawSearchHit[]) => items.map(formatUserSearchHit)\r\n            };\r\n            const query: Record<string, any> = { type: 'user' };\r\n            if (searchText) {\r\n                query.q = searchText;\r\n            }\r\n            return new SearchRequest(rev, searchDefinition, query, options);\r\n        },\r\n        /**\r\n         * Returns the channel and category subscriptions for the user making the API call.\r\n         */\r\n        async listSubscriptions(): Promise<{ categories: string[], channels: string[] }> {\r\n            return rev.get('/api/v2/users/subscriptions');\r\n        },\r\n        async subscribe(id: string, type: LiteralString<'Channel' | 'Category'>): Promise<void> {\r\n            return rev.post('/api/v2/users/subscribe', { id, type });\r\n        },\r\n        /**\r\n         * Unsubscribe from specific channel or category.\r\n         */\r\n        async unsubscribe(id: string, type: LiteralString<'Channel' | 'Category'>): Promise<void> {\r\n            return rev.post('/api/v2/users/unsubscribe', { id, type });\r\n        },\r\n        async getNotifications(unread: boolean = false): Promise<{ count: number, notifications: User.Notification[]}> {\r\n            return rev.get('/api/v2/users/notifications', { unread });\r\n        },\r\n        /**\r\n         *\r\n         * @param notificationId If notificationId not provided, then all notifications for the user are marked as read.\r\n         */\r\n        async markNotificationRead(notificationId?: string): Promise<void> {\r\n            await rev.put('/api/v2/users/notifications', notificationId ? {notificationId} : undefined);\r\n        },\r\n        async loginReport(sortField?: User.LoginReportSort, sortOrder?: Rev.SortDirection): Promise<User.LoginReportEntry[]> {\r\n            const query = {\r\n                ...sortField && { sortField },\r\n                ...sortOrder && { sortOrder }\r\n            };\r\n            await rev.session.queueRequest(RateLimitEnum.GetUsersByLoginDate);\r\n            const {Users} = await rev.get('/api/v2/users/login-report', query, { responseType: 'json' });\r\n            return Users;\r\n        }\r\n    };\r\n    return userAPI;\r\n}\r\n\r\nfunction formatUserSearchHit(hit: User.RawSearchHit): User.SearchHit {\r\n    return {\r\n        userId: hit.Id,\r\n        entityType: hit.EntityType,\r\n        email: hit.Email,\r\n        firstname: hit.FirstName,\r\n        lastname: hit.LastName,\r\n        username: hit.UserName,\r\n        profileImageUri: hit.ProfileImageUri\r\n    };\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport type { Rev, Video } from '../types';\r\nimport { RateLimitEnum, asValidDate, isPlainObject } from '../utils';\r\nimport { IPageResponse, PagedRequest } from '../utils/paged-request';\r\n\r\n\r\nconst DEFAULT_INCREMENT: number = 30;\r\nconst DEFAULT_SORT: Rev.SortDirection = 'asc';\r\n\r\nfunction addDays(date: Date, numDays: number) {\r\n    const d = new Date(date.getTime());\r\n    d.setDate(d.getDate() + numDays);\r\n    return d;\r\n}\r\n\r\nfunction parseOptions(options: Video.VideoReportOptions) {\r\n    let {\r\n        incrementDays = DEFAULT_INCREMENT,\r\n        sortDirection = DEFAULT_SORT,\r\n        videoIds,\r\n        startDate,\r\n        endDate,\r\n        ...otherOptions\r\n    } = options;\r\n\r\n    // clamp increment to 1 minute - 30 days range\r\n    incrementDays = Math.min(\r\n        Math.max(\r\n            1 / 24 / 60,\r\n            parseFloat(incrementDays as any) || DEFAULT_INCREMENT\r\n        ),\r\n        30\r\n    );\r\n\r\n    // API expects videoIds as a string\r\n    if (Array.isArray(videoIds)) {\r\n        videoIds = videoIds\r\n            .map(s => s.trim())\r\n            .filter(Boolean)\r\n            .join(',');\r\n    }\r\n\r\n    return {\r\n        incrementDays, sortDirection, videoIds,\r\n        ...parseDates(startDate, endDate),\r\n        ...otherOptions\r\n    };\r\n}\r\n\r\nfunction parseDates(startArg: string | Date | undefined, endArg: string | Date | undefined) {\r\n    const now = new Date();\r\n    let startDate = asValidDate(startArg);\r\n    let endDate = asValidDate(endArg);\r\n\r\n    // if no end date set then use now, or startDate + 30 days\r\n    if (!endDate) {\r\n        if (startDate) {\r\n            endDate = addDays(startDate, 30);\r\n            if (endDate.getTime() > now.getTime()) {\r\n                endDate = now;\r\n            }\r\n        } else {\r\n            endDate = now;\r\n        }\r\n    }\r\n    // if no start/beginning date then use end - 30 days\r\n    if (!startDate)\r\n    {\r\n        startDate = addDays(endDate, -30);\r\n    }\r\n\r\n    // make sure times aren't swapped\r\n    if (startDate.getTime() > endDate.getTime()) {\r\n        [startDate, endDate] = [endDate, startDate];\r\n    }\r\n    return { startDate, endDate };\r\n}\r\n\r\nexport class VideoReportRequest extends PagedRequest<Video.VideoReportEntry> {\r\n    declare options: Required<ReturnType<typeof parseOptions>>;\r\n    private _rev: RevClient;\r\n    private _endpoint: string;\r\n    constructor(rev: RevClient, options: Video.VideoReportOptions = {}, endpoint = \"/api/v2/videos/report\") {\r\n        super(parseOptions(options));\r\n        this._endpoint = endpoint;\r\n\r\n        this._rev = rev;\r\n    }\r\n    protected async _requestPage() {\r\n        const { startDate, endDate } = this;\r\n        const {incrementDays, sortDirection, videoIds } = this.options;\r\n        const isAscending = sortDirection === 'asc';\r\n\r\n        let rangeStart = startDate;\r\n        let rangeEnd = endDate;\r\n        let done = false;\r\n\r\n        if (isAscending) {\r\n            rangeEnd = addDays(rangeStart, incrementDays);\r\n            //\r\n            if (rangeEnd >= endDate) {\r\n                done = true;\r\n                rangeEnd = endDate;\r\n            }\r\n        } else {\r\n            rangeStart = addDays(rangeEnd, -1 * incrementDays);\r\n            if (rangeStart <= startDate)\r\n            {\r\n                done = true;\r\n                rangeStart = startDate;\r\n            }\r\n        }\r\n\r\n        const query: Record<string, string> = {\r\n            after: rangeStart.toJSON(),\r\n            before: rangeEnd.toJSON()\r\n        };\r\n        if (videoIds) {\r\n            query.videoIds = videoIds;\r\n        }\r\n        await this._rev.session.queueRequest(RateLimitEnum.GetVideoViewReport);\r\n        const items: Video.VideoReportEntry[] = await this._rev.get(this._endpoint, query, { responseType: \"json\" });\r\n\r\n        // go to next date range\r\n        if (!done) {\r\n            if (isAscending) {\r\n                this.startDate = rangeEnd;\r\n            } else {\r\n                this.endDate = rangeStart;\r\n            }\r\n        }\r\n\r\n        return {\r\n            items,\r\n            done\r\n        };\r\n    }\r\n    get startDate() { return this.options.startDate; }\r\n    set startDate(value) { this.options.startDate = value; }\r\n    get endDate() { return this.options.endDate; }\r\n    set endDate(value) { this.options.endDate = value; }\r\n}\r\n\r\nexport function videoReportAPI(rev: RevClient) {\r\n    function report(options?: Video.VideoReportOptions): VideoReportRequest;\r\n    function report(videoId: string, options?: Video.VideoReportOptions): VideoReportRequest;\r\n    function report(videoId?: string | Video.VideoReportOptions, options: Video.VideoReportOptions = {}): VideoReportRequest {\r\n        if (isPlainObject(videoId)) {\r\n            options = videoId;\r\n        } else if (typeof videoId === 'string') {\r\n            options = {\r\n                ...(options ?? {}),\r\n                videoIds: videoId\r\n            };\r\n        }\r\n        return new VideoReportRequest(rev, options, '/api/v2/videos/report');\r\n    }\r\n    function summaryStatistics(videoId: string, startDate?: undefined, endDate?: undefined, options?: Rev.RequestOptions): Promise<Video.SummaryStatistics>;\r\n    function summaryStatistics(videoId: string, startDate: Date | string, endDate?: undefined, options?: Rev.RequestOptions): Promise<Video.SummaryStatistics>;\r\n    function summaryStatistics(videoId: string, startDate: Date | string, endDate: Date | string, options?: Rev.RequestOptions): Promise<Video.SummaryStatistics>;\r\n    function summaryStatistics(videoId: string, startDate?: Date | string, endDate: Date | string | undefined = new Date(), options?: Rev.RequestOptions): Promise<Video.SummaryStatistics> {\r\n        const payload = startDate\r\n            ? { after: new Date(startDate).toISOString(), before: new Date(endDate ?? Date.now()) }\r\n            : undefined;\r\n        return rev.get(`/api/v2/videos/${videoId}/summary-statistics`, payload, options);\r\n    }\r\n    return {\r\n        report,\r\n        uniqueSessionsReport(videoId: string, options: Video.UniqueSessionReportOptions = {}) {\r\n            return new VideoReportRequest(rev, options, `/api/v2/videos/${videoId}/report`);\r\n        },\r\n        summaryStatistics\r\n    };\r\n}\r\n","import { Rev, Transcription, Video } from \"../types\";\r\nimport { isPlainObject } from \"../utils\";\r\nimport type {RevClient} from \"../rev-client\";\r\n\r\nexport function videoDownloadAPI(rev: RevClient) {\r\n    /**\r\n     * Download a video. does not parse the output body. Note that content is sent as transfer-encoding: chunked;\r\n     * @param videoId\r\n     * @returns\r\n     */\r\n    async function download<T = ReadableStream>(videoId: string, options: Rev.RequestOptions = {}): Promise<Rev.Response<T>> {\r\n        const response = await rev.request<T>('GET', `/api/v2/videos/${videoId}/download`, undefined, {\r\n            responseType: 'stream',\r\n            ...options\r\n        });\r\n        return response;\r\n    }\r\n\r\n    /**\r\n     * download specified chapter. The chapter object has an imageUrl, this just wraps the functionality and adds the authorization header\r\n     * @param videoId\r\n     * @param chapter chapter object returned from the video.chapters(videoId) API call\r\n     * @returns\r\n     */\r\n    async function downloadChapter(chapter: Video.Chapter, options: Rev.RequestOptions = {}) {\r\n        const {imageUrl} = chapter;\r\n        const { body } = await rev.request<Blob>('GET', imageUrl, undefined, { responseType: 'blob', ...options });\r\n        return body;\r\n    }\r\n\r\n    async function downloadSupplemental<T = Blob>(file: Video.SupplementalFile, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadSupplemental<T = Blob>(videoId: string, fileId: string, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadSupplemental<T = Blob>(videoId: Video.SupplementalFile | string, fileId?: string | Rev.RequestOptions, options?: Rev.RequestOptions): Promise<T> {\r\n        const endpoint = isPlainObject(videoId)\r\n            ? videoId.downloadUrl\r\n            : `/api/v2/videos/${videoId}/supplemental-files/${fileId}`;\r\n\r\n        const opts = isPlainObject(fileId) ? fileId : options;\r\n\r\n        const { body } = await rev.request<T>('GET', endpoint, undefined, { responseType: 'blob', ...opts });\r\n        return body;\r\n    }\r\n\r\n    async function downloadTranscription<T = Blob>(transcription: Transcription, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadTranscription<T = Blob>(videoId: string, language: string, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadTranscription<T = Blob>(videoId: Transcription | string, language?: string | Rev.RequestOptions, options?: Rev.RequestOptions): Promise<T> {\r\n        const endpoint = isPlainObject(videoId)\r\n            ? videoId.downloadUrl\r\n            : `/api/v2/videos/${videoId}/transcription-files/${language}`;\r\n\r\n        const opts = isPlainObject(language) ? language : options;\r\n\r\n        const { body } = await rev.request<T>('GET', endpoint, undefined, { responseType: 'blob', ...opts });\r\n        return body;\r\n    }\r\n\r\n    async function downloadThumbnail<T = Blob>(thumbnailUrl: string, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadThumbnail<T = Blob>(query: { imageId: string }, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadThumbnail<T = Blob>(query: { videoId: string }, options?: Rev.RequestOptions): Promise<T>;\r\n    async function downloadThumbnail<T = Blob>(query: string | { videoId?: string, imageId?: string; }, options: Rev.RequestOptions = {}): Promise<T> {\r\n        let {\r\n            videoId = '',\r\n            imageId = ''\r\n        } = typeof query === 'string'\r\n                ? { imageId: query }\r\n                : query;\r\n\r\n        if (!(videoId || imageId)) {\r\n            throw new TypeError('No video/image specified to download');\r\n        }\r\n\r\n        let thumbnailUrl: string = '';\r\n        \r\n        if (videoId) {\r\n            thumbnailUrl = `/api/v2/videos/${videoId}/thumbnail`;\r\n            // allow getting from api if only know the video ID\r\n            // imageId = (await rev.get<{video: Video.Playback}>(`/api/v2/videos/${videoId}/playback-url`)).video.thumbnailUrl;\r\n        } else if (imageId.startsWith('http')) {\r\n            // thumbnail URI\r\n            thumbnailUrl = `${imageId}${!imageId.endsWith('.jpg') ? '.jpg' : ''}`;\r\n        } else {\r\n            thumbnailUrl = `/api/v2/media/videos/thumbnails/${imageId}.jpg`;\r\n        }\r\n\r\n        const { body } = await rev.request<T>('GET', thumbnailUrl, undefined, { responseType: 'blob', ...options });\r\n        return body;\r\n    }\r\n\r\n    return {\r\n        download,\r\n        downloadChapter,\r\n        downloadSupplemental,\r\n        downloadThumbnail,\r\n        downloadTranscription\r\n    };\r\n}\r\n","import { Rev, Video } from \"../types\";\r\nimport type { ExternalAccess } from '../types/video';\r\nimport { isPlainObject } from \"../utils\";\r\nimport type {RevClient} from \"../rev-client\";\r\nimport { SearchRequest } from \"../utils/request-utils\";\r\n\r\nexport function videoExternalAccessAPI(rev: RevClient) {\r\n    return {\r\n        /**\r\n         *\r\n         * @param videoId Id of video to submit emails for external access\r\n         * @param q       Search string\r\n         * @param options search options\r\n         * @returns\r\n         */\r\n        listExternalAccess(videoId: string, q?: string, options?: Rev.SearchOptions<ExternalAccess>): Rev.ISearchRequest<ExternalAccess> {\r\n            const searchDefinition: Rev.SearchDefinition<ExternalAccess> = {\r\n                endpoint: `/api/v2/videos/${videoId}/external-access`,\r\n                /** NOTE: this API doesn't actually return a total, so this will always be undefined */\r\n                totalKey: 'total',\r\n                hitsKey: 'items'\r\n            };\r\n            const payload = q ? {q} : undefined;\r\n            return new SearchRequest<ExternalAccess>(rev, searchDefinition, payload, options);\r\n        },\r\n        async createExternalAccess(videoId: string, request: ExternalAccess.Request): Promise<void> {\r\n            await rev.post(`/api/v2/videos/${videoId}/external-access`, request);\r\n        },\r\n        async renewExternalAccess(videoId: string, request: Pick<ExternalAccess.Request, 'emails' | 'noEmail'>): Promise<ExternalAccess.RenewResponse> {\r\n            return rev.put(`/api/v2/videos/${videoId}/external-access`, request);\r\n        },\r\n        async deleteExternalAccess(videoId: string, request: Pick<ExternalAccess.Request, 'emails'>) {\r\n            return rev.delete(`/api/v2/videos/${videoId}/external-access`, request);\r\n        },\r\n        async revokeExternalAccess(videoId: string, request: Pick<ExternalAccess.Request, 'emails'>) {\r\n            return rev.put<void>(`/api/v2/videos/${videoId}/external-access/revoke`, request);\r\n        }\r\n    }\r\n}\r\n","import { RevError } from '../rev-error';\r\nimport type { RevClient } from '../rev-client';\r\nimport { Video, Rev, Admin, Transcription } from '../types';\r\nimport { SearchRequest } from '../utils/request-utils';\r\nimport { videoReportAPI } from './video-report-request';\r\nimport { videoDownloadAPI } from './video-download';\r\nimport { RateLimitEnum, sleep } from '../utils';\r\nimport { mergeHeaders } from '../utils/merge-headers';\r\nimport { videoExternalAccessAPI } from './video-external-access';\r\n\r\ntype VideoSearchDetailedItem = Video.SearchHit & (Video.Details | { error?: Error });\r\n\r\nexport default function videoAPIFactory(rev: RevClient) {\r\n    /** get list of comments on a video\r\n         * set showAll param to true to include un-redacted values of comments (admin only)\r\n         */\r\n    function comments(videoId: string): Promise<Video.Comment[]>;\r\n    function comments(videoId: string, showAll: true): Promise<Video.Comment.Unredacted[]>;\r\n    async function comments(videoId: string, showAll: boolean = false): Promise<Video.Comment[] | Video.Comment.Unredacted[]> {\r\n        const response = await rev.get<Video.Comment.ListResponse>(`/api/v2/videos/${videoId}/comments`, showAll ? { showAll: 'true' } : undefined);\r\n        return response.comments;\r\n    }\r\n\r\n    const videoAPI = {\r\n        /**\r\n         * This is an example of using the video Patch API to only update a single field\r\n         * @param videoId\r\n         * @param title\r\n         */\r\n        async setTitle(videoId: string, title: string) {\r\n            const payload = [{ op: 'add', path: '/Title', value: title }];\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.patch(`/api/v2/videos/${videoId}`, payload);\r\n        },\r\n        /**\r\n         * Use the Patch API to update a single Custom Field.\r\n         * @param videoId - id of video to update\r\n         * @param customField - the custom field object (with id and value)\r\n         */\r\n        async setCustomField(videoId: string, customField: Pick<Admin.CustomField, 'id' | 'value'>) {\r\n            // LEGACY behavior, only relevant for Rev < 7.48\r\n            // const payload = [\r\n            //     { op: 'remove', path: '/customFields', value: customField.id },\r\n            //     { op: 'add', path: '/customFields/-', value: customField }\r\n            // ];\r\n            const payload = [{\r\n                op: 'replace',\r\n                path: '/CustomFields',\r\n                value: [customField]\r\n            }];\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.patch(`/api/v2/videos/${videoId}`, payload);\r\n        },\r\n        async delete(videoId: string, options?: Rev.RequestOptions): Promise<void> {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.delete(`/api/v2/videos/${videoId}`, undefined, options);\r\n            // TIP: If delete returns a 401 then video has likely already been deleted\r\n        },\r\n        /**\r\n         * get processing status of a video\r\n         * @param videoId\r\n         */\r\n        async status(videoId: string, options?: Rev.RequestOptions): Promise<Video.StatusResponse> {\r\n            return rev.get(`/api/v2/videos/${videoId}/status`, undefined, options);\r\n        },\r\n        async details(videoId: string, options?: Rev.RequestOptions): Promise<Video.Details> {\r\n            await rev.session.queueRequest(RateLimitEnum.GetVideoDetails);\r\n            return rev.get(`/api/v2/videos/${videoId}/details`, undefined, options);\r\n        },\r\n        async update(videoId: string, metadata: Video.UpdateRequest, options?: Rev.RequestOptions): Promise<void> {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.put(`/api/v2/videos/${videoId}`, metadata, options);\r\n        },\r\n        comments,\r\n        async chapters(videoId: string, options?: Rev.RequestOptions): Promise<Video.Chapter[]> {\r\n            try {\r\n                const {chapters} = await rev.get<{chapters: Video.Chapter[]}>(`/api/v2/videos/${videoId}/chapters`, undefined, options);\r\n                return chapters;\r\n            } catch (err) {\r\n                // if no chapters then this api returns a 400 response\r\n                if (err instanceof RevError && err.code === \"NoVideoChapters\") {\r\n                    return [];\r\n                }\r\n                throw err;\r\n            }\r\n        },\r\n        async supplementalFiles(videoId: string, options?: Rev.RequestOptions): Promise<Video.SupplementalFile[]> {\r\n            const {supplementalFiles} = await rev.get(`/api/v2/videos/${videoId}/supplemental-files`, undefined, options);\r\n            return supplementalFiles;\r\n        },\r\n        // async deleteSupplementalFiles(videoId: string, fileId: string | string[]): Promise<void> {\r\n        //     const fileIds = Array.isArray(fileId)\r\n        //         ? fileId.join(',')\r\n        //         : fileId\r\n        //     await rev.delete(`/api/v2/videos/${videoId}/supplemental-files`, { fileIds });\r\n        // },\r\n        async transcriptions(videoId: string, options?: Rev.RequestOptions): Promise<Transcription[]> {\r\n            const {transcriptionFiles} = await rev.get(`/api/v2/videos/${videoId}/transcription-files`, undefined, options);\r\n            return transcriptionFiles;\r\n        },\r\n        get upload() {\r\n            return rev.upload.video;\r\n        },\r\n        get replace() {\r\n            return rev.upload.replaceVideo;\r\n        },\r\n        async migrate(videoId: string, options: Video.MigrateRequest, requestOptions?: Rev.RequestOptions) {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.put(`/api/v2/videos/${videoId}/migration`, options, requestOptions);\r\n        },\r\n        /**\r\n         * search for videos, return as one big list. leave blank to get all videos in the account\r\n         */\r\n        search(query: Video.SearchOptions = { }, options: Rev.SearchOptions<Video.SearchHit> = { }): Rev.ISearchRequest<Video.SearchHit> {\r\n            const searchDefinition: Rev.SearchDefinition<Video.SearchHit> = {\r\n                endpoint: '/api/v2/videos/search',\r\n                totalKey: 'totalVideos',\r\n                hitsKey: 'videos',\r\n                async request(endpoint, query, options) {\r\n                    await rev.session.queueRequest(RateLimitEnum.SearchVideos);\r\n                    return rev.get(endpoint, query, options);\r\n                }\r\n            };\r\n            const request = new SearchRequest<Video.SearchHit>(rev, searchDefinition, query, options);\r\n            return request;\r\n        },\r\n        /**\r\n         * Example of using the video search API to search for videos, then getting\r\n         * the details of each video\r\n         * @deprecated This method can cause timeouts if iterating through a very\r\n         *             large number of results, as the search scroll cursor has a\r\n         *             timeout of ~5 minutes. Consider getting all search results\r\n         *             first, then getting details\r\n         * @param query\r\n         * @param options\r\n         */\r\n        searchDetailed(\r\n            query: Video.SearchOptions = { },\r\n            options: Rev.SearchOptions<VideoSearchDetailedItem> = { }\r\n        ): Rev.ISearchRequest<VideoSearchDetailedItem> {\r\n            const searchDefinition = {\r\n                endpoint: '/api/v2/videos/search',\r\n                totalKey: 'totalVideos',\r\n                hitsKey: 'videos',\r\n                transform: async (videos: Video.SearchHit[]) => {\r\n                    const result: Array<Video.SearchHit & (Video.Details & { error?: Error; })> = [];\r\n                    for (let rawVideo of videos) {\r\n                        const out: Video.SearchHit & (Video.Details & { error?: Error; }) = rawVideo as any;\r\n                        try {\r\n                            const details = await videoAPI.details(rawVideo.id);\r\n                            Object.assign(out, details);\r\n                        } catch (error: any) {\r\n                            out.error = error;\r\n                        }\r\n                        result.push(out);\r\n                    }\r\n                    return result;\r\n                }\r\n            };\r\n            const request = new SearchRequest<Video.SearchHit>(rev, searchDefinition, query, options);\r\n            return request;\r\n        },\r\n        async playbackInfo(videoId: string): Promise<Video.Playback> {\r\n            const { video } = await rev.get(`/api/v2/videos/${videoId}/playback-url`);\r\n            return video;\r\n        },\r\n        async playbackUrls(videoId: string, {ip, userAgent}: Video.PlaybackUrlsRequest = {}, options?: Rev.RequestOptions): Promise<Video.PlaybackUrlsResponse> {\r\n            const query = ip ? { ip } : undefined;\r\n\r\n            const opts: Rev.RequestOptions = {\r\n                ...options,\r\n                ...userAgent && {\r\n                    headers: mergeHeaders(options?.headers, { 'User-Agent': userAgent })\r\n                },\r\n                responseType: 'json'\r\n            };\r\n\r\n            return rev.get(`/api/v2/videos/${videoId}/playback-urls`, query, opts);\r\n        },\r\n        ...videoDownloadAPI(rev),\r\n        ...videoReportAPI(rev),\r\n        ...videoExternalAccessAPI(rev),\r\n        /**\r\n         * @deprecated Use edit() API instead\r\n         */\r\n        async trim(videoId: string, removedSegments: Array<{ start: string, end: string }>) {\r\n            await rev.session.queueRequest(RateLimitEnum.UploadVideo);\r\n            return rev.post(`/api/v2/videos/${videoId}/trim`, removedSegments);\r\n        },\r\n        async convertDualStreamToSwitched(videoId: string) {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            return rev.put<void>(`/api/v2/videos/${videoId}/convert-dual-streams-to-switched-stream`);\r\n        },\r\n        async edit(videoId: string, keepRanges: Video.ClipRequest[], options?: Rev.RequestOptions) {\r\n            await rev.session.queueRequest(RateLimitEnum.UploadVideo);\r\n            return rev.post(`/api/v2/videos/${videoId}/edit`, keepRanges, options);\r\n        },\r\n        async patch(videoId: string, operations: Rev.PatchOperation[], options?: Rev.RequestOptions) {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.patch(`/api/v2/videos/${videoId}`, operations, options);\r\n        },\r\n        async generateMetadata(videoId: string, fields: Video.MetadataGenerationField[] = [\"all\"], options?: Rev.RequestOptions) {\r\n            await rev.session.queueRequest(RateLimitEnum.UpdateVideoMetadata);\r\n            await rev.put(`/api/v2/videos/${videoId}/generate-metadata`, { metadataGenerationFields: fields }, options);\r\n        },\r\n        async generateMetadataStatus(videoId: string, options?: Rev.RequestOptions): Promise<Video.MetadataGenerationStatus> {\r\n            const {description} = await rev.get(`/api/v2/videos/${videoId}/metadata-generation-status`, undefined, {...options, responseType: 'json'});\r\n            return description.status;\r\n        },\r\n        async transcribe(videoId: string, language: Transcription.SupportedLanguage | Transcription.Request, options?: Rev.RequestOptions): Promise<Transcription.Status> {\r\n            const payload = typeof language === 'string' ? { language } : language;\r\n            return rev.post(`/api/v2/videos/${videoId}/transcription`, payload, {...options, responseType: 'json'})\r\n        },\r\n        async transcriptionStatus(videoId: string, transcriptionId: string, options?: Rev.RequestOptions): Promise<Transcription.Status> {\r\n            return rev.get(`/api/v2/videos/${videoId}/transcriptions/${transcriptionId}/status`, undefined, {...options, responseType: 'json'});\r\n        },\r\n        async translate(videoId: string, source: Transcription.TranslateSource, target: Transcription.SupportedLanguage | Transcription.SupportedLanguage[], options?: Rev.RequestOptions): Promise<Transcription.TranslateResult> {\r\n            const payload = {\r\n                sourceLanguage: source,\r\n                targetLanguages: typeof target === 'string' ? [target] : target\r\n            };\r\n            return rev.post(`/api/v2/videos/${videoId}/translations`, payload, {...options, responseType: 'json'});\r\n        },\r\n        async getTranslationStatus(videoId: string, language: Transcription.SupportedLanguage, options?: Rev.RequestOptions): Promise<Transcription.StatusEnum> {\r\n            const {status} = await rev.get(`/api/v2/videos/${videoId}/translations/${language}/status`, undefined, {...options, responseType: 'json'});\r\n            return status;\r\n        },\r\n        async deleteTranscription(videoId: string, language?: Transcription.SupportedLanguage | Transcription.SupportedLanguage[], options?: Rev.RequestOptions): Promise<void> {\r\n            const locale = Array.isArray(language) ? language.map(s => s.trim()).join(',') : language;\r\n            await rev.delete(`/api/v2/videos/${videoId}`, locale ? {locale} : undefined, options);\r\n        },\r\n        /**\r\n         * Helper - update the audio language for a video. If index isn't specified then update the default language\r\n         * @param video - videoId or video details (from video.details api call)\r\n         * @param language - language to use, for example 'en'\r\n         * @param trackIndex - index of audio track - if not supplied then update default or first index\r\n         * @param options\r\n         */\r\n        async setAudioLanguage(video: string | Video.Details, language: Transcription.SupportedLanguage, trackIndex?: number, options?: Rev.RequestOptions): Promise<void> {\r\n            const {id, audioTracks = []} = typeof video === 'string' ? { id: video } : video;\r\n            let index = trackIndex ?? audioTracks.findIndex(t => t.isDefault === true) ?? 0;\r\n            const op: Rev.PatchOperation = {\r\n                op: 'replace',\r\n                path: `/audioTracks/${index}`,\r\n                value: { track: index, languageId: language }\r\n            };\r\n            await videoAPI.patch(id, [op], options);\r\n        },\r\n        /**\r\n         * Helper - wait for video transcode to complete.\r\n         * This doesn't indicate that a video is playable, rather that all transcoding jobs are complete\r\n         * @param videoId\r\n         * @param options\r\n         */\r\n        async waitTranscode(videoId: string, options: Video.WaitTranscodeOptions = {}, requestOptions?: Rev.RequestOptions): Promise<Video.StatusResponse> {\r\n            const {\r\n                pollIntervalSeconds = 30,\r\n                timeoutMinutes = 240,\r\n                signal,\r\n                ignorePlaybackWhileTranscoding = true,\r\n                onProgress,\r\n                onError = (error: Error) => { throw error; }\r\n            } = options;\r\n\r\n            const ONE_MINUTE = 1000 * 60;\r\n            const timeoutDate = (Date.now() + (timeoutMinutes * ONE_MINUTE) || Infinity);\r\n            // sanity check: ensure at least 5 seconds between calls\r\n            const pollInterval = Math.max((pollIntervalSeconds || 30) * 1000, 5000);\r\n            // set as failed initially in case no error thrown but times out\r\n            let statusResponse = {status: 'UploadFailed'} as Video.StatusResponse;\r\n            while (Date.now() < timeoutDate && !signal?.aborted) {\r\n                // call video status API\r\n                try {\r\n                    statusResponse = await videoAPI.status(videoId, options);\r\n                    let {\r\n                        isProcessing,\r\n                        overallProgress = 0,\r\n                        status\r\n                    } = statusResponse;\r\n\r\n                    // status may be Ready initially even though about to go to Processing state\r\n                    if (ignorePlaybackWhileTranscoding && status === 'Ready' && isProcessing) {\r\n                        status = 'Processing';\r\n                    }\r\n\r\n                    // force failed processing as finished\r\n                    if (status === 'ProcessingFailed') {\r\n                        overallProgress = 1;\r\n                        isProcessing = false;\r\n                    }\r\n                    // override API values as per above\r\n                    Object.assign(statusResponse, { status, overallProgress, isProcessing });\r\n\r\n                    onProgress?.(statusResponse);\r\n\r\n                    // isProcessing is initially false, so wait till overallProgress changes to complete\r\n                    if (overallProgress === 1 && !isProcessing) {\r\n                        // finished, break out of loop\r\n                        break;\r\n                    }\r\n                } catch (error) {\r\n                    // by default will throw error\r\n                    await Promise.resolve(onError(error as Error));\r\n                }\r\n\r\n                await sleep(pollInterval, signal);\r\n            }\r\n            return statusResponse;\r\n        }\r\n    };\r\n    return videoAPI;\r\n}\r\n","import { RevError } from '..';\r\nimport type { RevClient } from '../rev-client';\r\nimport type { Rev } from '../types';\r\nimport { Webcast } from '../types/webcast';\r\nimport { RateLimitEnum } from '../utils';\r\nimport { SearchRequest } from '../utils/request-utils';\r\n\r\nfunction getSummaryFromResponse<T extends Record<string, any>>(response: T, hitsKey: string) {\r\n    const ignoreKeys = ['scrollId', 'statusCode', 'statusDescription'];\r\n\r\n    const summary = Object.fromEntries(Object.entries(response)\r\n        .filter(([key, value]) => {\r\n            // don't include arrays or scroll type keys\r\n            return !(key === hitsKey || ignoreKeys.includes(key) || Array.isArray(value));\r\n        }));\r\n    return summary;\r\n}\r\n\r\nexport class RealtimeReportRequest<T extends Webcast.RealtimeSession = Webcast.RealtimeSession> extends SearchRequest<T> {\r\n    declare summary: Webcast.RealtimeSummary;\r\n    constructor(rev: RevClient, eventId: string, query: Webcast.RealtimeRequest = {}, options: Rev.SearchOptions<T> = {}) {\r\n        const searchDefinition: Rev.SearchDefinition<T> = {\r\n            endpoint: `/api/v2/scheduled-events/${eventId}/real-time/attendees`,\r\n            totalKey: 'total',\r\n            hitsKey: 'attendees',\r\n            // get summary from initial response\r\n            request: async (endpoint, query, options) => {\r\n                await rev.session.queueRequest(RateLimitEnum.GetWebcastAttendeesRealtime);\r\n                const response = await rev.post<Webcast.RealtimeSummary>(endpoint, query, options);\r\n\r\n                const summary = getSummaryFromResponse(response, 'attendees');\r\n                Object.assign(this.summary, summary);\r\n                return response;\r\n            }\r\n        };\r\n        super(rev, searchDefinition, query, options);\r\n        this.summary = {} as any;\r\n    }\r\n    /**\r\n     * get the aggregate statistics only, instead of actual session data.\r\n     * @returns {Webcast.PostEventSummary}\r\n     */\r\n    async getSummary() {\r\n        // set maxResults to 0 to mark request as done, since first page of sessions will be lost\r\n        this.options.maxResults = 0;\r\n        // must get first page of results to load summary data\r\n        await this.nextPage();\r\n        return this.summary;\r\n    }\r\n}\r\n\r\nexport class PostEventReportRequest extends SearchRequest<Webcast.PostEventSession> {\r\n    declare summary: Webcast.PostEventSummary;\r\n    constructor(rev: RevClient, query: { eventId: string, runNumber?: number }, options: Rev.SearchOptions<Webcast.PostEventSession> = {}) {\r\n        const { eventId, runNumber } = query;\r\n        const runQuery = (runNumber && runNumber >= 0)\r\n            ? { runNumber }\r\n            : {};\r\n\r\n        const searchDefinition: Rev.SearchDefinition<Webcast.PostEventSession> = {\r\n            endpoint: `/api/v2/scheduled-events/${eventId}/post-event-report`,\r\n                totalKey: 'totalSessions',\r\n                hitsKey: 'sessions',\r\n                request: async (endpoint, query, options) => {\r\n                    // this endpoint has a particular error response that isn't automatically captured\r\n                    // by the RevError parser, so need to manually check\r\n                    const response = await rev.request<Webcast.PostEventSummary>('GET', endpoint, query, {\r\n                        ...options,\r\n                        responseType: 'json',\r\n                        throwHttpErrors: false\r\n                    });\r\n\r\n                    // will throw on error response\r\n                    await this._assertResponseOk(response);\r\n\r\n                    // get summary removes scrollId and other internal data\r\n                    Object.assign(this.summary, getSummaryFromResponse(response.body, 'sessions'));\r\n                    return response.body;\r\n                }\r\n        };\r\n        super(rev, searchDefinition,  runQuery, options);\r\n        this.summary = {};\r\n    }\r\n    private async _assertResponseOk({response, statusCode, body}: Rev.Response<Webcast.PostEventSummary>): Promise<Webcast.PostEventSummary> {\r\n        if (response.ok) {\r\n            return body;\r\n        }\r\n\r\n        if (statusCode == 400 && (body as PostEventErrorResponse)?.errorDescription) {\r\n            throw new RevError(response, { details: (body as PostEventErrorResponse).errorDescription });\r\n        }\r\n        // bodyUsed should always be true, but this is just a safety check\r\n        const error = (!!body || response.bodyUsed)\r\n            ? new RevError(response, body as string)\r\n            : await RevError.create(response);\r\n        throw error;\r\n    }\r\n    /**\r\n     * get the aggregate statistics only, instead of actual session data.\r\n     * @returns {Webcast.PostEventSummary}\r\n     */\r\n    async getSummary() {\r\n        // set maxResults to 0 to mark request as done, since first page of sessions will be lost\r\n        this.options.maxResults = 0;\r\n        // must get first page of results to load summary data\r\n        await this.nextPage();\r\n        return this.summary;\r\n    }\r\n}\r\n\r\n\r\ninterface PostEventErrorResponse {\r\n    errorDescription: string;\r\n    sessions: [],\r\n    totalSessions: 0\r\n}\r\n\r\n/**\r\n * The Post Event Report returns a special JSON body on 400 error, unlike other endpoints\r\n */\r\nasync function parseAttendeesError(revResponse: Rev.Response<unknown>) {\r\n\r\n}\r\n","import { Rev } from '..';\r\nimport type { RevClient } from '../rev-client';\r\nimport { Webcast, GuestRegistration, Banner } from '../types/webcast';\r\nimport { SearchRequest } from '../utils/request-utils';\r\nimport { titleCase } from '../utils';\r\nimport { PostEventReportRequest, RealtimeReportRequest } from './webcast-report-request';\r\nimport { mergeHeaders } from '../utils/merge-headers';\r\n\r\ntype RealtimeSession<T extends Webcast.RealtimeRequest | undefined> = T extends { attendeeDetails: 'All' }\r\n    ? Webcast.RealtimeSessionDetail\r\n    : T extends { attendeeDetails: 'Counts' }\r\n    ? never\r\n    : Webcast.RealtimeSession;\r\n\r\nexport default function webcastAPIFactory(rev: RevClient) {\r\n    const webcastAPI = {\r\n        async list(options: Webcast.ListRequest = { }, requestOptions?: Rev.RequestOptions): Promise<Webcast[]> {\r\n            return rev.get('/api/v2/scheduled-events', options, { ...requestOptions, responseType: 'json' });\r\n        },\r\n        search(query: Webcast.SearchRequest, options?: Rev.SearchOptions<Webcast>): Rev.ISearchRequest<Webcast> {\r\n            const searchDefinition: Rev.SearchDefinition<Webcast> = {\r\n                endpoint: `/api/v2/search/scheduled-events`,\r\n                totalKey: 'total',\r\n                hitsKey: 'events',\r\n                request: (endpoint, query, options) => rev.post(endpoint, query, options),\r\n                isPost: true\r\n            };\r\n            return new SearchRequest<Webcast>(rev, searchDefinition, query, options);\r\n        },\r\n        async create(event: Webcast.CreateRequest): Promise<string> {\r\n            const { eventId } = await rev.post(`/api/v2/scheduled-events`, event);\r\n            return eventId;\r\n        },\r\n        async details(eventId: string, requestOptions?: Rev.RequestOptions): Promise<Webcast.Details> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}`, undefined, requestOptions);\r\n        },\r\n        async edit(eventId: string, event: Webcast.CreateRequest): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}`, event);\r\n        },\r\n        // async patch - not yet implemented\r\n        async delete(eventId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}`);\r\n        },\r\n        async editAccess(eventId: string, entities: Webcast.EditAttendeesRequest): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/access-control`, entities);\r\n        },\r\n        attendees(\r\n            eventId: string,\r\n            runNumber?: number,\r\n            options?: Rev.SearchOptions<Webcast.PostEventSession>\r\n        ) {\r\n            return new PostEventReportRequest(rev, { eventId, runNumber }, options);\r\n        },\r\n        realtimeAttendees<T extends Webcast.RealtimeRequest | undefined>(\r\n            eventId: string,\r\n            query?: T,\r\n            options?: Rev.SearchOptions<RealtimeSession<T>>\r\n        ) {\r\n            return new RealtimeReportRequest<RealtimeSession<T>>(rev, eventId, query, options);\r\n        },\r\n        async questions(eventId: string, runNumber?: number): Promise<Webcast.Question[]> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/questions`, query, { responseType: 'json' });\r\n        },\r\n        async pollResults(eventId: string, runNumber?: number): Promise<Webcast.PollResults[]> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            // const {polls} = await rev.get(`/api/v2/scheduled-events/${eventId}/poll-results`, query, { responseType: 'json' });\r\n            // workaround for event that never happened returning blank response\r\n            const rawResponse = await rev.get(`/api/v2/scheduled-events/${eventId}/poll-results`, query, { responseType: 'text' });\r\n            const {polls = []} = rawResponse ? JSON.parse(rawResponse) : {};\r\n            return polls;\r\n        },\r\n        async comments(eventId: string, runNumber?: number): Promise<Webcast.Comment[]> {\r\n            const query = (runNumber ?? -1) >= 0 ? { runNumber } : {};\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/comments`, query, { responseType: 'json' });\r\n        },\r\n        async status(eventId: string, requestOptions?: Rev.RequestOptions): Promise<Webcast.Status> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/status`, undefined, requestOptions);\r\n        },\r\n        async isPublic(eventId: string, requestOptions?: Rev.RequestOptions): Promise<boolean> {\r\n            const response = await rev.request('GET', `/api/v2/scheduled-events/${eventId}/is-public`, undefined, { ...requestOptions, throwHttpErrors: false, responseType: 'json' });\r\n            return response.statusCode !== 401 && response.body?.isPublic;\r\n        },\r\n        async playbackUrls(eventId: string, {ip, userAgent}: Webcast.PlaybackUrlRequest = { }, options?: Rev.RequestOptions): Promise<Webcast.PlaybackUrlsResponse> {\r\n            const query = ip ? { ip } : undefined;\r\n\r\n            const opts: Rev.RequestOptions = {\r\n                ...options,\r\n                ...userAgent && {\r\n                    headers: mergeHeaders(options?.headers, { 'User-Agent': userAgent })\r\n                },\r\n                responseType: 'json'\r\n            };\r\n\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/playback-url`, query, opts);\r\n        },\r\n        /**\r\n         * @deprecated\r\n         * @param eventId\r\n         * @param options\r\n         * @returns\r\n         */\r\n        async playbackUrl(eventId: string, options: Webcast.PlaybackUrlRequest = { }): Promise<Webcast.Playback[]> {\r\n            rev.log('debug', 'webcast.playbackUrl is deprecated - use webcast.playbackUrls instead');\r\n            const {playbackResults} = await webcastAPI.playbackUrls(eventId, options);\r\n            return playbackResults;\r\n        },\r\n        async startEvent(eventId: string, preProduction: boolean = false): Promise<void> {\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/start`, { preProduction });\r\n        },\r\n        async stopEvent(eventId: string, preProduction: boolean = false): Promise<void> {\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/start`, { preProduction });\r\n        },\r\n        async startBroadcast(eventId: string): Promise<void> {\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/broadcast`);\r\n        },\r\n        async stopBroadcast(eventId: string): Promise<void> {\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/broadcast`);\r\n        },\r\n        async startRecord(eventId: string): Promise<void> {\r\n            await rev.put(`/api/v2/scheduled-events/${eventId}/record`);\r\n        },\r\n        async stopRecord(eventId: string): Promise<void> {\r\n            await rev.delete(`/api/v2/scheduled-events/${eventId}/record`);\r\n        },\r\n        async linkVideo(eventId: string, videoId: string, autoRedirect: boolean = true) {\r\n            const payload = {\r\n                videoId,\r\n                redirectVod: autoRedirect\r\n            };\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/linked-video`, payload);\r\n        },\r\n        async unlinkVideo(eventId: string) {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/linked-video`);\r\n        },\r\n        /**\r\n         * Retrieve details of a specific guest user Public webcast registration.\r\n         * @param eventId - Id of the Public webcast\r\n         * @param registrationId - Id of guest user's registration to retrieve\r\n         * @returns\r\n         */\r\n        async guestRegistration(eventId: string, registrationId: string): Promise<GuestRegistration.Details> {\r\n            return rev.get(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`);\r\n        },\r\n        /**\r\n         * Register one attendee/guest user for an upcoming Public webcast. Make sure you first enable Public webcast pre-registration before adding registrations.\r\n         * @param eventId\r\n         * @param registration\r\n         * @returns\r\n         */\r\n        async createGuestRegistration(eventId: string, registration: GuestRegistration.Request): Promise<GuestRegistration.Details> {\r\n            return rev.post(`/api/v2/scheduled-events/${eventId}/registrations`, registration);\r\n        },\r\n        listGuestRegistrations(\r\n            eventId: string,\r\n            query: GuestRegistration.SearchRequest = {},\r\n            options?: Rev.SearchOptions<GuestRegistration>\r\n        ): Rev.ISearchRequest<GuestRegistration> {\r\n            const searchDefinition: Rev.SearchDefinition<GuestRegistration> = {\r\n                endpoint: `/api/v2/scheduled-events/${eventId}/registrations`,\r\n                /** NOTE: this API doesn't actually return a total, so this will always be undefined */\r\n                totalKey: 'total',\r\n                hitsKey: 'guestUsers'\r\n            };\r\n            return new SearchRequest<GuestRegistration>(rev, searchDefinition, query, options);\r\n        },\r\n        updateGuestRegistration(eventId: string, registrationId: string, registration: GuestRegistration.Request): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`, registration);\r\n        },\r\n        patchGuestRegistration(eventId: string, registrationId: string, registration: Partial<GuestRegistration.Request>): Promise<void> {\r\n            const operations = Object.entries(registration)\r\n                .map(([key, value]) => {\r\n                    let path = `/${titleCase(key)}`;\r\n                    return { op: 'replace', path, value };\r\n                });\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`, operations);\r\n        },\r\n        deleteGuestRegistration(eventId: string, registrationId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/registrations/${registrationId}`);\r\n        },\r\n        async listBanners(eventId: string): Promise<Banner[]> {\r\n            const {banners} = await rev.get(`/api/v2/scheduled-events/${eventId}/banners`);\r\n            return banners || [];\r\n        },\r\n        addBanner(eventId: string, banner: Banner.Request): Promise<Banner> {\r\n            return rev.post(`/api/v2/scheduled-events/${eventId}/banner`, banner);\r\n        },\r\n        setBannerStatus(eventId: string, bannerId: string, isEnabled: boolean): Promise<void> {\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/banner/${bannerId}/status`, {isEnabled});\r\n        },\r\n        updateBanner(eventId: string, banner: Banner): Promise<Banner> {\r\n            // separate id from the banner data\r\n            const {id, ...payload} = banner;\r\n            return rev.put(`/api/v2/scheduled-events/${eventId}/banner/${id}`, payload);\r\n        },\r\n        deleteBanner(eventId: string, bannerId: string): Promise<void> {\r\n            return rev.delete(`/api/v2/scheduled-events/${eventId}/banner/${bannerId}`);\r\n        }\r\n    };\r\n\r\n    return webcastAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\nimport { Zone } from '../types/zone';\r\n\r\nexport default function zonesAPIFactory(rev: RevClient) {\r\n    const zonesAPI = {\r\n        async list(): Promise<{ defaultZone: Zone, zones: Zone[]; }> {\r\n            return rev.get(`/api/v2/zones`, undefined, { responseType: 'json' });\r\n        },\r\n        async flatList(): Promise<Zone.FlatZone[]> {\r\n            const {\r\n                defaultZone,\r\n                zones\r\n            } = await zonesAPI.list();\r\n            const flatZones: Omit<Zone, 'childZones'>[] = [defaultZone];\r\n            function recursiveAdd(inZone: Zone) {\r\n                const {\r\n                    childZones = [],\r\n                    ...zone\r\n                } = inZone;\r\n\r\n                flatZones.push(zone);\r\n                childZones.forEach(recursiveAdd);\r\n            }\r\n            zones.forEach(recursiveAdd);\r\n            return flatZones;\r\n        },\r\n        async create(zone: Zone.CreateRequest): Promise<string> {\r\n            const { zoneId } = await rev.post(`/api/v2/zones`, zone, { responseType: 'json' });\r\n            return zoneId;\r\n        },\r\n        async edit(zoneId: string, zone: Zone.CreateRequest): Promise<void> {\r\n            return rev.put(`/api/v2/zones/${zoneId}`, zone);\r\n        },\r\n        delete(zoneId: string) {\r\n            return rev.delete(`/api/v2/zones/${zoneId}`);\r\n        },\r\n        get devices() {\r\n            return rev.device.listZoneDevices;\r\n        }\r\n    };\r\n    return zonesAPI;\r\n}\r\n","import type { RevClient } from '../rev-client';\r\n\r\nexport default function environmentAPIFactory(rev: RevClient) {\r\n    let accountId = '';\r\n    let version = '';\r\n    let ulsInfo: undefined | { enabled: boolean, locationUrls: string[] } = undefined;\r\n\r\n    const environmentAPI = {\r\n        /**\r\n         * Get's the accountId embedded in Rev's main entry point\r\n         * @returns\r\n         */\r\n        async getAccountId(forceRefresh = false): Promise<string> {\r\n            if (!accountId || forceRefresh) {\r\n                const text = await rev.get<string>('/', undefined, { responseType: 'text' }).catch(error => '');\r\n                accountId = (/BootstrapContext.*account[\":{ ]*\"id\"\\s*:\\s*\"([^\"]+)\"/.exec(text) || [])[1] || '';\r\n            }\r\n            return accountId;\r\n        },\r\n        /**\r\n         * Get's the version of Rev returned by /js/version.js\r\n         * @returns\r\n         */\r\n        async getRevVersion(forceRefresh = false): Promise<string> {\r\n            if (!version || forceRefresh) {\r\n                const text = await rev.get<string>('/js/version.js', undefined, { responseType: 'text' }).catch(error => '');\r\n                version = (/buildNumber:\\s+['\"]([\\d.]+)/.exec(text) || [])[1] || '';\r\n            }\r\n            return version;\r\n        },\r\n        /**\r\n         * Use the Get User Location Service API to get a user's IP address for zoning purposes\r\n         * Returns the IP if ULS enabled and one successfully found, otherwise undefined.\r\n         * undefined response indicates Rev should use the user's public IP for zoning.\r\n         * @param timeoutMs    - how many milliseconds to wait for a response (if user is not)\r\n         *                       on VPN / intranet with ULS DME then DNS lookup or request\r\n         *                       can time out, so don't set this too long.\r\n         *                       Default is 10 seconds\r\n         * @param forceRefresh   By default the User Location Services settings is cached\r\n         *                       (not the user's detected IP). Use this to force reloading\r\n         *                       the settings from Rev.\r\n         * @returns\r\n         */\r\n        async getUserLocalIp(timeoutMs = 10 * 1000, forceRefresh = false): Promise<string | undefined> {\r\n            if (!ulsInfo || forceRefresh) {\r\n                ulsInfo = await rev.get('/api/v2/user-location');\r\n            }\r\n            // if User Location Services isn't enabled then return undefined, meaning Rev will just use user's public IP for zoning\r\n            if (!ulsInfo?.enabled || ulsInfo.locationUrls.length === 0) {\r\n                return undefined;\r\n            }\r\n            const controller = new AbortController();\r\n            const getIp = async function (ulsUrl: string) {\r\n                try {\r\n                    let {ip = ''} = await rev.get<{ ip: string }>(ulsUrl, {}, {\r\n                        headers: { Authorization: '' },\r\n                        responseType: 'json',\r\n                        signal: controller.signal\r\n                    });\r\n                    ip = `${ip}`.split(',')[0].trim();\r\n                    if (ip) {\r\n                        // cancel any other requests early\r\n                        controller.abort();\r\n                    }\r\n                    return ip;\r\n                } catch (error) {\r\n                    rev.log('debug', `ULS URL Failed: ${ulsUrl}`, error);\r\n                    return undefined;\r\n                }\r\n            }\r\n\r\n            const timer = setTimeout(() => controller.abort(), timeoutMs);\r\n            try {\r\n                // collect all returned IPs...first response will abort others early\r\n                const ips = await Promise.all(ulsInfo.locationUrls.map(getIp));\r\n                return ips.find(ip => !!ip);\r\n            } finally {\r\n                clearTimeout(timer);\r\n            }\r\n        }\r\n    };\r\n\r\n    return environmentAPI;\r\n}\r\n","import type { RevClient } from './rev-client';\r\nimport type { Rev } from './types';\r\nimport { isPlainObject, sleep } from './utils';\r\nimport interop from './interop/polyfills';\r\nimport { RateLimitEnum, RateLimitQueues, clearQueues, makeQueues } from './utils/rate-limit-queues';\r\n\r\nconst ONE_MINUTE = 1000 * 60;\r\n\r\n// obsfucate credentials to avoid accidental disclosure\r\nconst _credentials = Symbol('credentials');\r\n\r\ninterface LoginResponse {\r\n    token: string,\r\n    expiration: string,\r\n    userId?: string,\r\n    refreshToken?: string,\r\n    apiKey?: string;\r\n}\r\n\r\nclass SessionKeepAlive {\r\n    private readonly _session!: SessionBase;\r\n    private controller?: AbortController;\r\n    extendOptions: Required<Rev.KeepAliveOptions>;\r\n    error?: undefined | Error;\r\n    private _isExtending: boolean = false;\r\n    constructor(session: SessionBase, options: Rev.KeepAliveOptions = { }) {\r\n        // TODO verify values?\r\n        this.extendOptions = {\r\n            extendThresholdMilliseconds: 3 * ONE_MINUTE,\r\n            keepAliveInterval: 10 * ONE_MINUTE,\r\n            verify: true,\r\n            ...options\r\n        };\r\n\r\n        Object.defineProperties(this, {\r\n            _session: {\r\n                get: () => session,\r\n                enumerable: false\r\n            }\r\n        });\r\n    }\r\n    getNextExtendTime() {\r\n        const { expires } = this._session;\r\n        if (!expires) {\r\n            return 0;\r\n        }\r\n        const {\r\n            keepAliveInterval: interval,\r\n            extendThresholdMilliseconds: threshold\r\n        } = this.extendOptions;\r\n\r\n        const timeTillExpiration = expires.getTime() - Date.now();\r\n        // clamp range to within 0 and max interval\r\n        return Math.max(0, Math.min(timeTillExpiration - threshold, interval));\r\n    }\r\n    private async _poll() {\r\n        const { _session: session } = this;\r\n        // force stop other poll process if already polling\r\n        // keep reference to controller in case of reset\r\n        const controller = this._reset();\r\n        const { signal } = controller;\r\n\r\n        while (session.isConnected && !signal.aborted) {\r\n            const nextExtendTime = this.getNextExtendTime();\r\n            await sleep(nextExtendTime, signal);\r\n\r\n            // check if poll was aborted. if so don't try to extend\r\n            if (signal.aborted) {\r\n                break;\r\n            }\r\n\r\n            // extend session\r\n            // possible this can throw an error\r\n            try {\r\n                // extending may re-login, so pause poll resets for now\r\n                this._isExtending = true;\r\n                await session.lazyExtend(this.extendOptions);\r\n            } catch (err: any) {\r\n                // swallow error, but signal stopped using abort controller\r\n                controller.abort();\r\n                this.error = err;\r\n            } finally {\r\n                this._isExtending = false;\r\n            }\r\n        }\r\n    }\r\n    start() {\r\n        if (this._isExtending) {\r\n            return;\r\n        }\r\n        this._poll();\r\n    }\r\n    stop() {\r\n        if (this._isExtending) {\r\n            return;\r\n        }\r\n        if (this.controller) {\r\n            this.controller.abort();\r\n        }\r\n    }\r\n    private _reset() {\r\n        this.error = undefined;\r\n        this._isExtending = false;\r\n        const oldController = this.controller;\r\n        this.controller = new interop.AbortController();\r\n\r\n        // stop previous poll\r\n        if (oldController) {\r\n            oldController.abort();\r\n        }\r\n        return this.controller;\r\n    }\r\n    get isAlive() {\r\n        return this.controller && !this.controller.signal.aborted;\r\n    }\r\n}\r\n\r\nabstract class SessionBase implements Rev.IRevSession {\r\n    token?: string;\r\n    expires: Date;\r\n    protected readonly rev!: RevClient;\r\n    protected readonly [_credentials]!: Rev.Credentials;\r\n    readonly keepAlive?: SessionKeepAlive;\r\n    readonly _rateLimits?: Partial<RateLimitQueues>;\r\n    constructor(rev: RevClient, credentials: Rev.Credentials, keepAliveOptions?: boolean | Rev.KeepAliveOptions, rateLimits?: boolean | Rev.RateLimits) {\r\n        this.expires = new Date();\r\n\r\n        if (keepAliveOptions === true) {\r\n            this.keepAlive = new SessionKeepAlive(this);\r\n        } else if (isPlainObject(keepAliveOptions)) {\r\n            this.keepAlive = new SessionKeepAlive(this, keepAliveOptions);\r\n        }\r\n\r\n        let rateLimitQueues: undefined | Partial<RateLimitQueues> = undefined;\r\n        if (rateLimits) {\r\n            rateLimitQueues = makeQueues(isPlainObject(rateLimits) ? rateLimits : undefined);\r\n        }\r\n\r\n        // add as private member\r\n        Object.defineProperties(this, {\r\n            rev: {\r\n                get() { return rev; },\r\n                enumerable: false\r\n            },\r\n            [_credentials]: {\r\n                get() { return credentials; },\r\n                enumerable: false\r\n            },\r\n            _rateLimits: {\r\n                get() { return rateLimitQueues; },\r\n                enumerable: false\r\n            }\r\n        });\r\n    }\r\n    async login() {\r\n        this.token = undefined;\r\n        this.expires = new Date();\r\n\r\n        const {\r\n            expiration,\r\n            ...session\r\n        } = await this._login();\r\n\r\n        Object.assign(this, session);\r\n\r\n        const expires = new Date(expiration);\r\n        // VERY edge case where old date could be returned - just assume 10 min expiration\r\n        if (expires.getTime() < this.expires.getTime()) {\r\n            this.expires.setUTCMinutes(this.expires.getUTCMinutes() + 10);\r\n        } else {\r\n            this.expires = expires;\r\n        }\r\n\r\n        if (this.keepAlive) {\r\n            this.keepAlive.start();\r\n        }\r\n    }\r\n    async extend() {\r\n        const { expiration } = await this._extend();\r\n        this.expires = new Date(expiration);\r\n    }\r\n    async logoff() {\r\n        if (this.keepAlive) {\r\n            this.keepAlive.stop();\r\n        }\r\n        try {\r\n            await this._logoff();\r\n        } finally {\r\n            this.token = undefined;\r\n            this.expires = new Date();\r\n        }\r\n    }\r\n    async verify() {\r\n        try {\r\n            await this.rev.auth.verifySession();\r\n            return true;\r\n        } catch (err) {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     *\r\n     * @returns wasExtended - whether session was extended / re-logged in\r\n     */\r\n    async lazyExtend(options: Rev.KeepAliveOptions = { }) {\r\n        const {\r\n            extendThresholdMilliseconds: threshold = 3 * ONE_MINUTE,\r\n            verify: shouldVerify = true\r\n        } = options;\r\n\r\n        const { expires } = this;\r\n        const timeLeft = expires\r\n            ? expires.getTime() - Date.now()\r\n            : -1;\r\n\r\n        // login if session expired\r\n        if (timeLeft <= 0) {\r\n            await this.login();\r\n            return true;\r\n        }\r\n\r\n        // extend if within extend window\r\n        if (timeLeft > threshold) {\r\n            try {\r\n                await this.extend();\r\n                // successful extend, nothing more to do\r\n                return true;\r\n            } catch (error) {\r\n                this.rev.log('warn', 'Error extending session - re-logging in', error);\r\n            }\r\n            // check if valid session if plenty of time left\r\n        } else if (!shouldVerify || await this.verify()) {\r\n            // valid, no change\r\n            return false;\r\n        }\r\n\r\n        // if reached here then need to re-login\r\n        await this.login();\r\n        return true;\r\n    }\r\n    async queueRequest(queue: `${RateLimitEnum}`) {\r\n        await this._rateLimits?.[queue]?.();\r\n    }\r\n    /**\r\n     * Abort pending executions. All unresolved promises are rejected with a `AbortError` error.\r\n     * @param {string} [message] - message parameter for rejected AbortError\r\n     */\r\n    async clearQueues(message?: string) {\r\n        await clearQueues(this._rateLimits ?? {}, message);\r\n    }\r\n    /**\r\n     * check if expiration time of session has passed\r\n     */\r\n    get isExpired() {\r\n        const { expires } = this;\r\n        if (!expires) {\r\n            return true;\r\n        }\r\n        return Date.now() > expires.getTime();\r\n    }\r\n    /**\r\n     * returns true if session isn't expired and has a token\r\n     */\r\n    get isConnected() {\r\n        return !!this.token && !this.isExpired;\r\n    }\r\n    get username() {\r\n        return this[_credentials].username;\r\n    }\r\n    get hasRateLimits() {\r\n        return !!this._rateLimits;\r\n    }\r\n    protected abstract _login(): Promise<LoginResponse>;\r\n    protected abstract _extend(): Promise<{ expiration: string; }>;\r\n    protected abstract _logoff(): Promise<void>;\r\n    public abstract toJSON(): Rev.IRevSessionState;\r\n}\r\n\r\n/**\r\n * Use OAuth2Session instead if possible\r\n * @deprecated\r\n */\r\nexport class OAuthSession extends SessionBase {\r\n    refreshToken?: string;\r\n    async _login() {\r\n        const { oauthConfig, authCode } = this[_credentials];\r\n        if (!oauthConfig || !authCode) {\r\n            throw new TypeError('OAuth Config / auth code not specified');\r\n        }\r\n        const {\r\n            accessToken: token,\r\n            expiration,\r\n            refreshToken,\r\n            userId\r\n        } = await this.rev.auth.loginOAuth(oauthConfig, authCode);\r\n        return { token, expiration, refreshToken, userId };\r\n    }\r\n    async _extend() {\r\n        const { [_credentials]: { oauthConfig } } = this;\r\n\r\n        const {\r\n            // other API calls call this \"token\" instead of \"accessToken\", hence the rename\r\n            accessToken: token,\r\n            expiration,\r\n            refreshToken\r\n        } = await this.rev.auth.extendSessionOAuth(oauthConfig as any, <string>this.refreshToken);\r\n\r\n        // unlike other extend methods this updates the token + refreshToken each time\r\n        Object.assign(this, { token, refreshToken });\r\n        return { expiration };\r\n    }\r\n    async _logoff() {\r\n        // nothing to do\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires,\r\n            refreshToken: this.refreshToken\r\n        };\r\n    }\r\n}\r\n\r\nexport class OAuth2Session extends SessionBase {\r\n    refreshToken?: string;\r\n    async _login() {\r\n        const { oauthConfig, code, codeVerifier } = this[_credentials];\r\n        if (!oauthConfig || !code || !codeVerifier) {\r\n            throw new TypeError('OAuth Config / auth code / verifier not specified');\r\n        }\r\n        const {\r\n            access_token: token,\r\n            expires_in,\r\n            refresh_token: refreshToken,\r\n            userId\r\n        } = await this.rev.auth.loginOAuth2(oauthConfig, code, codeVerifier);\r\n        const expiresTime = Date.now() + parseInt(expires_in, 10) * 1000;\r\n        const expiration = new Date(expiresTime).toISOString();\r\n        return { token, expiration, refreshToken, userId };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport class UserSession extends SessionBase {\r\n    userId?: string;\r\n    async _login() {\r\n        const { username, password } = this[_credentials];\r\n        if (!username || !password) {\r\n            throw new TypeError('username/password not specified');\r\n        }\r\n        const {\r\n            token,\r\n            expiration,\r\n            id: userId\r\n        } = await this.rev.auth.loginUser(username, password);\r\n        return { token, expiration, userId };\r\n    }\r\n    async _extend() {\r\n        const { userId } = this;\r\n\r\n        return this.rev.auth.extendSessionUser(<string>userId);\r\n    }\r\n    async _logoff() {\r\n        const { userId } = this;\r\n\r\n        return this.rev.auth.logoffUser(<string>userId);\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires,\r\n            userId: this.userId\r\n        };\r\n    }\r\n}\r\n\r\nexport class ApiKeySession extends SessionBase {\r\n    async _login() {\r\n        const { apiKey, secret } = this[_credentials];\r\n        if (!apiKey || !secret) {\r\n            throw new TypeError('apiKey/secret not specified');\r\n        }\r\n        return this.rev.auth.loginToken(apiKey, secret);\r\n    }\r\n    async _extend() {\r\n        const { apiKey } = this[_credentials];\r\n        return this.rev.auth.extendSessionToken(<string>apiKey);\r\n    }\r\n    async _logoff() {\r\n        const { apiKey } = this[_credentials];\r\n        return this.rev.auth.logoffToken(<string>apiKey);\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires,\r\n            apiKey: this[_credentials].apiKey\r\n        };\r\n    }\r\n}\r\n\r\nexport class JWTSession extends SessionBase {\r\n    async _login() {\r\n        const { jwtToken } = this[_credentials];\r\n        if (!jwtToken) {\r\n            throw new TypeError('JWT Token not specified');\r\n        }\r\n        const {accessToken: token, expiration} = await this.rev.auth.loginJWT(jwtToken);\r\n        return { token, expiration, issuer: 'vbrick' };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport class GuestRegistrationSession extends SessionBase {\r\n    async _login() {\r\n        const { webcastId, guestRegistrationToken } = this[_credentials];\r\n        if (!guestRegistrationToken || !webcastId) {\r\n            throw new TypeError('Guest Registration Token or Webcast ID not specified');\r\n        }\r\n        const {accessToken: token} = await this.rev.auth.loginGuestRegistration(webcastId, guestRegistrationToken);\r\n\r\n        // expires time is not sent, so just assume 15 minutes\r\n        const expiresTime = Date.now() + 1000 * 60 * 15;\r\n        const expiration = new Date(expiresTime).toISOString();\r\n\r\n        return { token, expiration, issuer: 'vbrick' };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport class AccessTokenSession extends SessionBase {\r\n    // just verify user on login\r\n    async _login() {\r\n        await this.rev.auth.verifySession();\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires?.toISOString(),\r\n            issuer: 'vbrick'\r\n        };\r\n    }\r\n    async _extend() {\r\n        return this.rev.auth.extendSession();\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n    get isConnected() {\r\n        return true;\r\n    }\r\n    get isExpired() {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport class PublicOnlySession extends SessionBase {\r\n    async _login() {\r\n        this.rev.log('debug', 'Using client with no authentication (publicOnly) - non-public endpoints will return 401');\r\n        // no verify\r\n        return {\r\n            token: this.token || '',\r\n            // very long expiration\r\n            expiration: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString(),\r\n            issuer: 'vbrick'\r\n        };\r\n    }\r\n    async _extend() {\r\n        return {\r\n            expiration: new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString()\r\n        }\r\n    }\r\n    async _logoff() {\r\n        return;\r\n    }\r\n    public toJSON(): Rev.IRevSessionState {\r\n        return {\r\n            token: this.token || '',\r\n            expiration: this.expires\r\n        };\r\n    }\r\n}\r\n\r\nexport function createSession(rev: RevClient, credentials: Rev.Credentials, keepAliveOptions?: boolean | Rev.KeepAliveOptions, rateLimits?: boolean | Rev.RateLimits) {\r\n    let session: Rev.IRevSession;\r\n\r\n    const {\r\n        session: sessionState = {} as Rev.IRevSessionState,\r\n        publicOnly,\r\n        ...creds\r\n    } = credentials;\r\n\r\n    const {\r\n        token,\r\n        expiration,\r\n        refreshToken,\r\n        userId\r\n    } = sessionState;\r\n\r\n    const now = Date.now();\r\n    const expires = new Date(expiration || now);\r\n    const hasSession = (token && typeof token === 'string') && (expires.getTime() > now);\r\n\r\n    const isOAuth2Login = credentials.oauthConfig && (credentials.code && credentials.codeVerifier);\r\n    const isLegacyOauthLogin = credentials.oauthConfig && (credentials.authCode || (hasSession && refreshToken));\r\n    const isApiKeyLogin = credentials.apiKey && (credentials.secret || (hasSession && !userId));\r\n    const isUsernameLogin = credentials.username && (credentials.password || (hasSession && userId));\r\n    const isJWTLogin = credentials.jwtToken;\r\n    const isGuestRegistration = credentials.webcastId && credentials.guestRegistrationToken;\r\n\r\n    // prefer oauth first, then apikey then username if multiple params specified\r\n    if (isOAuth2Login) {\r\n        session = new OAuth2Session(rev, creds, keepAliveOptions, rateLimits);\r\n    } else if (isLegacyOauthLogin) {\r\n        session = new OAuthSession(rev, creds, keepAliveOptions, rateLimits);\r\n        if (refreshToken) {\r\n            (session as OAuthSession).refreshToken = refreshToken;\r\n        }\r\n    } else if (isApiKeyLogin) {\r\n        session = new ApiKeySession(rev, creds, keepAliveOptions, rateLimits);\r\n    } else if (isJWTLogin) {\r\n        session = new JWTSession(rev, creds, keepAliveOptions, rateLimits);\r\n    } else if (isGuestRegistration) {\r\n        session = new GuestRegistrationSession(rev, creds, keepAliveOptions, rateLimits);\r\n    } else if (isUsernameLogin) {\r\n        session = new UserSession(rev, creds, keepAliveOptions, rateLimits);\r\n        if (userId) {\r\n            (session as UserSession).userId = userId;\r\n        }\r\n    } else if (hasSession || publicOnly) {\r\n        session = new AccessTokenSession(rev, creds, keepAliveOptions, rateLimits);\r\n    } else {\r\n        throw new TypeError('Must specify credentials (username+password, apiKey+secret or oauthConfig+authCode)');\r\n    }\r\n\r\n    if (hasSession) {\r\n        session.token = token;\r\n        session.expires = expires;\r\n    }\r\n    return session;\r\n}\r\n","import { RevError } from './rev-error';\r\nimport { RateLimitEnum, isPlainObject, retry } from './utils';\r\nimport * as api from './api';\r\nimport polyfills, {shouldInitialize, onInitialize} from './interop/polyfills';\r\nimport { Rev } from './types';\r\nimport { decodeBody } from './utils/request-utils';\r\nimport { createSession } from './rev-session';\r\n\r\ntype PayloadType = { [key: string]: any; } | Record<string, any> | any[];\r\n\r\nexport class RevClient {\r\n    url: string;\r\n    logEnabled: boolean;\r\n    session: Rev.IRevSession;\r\n    readonly admin!: ReturnType<typeof api.admin>;\r\n    readonly audit!: ReturnType<typeof api.audit>;\r\n    readonly auth!: ReturnType<typeof api.auth>;\r\n    readonly category!: ReturnType<typeof api.category>;\r\n    readonly channel!: ReturnType<typeof api.channel>;\r\n    readonly device!: ReturnType<typeof api.device>;\r\n    readonly environment!: ReturnType<typeof api.environment>;\r\n    readonly group!: ReturnType<typeof api.group>;\r\n    readonly playlist!: ReturnType<typeof api.playlist>;\r\n    readonly recording!: ReturnType<typeof api.recording>;\r\n    readonly upload!: ReturnType<typeof api.upload>;\r\n    readonly user!: ReturnType<typeof api.user>;\r\n    readonly video!: ReturnType<typeof api.video>;\r\n    readonly webcast!: ReturnType<typeof api.webcast>;\r\n    readonly zones!: ReturnType<typeof api.zones>;\r\n    private _streamPreference: Rev.RequestOptions['responseType'];\r\n    constructor(options: Rev.Options) {\r\n        if (!isPlainObject(options) || !options.url) {\r\n            throw new TypeError('Missing configuration options for client - url and username/password or apiKey/secret');\r\n        }\r\n        const {\r\n            url,\r\n            log,\r\n            logEnabled = false,\r\n            keepAlive = true,\r\n            // NOTE default to false rate limiting for now. In future this may change\r\n            rateLimits = false,\r\n            defaultStreamPreference = 'stream',\r\n            ...credentials\r\n        } = options;\r\n\r\n        // get just the origin of provided url\r\n        const urlObj = new URL(url);\r\n        this.url = urlObj.origin;\r\n\r\n        // will throw error if credentials are invalid\r\n        this.session = createSession(this, credentials, keepAlive, rateLimits);\r\n\r\n        // add logging functionality\r\n        this.logEnabled = !!logEnabled;\r\n        if (log) {\r\n            this.log = (severity: Rev.LogSeverity, ...args: any[]) => {\r\n                if (!this.logEnabled) {\r\n                    return;\r\n                }\r\n                log(severity, ...args);\r\n            };\r\n        }\r\n        this._streamPreference = defaultStreamPreference;\r\n\r\n        // add all API endpoints\r\n        Object.defineProperties(this, {\r\n            admin: { value: api.admin(this), writable: false },\r\n            // NOTE rate limiting option passed into api factory since its\r\n            audit: { value: api.audit(this, rateLimits), writable: false },\r\n            auth: { value: api.auth(this), writable: false },\r\n            category: { value: api.category(this), writable: false },\r\n            channel: { value: api.channel(this), writable: false },\r\n            device: { value: api.device(this), writable: false },\r\n            environment: { value: api.environment(this), writable: false },\r\n            group: { value: api.group(this), writable: false },\r\n            playlist: { value: api.playlist(this), writable: false },\r\n            recording: { value: api.recording(this), writable: false },\r\n            upload: { value: api.upload(this), writable: false },\r\n            user: { value: api.user(this), writable: false },\r\n            video: { value: api.video(this), writable: false },\r\n            webcast: { value: api.webcast(this), writable: false },\r\n            // COMBAK - DEPRECATED\r\n            webcasts: { get: () => {\r\n                this.log('debug', 'webcasts is deprecated - use rev.webcast instead');\r\n                return this.webcast;\r\n            }, enumerable: false },\r\n            zones: { value: api.zones(this), writable: false }\r\n        });\r\n    }\r\n    /**\r\n     * make a REST request\r\n     */\r\n    async request<T = any>(method: Rev.HTTPMethod, endpoint: string, data: any = undefined, options: Rev.RequestOptions = { }): Promise<Rev.Response<T>> {\r\n        // support for dynamically loading fetch polyfill\r\n        if (shouldInitialize()) await onInitialize();\r\n\r\n        const url = new URL(endpoint, this.url);\r\n        // ensure url matches Rev url, to avoid sending authorization header elsewhere\r\n        if (url.origin !== this.url) {\r\n            throw new TypeError(`Invalid endpoint - must be relative to ${this.url}`);\r\n        }\r\n\r\n        let {\r\n            headers: optHeaders,\r\n            responseType,\r\n            throwHttpErrors = true,\r\n            ...requestOpts\r\n        } = options;\r\n\r\n        // setup headers for JSON communication (by default)\r\n        const headers = new polyfills.Headers(optHeaders);\r\n\r\n        // add authorization header from stored token\r\n        if (this.session.token && !headers.has('Authorization')) {\r\n            headers.set('Authorization', `VBrick ${this.session.token}`);\r\n        }\r\n        if (headers.get('Authorization') === '') {\r\n            // if Auth is explicitly set to '' then remove from list\r\n            headers.delete('Authorization');\r\n        }\r\n\r\n        const fetchOptions: RequestInit = {\r\n            mode: 'cors',\r\n            method,\r\n            ...requestOpts,\r\n            headers\r\n        };\r\n\r\n        // default to JSON request payload, but allow it to be overridden\r\n        let shouldSetAsJSON = !headers.has('Content-Type');\r\n        const normalizedMethod = method.toUpperCase();\r\n\r\n        // add provided data to request body or as query string parameters\r\n        if (data) {\r\n            if (['POST', 'PUT', 'PATCH'].includes(normalizedMethod)) {\r\n                if (typeof data === 'string') {\r\n                    fetchOptions.body = data;\r\n                } else if (data instanceof polyfills.FormData) {\r\n                    shouldSetAsJSON = false;\r\n                    fetchOptions.body = data;\r\n                } else if (isPlainObject(data) || Array.isArray(data)) {\r\n                    fetchOptions.body = JSON.stringify(data);\r\n                } else {\r\n                    fetchOptions.body = data;\r\n                }\r\n            } else if (isPlainObject(data)) {\r\n                // add values to query string of URL\r\n                for (let [key, value] of Object.entries(data)) {\r\n                    url.searchParams.append(key, value);\r\n                }\r\n            } else {\r\n                throw new TypeError(`Invalid payload for request to ${method} ${endpoint}`);\r\n            }\r\n        }\r\n\r\n        // default to JSON communication\r\n        if (!headers.has('Accept')) {\r\n            headers.set('Accept', 'application/json');\r\n        }\r\n        // set to JSON payload\r\n        if (shouldSetAsJSON) {\r\n            headers.set('Content-Type', 'application/json');\r\n        }\r\n\r\n        // OPTIONAL log request and response\r\n        this.log('debug', `Request ${method} ${endpoint}`);\r\n\r\n        if (this.session.hasRateLimits) {\r\n            switch (normalizedMethod) {\r\n                case 'GET':\r\n                    await this.session.queueRequest(RateLimitEnum.Get);\r\n                    break;\r\n                case 'POST':\r\n                case 'PATCH':\r\n                case 'PUT':\r\n                case 'DELETE':\r\n                    await this.session.queueRequest(RateLimitEnum.Post);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // NOTE: will throw error on AbortError or client fetch errors\r\n        const response = await polyfills.fetch(`${url}`, {\r\n            ...fetchOptions,\r\n            method,\r\n            headers\r\n        });\r\n\r\n        const {\r\n            ok,\r\n            status: statusCode,\r\n            statusText,\r\n            headers: responseHeaders\r\n        } = response;\r\n\r\n        // check for error response code\r\n        if (!ok) {\r\n            if (throwHttpErrors) {\r\n                const err = await RevError.create(response);\r\n                this.log('debug', `Response ${method} ${endpoint} ${statusCode} ${err.code || statusText}`);\r\n                throw err;\r\n            }\r\n            // if not throwwing then force responseType to auto (could be text or json)\r\n            responseType = undefined;\r\n        }\r\n\r\n        this.log('debug', `Response ${method} ${endpoint} ${statusCode} ${statusText}`);\r\n\r\n        let body: any = response.body;\r\n\r\n        switch (responseType) {\r\n            case 'json':\r\n                // safety check for empty response\r\n                if (`${responseHeaders.get('content-length')}` === '0') {\r\n                    body = null;\r\n                } else {\r\n                    body = await response.json();\r\n                }\r\n                break;\r\n            case 'text':\r\n                body = await response.text();\r\n                break;\r\n            case 'blob':\r\n                body = await response.blob();\r\n                break;\r\n            case 'stream':\r\n                switch (this._streamPreference) {\r\n                    case 'webstream': body = polyfills.asWebStream(response.body); break;\r\n                    case 'nativestream': body = polyfills.asPlatformStream(response.body); break;\r\n                    default: body = response.body;\r\n                }\r\n                body = response.body;\r\n                break;\r\n            case 'webstream':\r\n                body = polyfills.asWebStream(response.body);\r\n                break;\r\n            case 'nativestream':\r\n                body = polyfills.asPlatformStream(response.body);\r\n                break;\r\n            default:\r\n                // if no mimetype in response then assume JSON unless otherwise specified\r\n                body = await decodeBody(response, headers.get('Accept'));\r\n        }\r\n\r\n        return {\r\n            statusCode,\r\n            headers: responseHeaders,\r\n            body,\r\n            response\r\n        };\r\n    }\r\n    async get<T = any>(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<T> {\r\n        const { body } = await this.request('GET', endpoint, data, options);\r\n        return body;\r\n    }\r\n    async post<T = any>(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<T> {\r\n        const { body } = await this.request('POST', endpoint, data, options);\r\n        return body;\r\n    }\r\n    async put<T = any>(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<T> {\r\n        const { body } = await this.request('PUT', endpoint, data, options);\r\n        return body;\r\n    }\r\n    async patch(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<void> {\r\n        await this.request('PATCH', endpoint, data, options);\r\n    }\r\n    async delete(endpoint: string, data?: PayloadType, options?: Rev.RequestOptions): Promise<void> {\r\n        await this.request('DELETE', endpoint, data, options);\r\n    }\r\n    /**\r\n     * authenticate with Rev\r\n     */\r\n    async connect() {\r\n\r\n        // Rarely the login call will fail on first attempt, therefore this code attempts to login\r\n        // multiple times\r\n        await retry(\r\n            () => this.session.login(),\r\n            // Do not re-attempt logins with invalid user/password or rate limiting - it can lock out the user\r\n            (err: RevError) => ![401, 429].includes(err.status));\r\n    }\r\n    /**\r\n     * end rev session\r\n     */\r\n    async disconnect() {\r\n        try {\r\n            await this.session.logoff();\r\n        } catch (error) {\r\n            this.log('warn', `Error in logoff, ignoring: ${error}`);\r\n        }\r\n    }\r\n    // this should get called every 15 minutes or so to extend the connection session\r\n    async extendSession() {\r\n        return this.session.extend();\r\n    }\r\n    /**\r\n     * Returns true/false based on if the session is currently valid\r\n     * @returns Promise<boolean>\r\n     */\r\n    async verifySession() {\r\n        return this.session.verify();\r\n    }\r\n    get isConnected() {\r\n        return this.session.isConnected;\r\n    }\r\n    get token() {\r\n        return this.session.token;\r\n    }\r\n    get sessionExpires() {\r\n        return this.session.expires;\r\n    }\r\n    get sessionState() {\r\n        return this.session.toJSON();\r\n    }\r\n    set sessionState(state: Rev.IRevSessionState) {\r\n        this.session.token = `${state.token}`;\r\n        this.session.expires = new Date(state.expiration);\r\n        for (let key of ['apiKey', 'refreshToken', 'userId'] as (keyof Rev.IRevSessionState)[]) {\r\n            if (key in state) {\r\n                (this.session as any)[key] = `${state[key] || ''}`;\r\n            }\r\n        }\r\n    }\r\n    log(severity: Rev.LogSeverity, ...args: any[]) {\r\n        if (!this.logEnabled) {\r\n            return;\r\n        }\r\n\r\n        const ts = (new Date()).toJSON().replace('T', ' ').slice(0, -5);\r\n        console.debug(`${ts} REV-CLIENT [${severity}]`, ...args);\r\n    }\r\n}\r\n"],"mappings":"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","names":["src_exports","__export","RevClient","RevError","ScrollError","src_default","utils","mimeTypes","getMimeForExtension","extension","defaultType","getExtensionForMime","contentType","defaultExtension","match","ext","mime","sanitizeUploadOptions","filename","defaultContentType","name","_toString","isPlainObject","val","prototype","isBlobLike","titleCase","val","uploadParser","value","options","url","file","polyfills_default","contentType","response","body","headers","RevError","filename","defaultContentType","sanitized","sanitizeUploadOptions","isBlobLike","appendJSONToForm","form","fieldName","data","appendFileToForm","input","uploadOptions","uploadMultipart","rev","method","endpoint","optHeaders","randomValues","byteLength","values","c","sha256Hash","value","bytes","hashed","binary","hmacSign","message","secret","enc","cryptoKey","signed","polyfills","uploadParser","form","headers","uploadOptions","options","stream","polyfills_default","isPendingInitialize","initializePromise","pendingInitialize","shouldInitialize","onInitialize","pending","overrides","setPolyfills","overrideCallback","ONE_MINUTE","rateLimit","fn","options","perSecond","perMinute","perHour","signal","limit","interval","queue","currentTick","activeCount","throttled","args","timeout","resolve","reject","execute","now","abortHandler","message","dispose","polyfills_default","rate_limit_default","defaultRateLimits","fn","normalizeRateLimitOptions","rateLimits","makeQueue","key","value","defaultValue","perMinute","limit","rate_limit_default","makeQueues","entries","clearQueues","message","asValidDate","val","defaultValue","retry","fn","shouldRetry","maxAttempts","sleepMilliseconds","attempt","err","sleep","ms","signal","done","timer","cleanup","tryParseJson","RevError","_RevError","response","body","status","statusText","url","isPlainObject","code","detail","tryParseJson","err","ScrollError","PagedRequest","options","items","current","total","err","onProgress","onError","signal","page","result","done","error","maxResults","pageCount","results","hit","decodeBody","response","acceptType","contentType","contentLength","SearchRequest","PagedRequest","rev","searchDefinition","query","options","items","current","total","hitsKey","err","_ignore","queryOpt","endpoint","totalKey","isPost","request","transform","requestFn","scrollId","rawItems","statusCode","statusDescription","done","error","ScrollError","adminAPIFactory","rev","roles","customFields","adminAPI","cache","response","name","fromCache","role","r","field","cf","registrationField","fieldId","query","options","searchDefinition","SearchRequest","schedules","videoId","params","parseCSV","raw","cur","inQuote","fieldQuoted","field","row","out","i","n","processField","headers","line","obj","parseEntry","line","tryParseJson","AuditRequest","PagedRequest","rev","endpoint","label","toDate","fromDate","beforeRequest","options","items","current","total","from","to","response","body","headers","parseCSV","done","asValidDate","defaultFrom","auditAPIFactory","rev","optRateLimits","requestsPerMinute","normalizeRateLimitOptions","makeOptTransform","opts","lock","makeQueue","req","locks","accountId","options","AuditRequest","userId","groupId","deviceId","videoId","eventId","mergeHeaders","source","other","merged","polyfills_default","value","key","PLACEHOLDER","getOAuth2AuthorizationUrl","config","code_challenge","state","url","getOAuth2PKCEVerifier","codeVerifier","polyfills_default","codeChallenge","buildLegacyOAuthQuery","oauthSecret","hmacSign","RESPONSE_TYPE","apiKey","redirectUri","verifier","signature","parseLegacyOAuthRedirectResponse","query","authCode","error","authAPIFactory","rev","authAPI","apiKey","secret","options","username","password","userId","jwtToken","webcastId","opts","mergeHeaders","config","state","verifier","codeChallenge","codeVerifier","getOAuth2PKCEVerifier","getOAuth2AuthorizationUrl","code","oauthSecret","query","buildLegacyOAuthQuery","url","parseLegacyOAuthRedirectResponse","authCode","GRANT_AUTH","redirectUri","refreshToken","GRANT_REFRESH","categoryAPIFactory","rev","category","categoryId","parentCategoryId","includeAllDescendants","payload","categories","channelAPIFactory","rev","channel","channelId","start","options","ChannelListRequest","members","operations","member","searchText","searchDefinition","query","SearchRequest","items","current","total","params","maxResults","onProgress","delta","results","hit","deviceAPIFactory","rev","dme","deviceId","groupAPIFactory","rev","groupAPI","group","groupId","searchText","options","searchDefinition","hits","formatGroupSearchHit","query","SearchRequest","userIds","result","userId","out","details","error","hit","getSummaryFromResponse","response","hitsKey","ignoreKeys","key","value","PlaylistDetailsRequest","SearchRequest","rev","playlistId","query","options","searchDefinition","endpoint","videos","playlistAPIFactory","rev","name","videos","payload","playlistId","query","options","PlaylistDetailsRequest","actions","parsePlaylist","entry","id","featurePlaylistId","featuredPlaylist","playlistName","extra","rawResult","hasFeatured","output","isPlainObject","recordingAPIFactory","rev","sipAddress","sipPin","title","videoId","status","payload","result","isPlainObject","request","scheduledRecordingId","recordingId","splitOptions","options","defaultType","filename","contentType","contentLength","useChunkedTransfer","defaultContentType","requestOptions","uploadAPIFactory","rev","FormData","polyfills_default","file","metadata","uploadOptions","form","defaultUsername","appendJSONToForm","filePayload","appendFileToForm","videoId","uploadMultipart","language","lang","chapters","action","chapter","title","time","imageFile","fileUploadOptions","chapterEntry","userAPIFactory","rev","details","userLookupValue","options","lookupType","requestOptions","query","userAPI","user","userId","username","email","type","response","groupId","operations","searchText","assignable","searchDefinition","items","formatUserSearchHit","SearchRequest","id","unread","notificationId","sortField","sortOrder","Users","hit","DEFAULT_INCREMENT","DEFAULT_SORT","addDays","date","numDays","d","parseOptions","options","incrementDays","sortDirection","videoIds","startDate","endDate","otherOptions","s","parseDates","startArg","endArg","now","asValidDate","VideoReportRequest","PagedRequest","rev","endpoint","isAscending","rangeStart","rangeEnd","done","query","items","value","videoReportAPI","report","videoId","isPlainObject","summaryStatistics","payload","videoDownloadAPI","rev","download","videoId","options","downloadChapter","chapter","imageUrl","body","downloadSupplemental","fileId","endpoint","isPlainObject","opts","downloadTranscription","language","downloadThumbnail","query","imageId","thumbnailUrl","videoExternalAccessAPI","rev","videoId","q","options","searchDefinition","payload","SearchRequest","request","videoAPIFactory","rev","comments","videoId","showAll","videoAPI","title","payload","customField","options","metadata","chapters","err","RevError","supplementalFiles","transcriptionFiles","requestOptions","query","searchDefinition","endpoint","SearchRequest","videos","result","rawVideo","out","details","error","video","ip","userAgent","opts","mergeHeaders","videoDownloadAPI","videoReportAPI","videoExternalAccessAPI","removedSegments","keepRanges","operations","fields","description","language","transcriptionId","source","target","status","locale","s","trackIndex","id","audioTracks","index","t","op","pollIntervalSeconds","timeoutMinutes","signal","ignorePlaybackWhileTranscoding","onProgress","onError","ONE_MINUTE","timeoutDate","pollInterval","statusResponse","isProcessing","overallProgress","sleep","getSummaryFromResponse","response","hitsKey","ignoreKeys","key","value","RealtimeReportRequest","SearchRequest","rev","eventId","query","options","searchDefinition","endpoint","summary","PostEventReportRequest","runNumber","runQuery","statusCode","body","RevError","webcastAPIFactory","rev","webcastAPI","options","requestOptions","query","searchDefinition","endpoint","SearchRequest","event","eventId","entities","runNumber","PostEventReportRequest","RealtimeReportRequest","rawResponse","polls","response","ip","userAgent","opts","mergeHeaders","playbackResults","preProduction","videoId","autoRedirect","payload","registrationId","registration","operations","key","value","titleCase","banners","banner","bannerId","isEnabled","id","zonesAPIFactory","rev","zonesAPI","defaultZone","zones","flatZones","recursiveAdd","inZone","childZones","zone","zoneId","environmentAPIFactory","rev","accountId","version","ulsInfo","forceRefresh","text","error","timeoutMs","controller","getIp","ulsUrl","ip","timer","ONE_MINUTE","_credentials","SessionKeepAlive","session","options","expires","interval","threshold","timeTillExpiration","controller","signal","nextExtendTime","sleep","err","oldController","polyfills_default","SessionBase","rev","credentials","keepAliveOptions","rateLimits","isPlainObject","rateLimitQueues","makeQueues","expiration","shouldVerify","timeLeft","error","queue","message","clearQueues","OAuthSession","oauthConfig","authCode","token","refreshToken","userId","OAuth2Session","code","codeVerifier","expires_in","expiresTime","UserSession","username","password","ApiKeySession","apiKey","secret","JWTSession","jwtToken","GuestRegistrationSession","webcastId","guestRegistrationToken","AccessTokenSession","createSession","rev","credentials","keepAliveOptions","rateLimits","session","sessionState","publicOnly","creds","token","expiration","refreshToken","userId","now","expires","hasSession","isOAuth2Login","isLegacyOauthLogin","isApiKeyLogin","isUsernameLogin","isJWTLogin","isGuestRegistration","OAuth2Session","OAuthSession","ApiKeySession","JWTSession","GuestRegistrationSession","UserSession","AccessTokenSession","RevClient","options","isPlainObject","url","log","logEnabled","keepAlive","rateLimits","defaultStreamPreference","credentials","urlObj","createSession","severity","args","adminAPIFactory","auditAPIFactory","authAPIFactory","categoryAPIFactory","channelAPIFactory","deviceAPIFactory","environmentAPIFactory","groupAPIFactory","playlistAPIFactory","recordingAPIFactory","uploadAPIFactory","userAPIFactory","videoAPIFactory","webcastAPIFactory","zonesAPIFactory","method","endpoint","data","shouldInitialize","onInitialize","optHeaders","responseType","throwHttpErrors","requestOpts","headers","polyfills_default","fetchOptions","shouldSetAsJSON","normalizedMethod","key","value","response","ok","statusCode","statusText","responseHeaders","err","RevError","body","decodeBody","retry","error","state","ts","utils","rate_limit_default","getExtensionForMime","getMimeForExtension","setPolyfills","src_default","RevClient"]}